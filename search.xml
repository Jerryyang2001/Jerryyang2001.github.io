<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2021/02/18/study/Math/ComplexFunctions/index/</url>
    <content><![CDATA[
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>GCN introduction</title>
    <url>/2020/11/04/KGCode/gcn/</url>
    <content><![CDATA[<p>图卷积神经网络</p>
<span id="more"></span>
<h1 id="graph-convolutional-network">Graph Convolutional Network</h1>
<blockquote>
<p>翻译自：<a href="http://tkipf.github.io/graph-convolutional-networks/">Graph Convolutional Networks | Thomas Kipf | University of Amsterdam</a></p>
</blockquote>
<h3 id="概述">概述</h3>
<p>现实世界中许多重要的数据（集）常常以图和网络的形式呈现，例如：社交网络，知识图谱，蛋白质相互作用网络，万维网等等（只举几例）。但是，直到最近，注意力很少放在对这些结构化的数据，建立泛化的神经网络模型之上。</p>
<p>最近几年，一些论文重新考虑了这些问题（统一的神经网络，去处理任意的结构化图数据） <a href="http://arxiv.org/abs/1312.6203">Bruna et al.</a>, ICLR 2014; <a href="http://arxiv.org/abs/1506.05163">Henaff et al.</a>, 2015; <a href="http://papers.nips.cc/paper/5954-convolutional-networks-on-graphs-for-learning-molecular-fingerprints">Duvenaud et al.</a>, NIPS 2015; <a href="https://arxiv.org/abs/1511.05493">Li et al.</a>, ICLR 2016; <a href="https://arxiv.org/abs/1606.09375">Defferrard et al.</a>, NIPS 2016; <a href="http://arxiv.org/abs/1609.02907">Kipf &amp; Welling</a>, ICLR 2017，其中一些，现在已经在他们主导的领域，取得了非常可喜的成果。</p>
<p>在这篇文章中，我将对近些年在这方面的研究给出一个概要，并且指出不同方法的优缺点。这些讨论主要聚焦于最近发表的这两篇论文：</p>
<ul>
<li>Kipf &amp; Welling (ICLR 2017), <a href="http://arxiv.org/abs/1609.02907">Semi-Supervised Classification with Graph Convolutional Networks</a> (disclaimer: I'm the first author)</li>
<li>Defferrard et al. (NIPS 2016), <a href="https://arxiv.org/abs/1606.09375">Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering</a></li>
</ul>
<p>以及 Ferenc Huszar 写的一篇回顾/讨论的文章：<a href="http://www.inference.vc/how-powerful-are-graph-convolutions-review-of-kipf-welling-2016-2/">How powerful are Graph Convolutions?</a> ，这篇文章主要讨论了这几类模型的一些限制。我<a href="http://tkipf.github.io/graph-convolutional-networks/#the-issue-with-regular-graphs">在这里</a>写了一点对这篇文章的评论（在文章的末尾）。</p>
<h3 id="大纲">大纲</h3>
<ul>
<li>对GNN的简单描述</li>
<li>谱域卷积与GCNs</li>
<li>Demo：简单一阶GCN模型的图嵌入</li>
<li>将 GCNs 作为 <em>Weisfeiler-Lehman</em> 算法的可微分</li>
</ul>
<p>如果你已经熟悉了 GCNs 与相关的方法，你可以直接跳到<a href="http://tkipf.github.io/graph-convolutional-networks/#gcns-part-iii-embedding-the-karate-club-network">Embedding the karate club network</a>。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>GCN</tag>
      </tags>
  </entry>
  <entry>
    <title>KGCode Intro</title>
    <url>/2020/08/20/KGCode/intro/</url>
    <content><![CDATA[<p>For KGCode</p>
<span id="more"></span>
<h1 id="kgcode">KGCode</h1>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>KGCode</category>
      </categories>
      <tags>
        <tag>KGCode</tag>
      </tags>
  </entry>
  <entry>
    <title>知识融合简述</title>
    <url>/2020/11/01/KGCode/kginteraction/</url>
    <content><![CDATA[<p>知识融合方法概述</p>
<span id="more"></span>
<h1 id="知识融合">知识融合</h1>
<h3 id="问题分析">问题分析</h3>
<h5 id="知识图谱的异构">知识图谱的异构</h5>
<p>从KG的构建看：</p>
<ol type="1">
<li>早期知识工程的理想是构建一个统一的知识库</li>
<li>人类知识体系复杂</li>
<li>不同人对某些知识由主观看法</li>
<li>知识会随时间自然演化</li>
<li>同一领域由不同组织构建自己的知识库</li>
<li>交叉领域中的交叉只是往往是独立构建</li>
<li>知识图谱构建优先考虑重用现有知识</li>
</ol>
<p>从KG应用的角度看：</p>
<ol type="1">
<li>不同领域的系统需要进行交互</li>
<li>系统需要处理来自不同领域的知识</li>
</ol>
<blockquote>
<p>知识具有共享性的同时，还需要兼顾自治性和动态性，知识的构建过程中和应用场景决定了知识异构是一种自然现象，不能完全消除。</p>
</blockquote>
<p>知识异构的两个层次：</p>
<ol type="1">
<li>语言曾异构：语法、逻辑、表达能力不匹配
<ul>
<li>语法异构：采用不同的描述语言</li>
<li>逻辑异构：逻辑表示不匹配</li>
<li>元语异构：元语的语义有差异</li>
<li>表达能力异构：不同语言表达能力的差异</li>
</ul></li>
<li>模型层异构：概念化、解释不匹配
<ul>
<li>概念化异构</li>
<li>解释不匹配</li>
</ul></li>
</ol>
<h5 id="知识图谱中的数据特点">知识图谱中的数据特点</h5>
<p>KG：</p>
<ul>
<li>包含语义信息、推理</li>
<li>形式更加灵活、扩展性</li>
</ul>
<blockquote>
<ul>
<li>包含一定的抽象层知识和大量的实力层事实</li>
<li>知识图谱中的知识融合要考虑两个层次的融合问题</li>
</ul>
</blockquote>
<h5 id="why-知识融合">Why 知识融合</h5>
<ol type="1">
<li>数据清洗
<ul>
<li>构建知识图谱可能存在异构</li>
<li>KG应用的预处理</li>
</ul></li>
<li>数据集成
<ul>
<li>需要同时利用或融合多个不同来源的知识图谱</li>
<li>不同源的知识图谱可能存在重叠的知识</li>
</ul></li>
</ol>
<h5 id="目标">目标</h5>
<p>合并多个知识图谱</p>
<ol type="1">
<li>解决本体的匹配
<ul>
<li>等价类、子类</li>
<li>等价属性、子属性</li>
</ul></li>
<li>解决实力层的匹配
<ol type="1">
<li>等价实例</li>
</ol></li>
</ol>
<p>复杂映射</p>
<ol type="1">
<li>语义映射
<ul>
<li>（复杂）概念的上下文</li>
<li>属性的上下文</li>
</ul></li>
<li>函数映射
<ul>
<li>计算函数</li>
<li>合并函数</li>
<li>复杂函数</li>
</ul></li>
</ol>
<p>映射的势：<code>1 : 1 or N : M</code></p>
<h3 id="解决思路">解决思路</h3>
<h5 id="本体匹配">本体匹配</h5>
<p>本体匹配框架</p>
<figure>
<img src="/2020/11/01/KGCode/kginteraction/assets\image-20201101214147985.png" class="lazyload" data-srcset="/2020/11/01/KGCode/kginteraction/assets\image-20201101214147985.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201101214147985"><figcaption aria-hidden="true">image-20201101214147985</figcaption>
</figure>
<ul>
<li>预处理：解析、清洗、构造基础数据</li>
<li>匹配计算：<strong>构造匹配搜索，相似度计算</strong></li>
<li>后处理：<strong>匹配结果抽取</strong>，匹配调谐</li>
</ul>
<h6 id="基础匹配器">基础匹配器：</h6>
<p><strong>字符串匹配器</strong></p>
<ul>
<li>编辑距离、最小编辑距离（Levenshtein distance）</li>
<li>Wagner and Fisher distance: 类似于Levenshtein distance，但给予del ins sub 不同的权重</li>
<li>汉明距离：<span class="math inline">\(\displaystyle{\delta(s,t)=1-\frac{(\sum_{i=1}^{\min(|s|,|t|)}s[i]\ne t[i])+||s||-||t||}{\max (|s|,|t|)}}\)</span></li>
<li>字串相似度：<span class="math inline">\(\delta(s,t)=\displaystyle\frac {2|x|}{|s|+|t|}\)</span></li>
<li>Dice 系数（用于度量两个集合的相似性）：<span class="math inline">\(sim_{Dice}(s,t)=\displaystyle\frac {2|s\cap t|}{|s|+|t|}\)</span></li>
<li>Jaccard 系数（与Dice系数相似）：<span class="math inline">\(sim(s,t)=\displaystyle\frac{|S\cap T|}{|S\cup T|}\)</span></li>
<li>N-Gram</li>
</ul>
<h6 id="文本匹配器">文本匹配器</h6>
<ul>
<li>TF-IDF：评估某个字或者某个词对于一个文档的重要程度</li>
<li>思想：将文档变为向量的形式，通过向量相似度实现文档匹配</li>
<li>本体中的概念和属性往往由大量相关的文本信息标签、注释、描述等等</li>
<li>带匹配的对象的相关文本组织为文档形式，再转化为文档向量</li>
<li>实际应用中非常有效，能解决很多实际应用场景</li>
</ul>
<blockquote>
<p>虚拟文档</p>
</blockquote>
<h6 id="结构匹配器">结构匹配器</h6>
<ul>
<li>思想：利用本体的结构信息来弥补文本信息量不足的情况</li>
<li></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>KGCode</category>
      </categories>
      <tags>
        <tag>KGCode</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈编程</title>
    <url>/2020/06/24/talk-chat/AboutProgramming1/</url>
    <content><![CDATA[<p>编程十载。</p>
<span id="more"></span>
<p>笔者江苏南京人，小学听人说编程有点意思随便学了点 <code>Basic</code>，觉着程序设计挺有趣，便一直没有放下编程的学习。当时挺自信，用 <code>Basic</code> 也能写点东西，虽然看上去不怎样，却能解决点实际问题：</p>
<blockquote>
<p>Q：解不定方程：2 x + 3 y = 100, x y 是正整数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR I = 1 TO 50</span><br><span class="line">    FOR J = 1 TO 33</span><br><span class="line">        IF 2*I+3*J = 100 THEN</span><br><span class="line">            PRINT I</span><br><span class="line">            PRINT J</span><br><span class="line">        END IF</span><br><span class="line">    NEXT J</span><br><span class="line">NEXT I</span><br></pre></td></tr></table></figure>
<p>Well，写的不好，但是至少我知道怎样去解决一些问题。要解这个方程实际上不需要这么麻烦。但是当时学到的确实是解决问题的方法：编一个程序、枚举各种情况、得到答案。</p>
<p>当然，如果我们仔细看一看这一个程序，实则三种最基础的程序结构都有：</p>
<ol type="1">
<li>顺序：<code>PRINT I PRINT J</code></li>
<li>分支：<code>IF ... THEN ... (ELSE ...) END IF</code></li>
<li>循环：<code>FOR I = 1 TO 50 NEXT I</code></li>
</ol>
<p>确实，我们需要这三种结构就能创建整个程序了，至少当时的我，还能记得，这三个程序足以撑起你需要的一切。</p>
<p>上了初中，接触的是 <code>Pascal</code>，勉强写了两年，就跳去学“高大上”的 <code>C++</code> 了，做点对比：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b,c: int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">foo</span><span class="params">(para: int)</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">writeln</span><span class="params">(para+1)</span></span></span><br><span class="line"><span class="function"><span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    readln(a, b, c);</span><br><span class="line">    foo(a);</span><br><span class="line">    foo(b);</span><br><span class="line">    foo(c);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para)</span> </span>&#123; cout &lt;&lt; para; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="built_in">foo</span>(a);<span class="built_in">foo</span>(b);<span class="built_in">foo</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时写的也是懵懵懂懂的，但也能说出些道道来：什么是函数，什么是形参实参之类的。当然，这些只是为了应付当年的 <code>NOIP</code> 比赛（现<code>csp</code>），写的程序里面大多是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10000000</span>];</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt; a[i];</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时还是挺自信，这玩意挺好啊，能解决问题，在赛场上也能拿点分。但是到了大学就不一样了。<code>c++</code> 程设这门课主要难点在于 <code>OOP</code> 与动态内存部分，各种 bug 都来了，我还记得，当时上的最多的网站：<a href="https://docs.microsoft.com/zh-cn/">Docs</a>，是微软的技术文档，每天沉浸在理解、记忆如何去写一个可以编译的程序之中，觉得生活确实充实。</p>
<p>但是如果你问我，到底学到了什么，我只能说，我学会了如何写出一个能够编译的 cpp。</p>
<p>疫情期间，有更多的时间看了看国外的开放课程（MIT Open Course），例如：</p>
<p><code>Intro to EECS 6.01I MIT</code>：计科、电子方向的导论课</p>
<p>讲的很浅显易懂，大概涉及以下几个方面</p>
<blockquote>
<p><strong>Topics</strong></p>
<ul>
<li>State Machine</li>
<li>Differential Equations and Operations</li>
<li>Circuit</li>
<li>... ...</li>
</ul>
</blockquote>
<p>在第一节课，教授指出了这门课的目的：形成思维方法，从以下几个方面去思考问题和知识。</p>
<ul>
<li>Primitives（原语）</li>
<li>Combination（组合）</li>
<li>Abstractions（抽象）</li>
<li>Patterns（模式）</li>
</ul>
<p>以电路为例</p>
<blockquote>
<p><strong>Example (Circuit)</strong></p>
<ul>
<li>Primitives
<ul>
<li>Ohm's Law</li>
<li>Node</li>
</ul></li>
<li>Combination
<ul>
<li>KVL KCL Equations</li>
<li>Node method, Loop method</li>
</ul></li>
<li>Abstractions
<ul>
<li>Parallel Combinations</li>
<li>Series Combinations</li>
</ul></li>
<li>Patterns
<ul>
<li>in Series Combinations: <span class="math inline">\(I = V / (R_1 + R_2)\)</span></li>
<li>in Parallel Combinations: <span class="math inline">\(V_1 = R_1 I,\dots\)</span></li>
</ul></li>
</ul>
</blockquote>
<figure class="highlight lua"><figcaption><span>FunctionalProgramming.lua</span><a href="/code/RandomTalks/AboutProgramming1/FunctionalProgramming.lua">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">get_accumulator</span><span class="params">(start)</span></span></span><br><span class="line">    start = start <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        start = start + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> acc = get_accumulator()</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(acc())</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 建站实录</title>
    <url>/2020/08/13/talk-chat/Hexo/</url>
    <content><![CDATA[<p>建站实录</p>
<span id="more"></span>
<h1 id="hexo">Hexo</h1>
<h3 id="前言">前言</h3>
<p>需要准备的材料：</p>
<ol type="1">
<li><p>vscode</p>
<ul>
<li>VSCode 的终端内，要换成<code>cmd.exe</code>，按下 <code>ctrl + ,</code> 进入设置，找到 <code>terminal.external.windowsExec</code>这个，修改为 <code>C:\Windows\System32\cmd.exe</code></li>
</ul></li>
<li><p>Node.js</p>
<blockquote>
<p>安装完成后需要执行：<code>npm config set registry https://registry.npm.taobao.org</code>，来重新定向源。</p>
</blockquote></li>
<li><p>Git客户端、以及一个配置好的 Github 账号</p></li>
</ol>
<h3 id="站点建立">站点建立</h3>
<blockquote>
<p>https://docs.github.com/en/github/working-with-github-pages</p>
</blockquote>
<ul>
<li>安装Git
<ul>
<li>Git 的配置</li>
</ul></li>
<li>安装Node.js</li>
<li>安装Hexo</li>
<li>GitHub创建个人仓库</li>
</ul>
<p>Git：在<a href="https://npm.taobao.org/mirrors/git-for-windows/v2.28.0.windows.1/">Mirror</a>中下载，并安装 <code>Git-2.28.0-64-bit.exe</code>（中间都是直接点击下一步即可）</p>
<p>Node.js：在<a href="https://npm.taobao.org/mirrors/node/latest-v14.x/">Mirror</a>中下载，并安装 <code>node-v14.8.0-x64.msi</code>。</p>
<p>第一步，为你的站点设置一个代码仓库：</p>
<blockquote>
<p><a href="https://docs.github.com/en/github/working-with-github-pages/creating-a-github-pages-site#creating-a-repository-for-your-site">Ref</a></p>
</blockquote>
<p>第二步，站点初始化</p>
<blockquote>
<p><a href="https://docs.github.com/en/github/working-with-github-pages/creating-a-github-pages-site#creating-your-site">Ref</a></p>
<p>Note: It can take up to 20 minutes for changes to your site to publish after you push the changes to GitHub. If your don't see your changes reflected in your browser after an hour, see "About Jekyll build errors for GitHub Pages sites."</p>
<p>部署需要时间、每小时最多部署10次，站点大小最多1G（图片不能太多太大，搞大型个人相册就免了）</p>
</blockquote>
<p>第三步，找一个地方，专门存放你的这个站点，例如：<code>D:/repos/</code> 在这个文件夹中 clone 下你的这个仓库。并且在 VScode 中打开这个<strong>仓库</strong></p>
<p>在这里，按照：</p>
<blockquote>
<p><a href="https://hexo.io/zh-cn/docs">Ref</a> 安装 Hexo。</p>
</blockquote>
<blockquote>
<p><a href="https://hexo.io/zh-cn/docs/setup">Ref</a> 在本机上建立站点</p>
</blockquote>
<p>注意，因为直接在git下的目录中打开code，所以其中的folder就是 <code>.</code> （当前文件夹）不用执行cd切换工作文件夹，也就是（在VScode 终端中执行）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init .</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<ul>
<li>初次尝试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s --debug <span class="comment"># 显示debug反馈</span></span><br><span class="line">hexo s <span class="comment"># 精简模式</span></span><br></pre></td></tr></table></figure>
<p>应当显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p><code>ctrl + 鼠标左键</code> 点击链接看看？</p>
<p>deploy 配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:Jerryyang2001/Jerryyang2001.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment"># 注意是 master 分支</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">Site</span> <span class="string">updated:&#123;&#123;</span> <span class="string">now(&#x27;YYYY-MM-DD</span> <span class="string">HH:mm:ss&#x27;)</span> <span class="string">&#125;&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>站点配置
<ul>
<li><code>_config.yml</code></li>
<li>实际上就按照 readme 走就行。</li>
</ul></li>
<li>更换主题（以我现在用的 <code>Fluid</code> 为例）
<ul>
<li>注意看文档就行</li>
<li>主题配置</li>
</ul></li>
<li>发布文章
<ul>
<li>Hexo 工作流</li>
<li><code>yaml</code></li>
<li><code>&lt;!-- more --&gt;</code>用法</li>
</ul></li>
<li>个性化设置
<ul>
<li>搜索器</li>
<li>Mathjax</li>
<li>Valine</li>
<li>思维导图</li>
</ul></li>
<li>其他
<ul>
<li>code Snippet</li>
</ul></li>
<li>附录</li>
</ul>
<blockquote>
<p>参考了部分：<a href="https://zhuanlan.zhihu.com/p/26625249">Ref</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>物理学绪论</title>
    <url>/2020/06/08/study/Physics/Ch0Pre/</url>
    <content><![CDATA[<p>基础物理学 绪论</p>
<span id="more"></span>
<h2 id="什么是物理">什么是物理</h2>
<h2 id="学习物理的目的">学习物理的目的</h2>
<h2 id="矢量代数基本知识">矢量代数基本知识</h2>
<h3 id="标量">标量</h3>
<p>只有大小（正负均可）</p>
<h3 id="矢量">矢量</h3>
<p>大小方向（一定是正值）</p>
<h3 id="矢量的书写">矢量的书写</h3>
<p><span class="math inline">\(\vec{A}\)</span>或<span class="math inline">\(\pmb{A}\)</span></p>
<p><span class="math inline">\(A\vec{e_A}\)</span></p>
<h3 id="矢量表示方法">矢量表示方法</h3>
<ol type="1">
<li><p>几何表示：有向线段</p></li>
<li><p>解析表示：（直角坐标系）</p>
<p><span class="math inline">\(\vec{A}=A_x\vec{i}+A_y\vec{j}+A_z\vec{k}\)</span></p></li>
</ol>
<h3 id="矢量方向">矢量方向</h3>
<p><span class="math inline">\(\cos \alpha = \frac{A_x}{|A|}\)</span></p>
<h3 id="矢量运算">矢量运算</h3>
<ol type="1">
<li>加法、减法</li>
<li>乘法
<ol type="1">
<li>点乘</li>
<li>叉乘</li>
</ol></li>
</ol>
<h3 id="矢量的求导积分">矢量的求导、积分</h3>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>质点运动学</title>
    <url>/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/</url>
    <content><![CDATA[<p>想当初，我还做了这么多笔记？</p>
<span id="more"></span>
<h2 id="质点运动的描述">质点运动的描述</h2>
<blockquote>
<p><strong>力学</strong>：研究机械运动(宏观物体之间或物体内各部分之间的相对位置的变动)。</p>
<p><strong>运动学</strong>：研究物体运动的描述及运动学量间的关系。</p>
<p><strong>动力学</strong>：研究物体运动与物体间相互作用间的联系。</p>
<p><strong>静力学</strong>：研究物体在相互作用下的平衡问题。</p>
</blockquote>
<h3 id="质点参考系和坐标系">质点、参考系和坐标系</h3>
<h4 id="质点-理想化的模型">质点 (理想化的模型)</h4>
<p>若物体的形状和大小可以忽略，则可视为一个<strong>具有一定质量的几何点</strong>。</p>
<p>物体可看作质点来处理的条件：</p>
<ul>
<li>作平动的物体</li>
<li>两物体间的距离远大于物体本身的线度</li>
</ul>
<h4 id="参考系-运动具有相对性">参考系 (运动具有相对性)</h4>
<p>研究物体运动时所选定的参照物体。</p>
<blockquote>
<p>运动具有相对性(relativity)，为此研究运动时需选定参考系(reference system)，为确定各时刻物体相对参考系的位置需建立坐标系(coordinate system)。</p>
</blockquote>
<h4 id="坐标系">坐标系</h4>
<p>定量表示物体的位置。</p>
<h3 id="质点运动的矢量描述位移速度加速度">质点运动的矢量描述（位移、速度、加速度）</h3>
<h4 id="位置矢量位矢径矢-position-vector">位置矢量(位矢、径矢 Position Vector)</h4>
<p>从坐标原点<span class="math inline">\(O\)</span>指向质点所在位置<span class="math inline">\(P\)</span>的有向线段，表征在空间某个质点 $ P $ 的位置的矢量<span class="math inline">\(\vec{r}=\vec{OP}\)</span>.</p>
<p><strong>大小（模）：</strong><span class="math inline">\(r=\sqrt{x^{2}+y^{2}+z^{2}}\)</span></p>
<p><strong>方向：</strong><span class="math inline">\(\cos \alpha=\frac{x}{r} ,\quad \cos \beta=\frac{y}{r} ,\quad \cos \gamma=\frac{z}{r}\)</span></p>
<h4 id="运动方程">运动方程</h4>
<p><span class="math inline">\(\pmb{r}=\pmb{r}(t)=x(t) \pmb{i}+y(t) \pmb{j}+z(t) \pmb{k}\)</span></p>
<p>参数方程：<span class="math inline">\(x=x(t) \quad y=y(t) \quad z=z(t)\)</span> 从中小区参数<span class="math inline">\(t\)</span>可以得到质点运动的轨道方程</p>
<h4 id="位移反映位置的变化">位移（反映位置的变化）</h4>
<blockquote>
<p>时间间隔内质点位置的变化 <span class="math inline">\(\Delta \pmb{r} = \pmb{r}(t+\Delta t) - \pmb{r}(t).\)</span></p>
<p>当质点在空间运动时，位矢<span class="math inline">\(r\)</span> 是时间<span class="math inline">\(t\)</span>的函数，<span class="math inline">\(\pmb{r}=\pmb{r}(t).\)</span> (1,1)</p>
</blockquote>
<p>在时刻<span class="math inline">\(t\)</span>，质点位矢为<span class="math inline">\(\pmb{r}_A = \pmb{r}(t)\)</span>;</p>
<p>在时刻<span class="math inline">\(t+\Delta t\)</span>,质点位矢为<span class="math inline">\(\pmb{r}_B=\pmb{r}(t+\Delta t)\)</span></p>
<p>于是，质点在时间间隔<span class="math inline">\(\Delta t\)</span>内的位置变化，可以用自 A 到 B 的矢量<span class="math inline">\(\Delta \pmb{r}\)</span>来表示，即<span class="math inline">\(\Delta \pmb{r} = \pmb{r}(t+\Delta t) - \pmb{r}(t).\)</span></p>
<figure>
<img src="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01a_1.png" class="lazyload" data-srcset="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01a_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="png"><figcaption aria-hidden="true">png</figcaption>
</figure>
<p>在直角坐标系中：</p>
<p><span class="math display">\[
\begin{aligned}
\Delta \pmb{r}&amp;=\Delta x \pmb{i}+\Delta \pmb{y}+\Delta z \pmb{k}
\\
|\Delta \pmb{r}|&amp;=\sqrt{\Delta x^{2}+\Delta y^{2}+\Delta z^{2}}
\end{aligned}
\]</span></p>
<p><strong>注意：</strong></p>
<ol type="1">
<li><span class="math inline">\(\widehat{A B}\)</span> 路程（标量） <span class="math inline">\(\Delta \pmb{r}\)</span>​ 位移（矢量）</li>
<li><span class="math inline">\({\pmb{r}}\)</span> 位矢、与坐标原点有关 <span class="math inline">\({\Delta \pmb{r}}\)</span> 位移、与坐标原点无关</li>
<li>${||} $ 位矢增量的大小 <span class="math inline">\({|\Delta r|}\)</span> 位矢大小的增量</li>
</ol>
<h4 id="速度velocity反映质点运动的快慢和方向">速度（Velocity）——反映质点运动的快慢和方向</h4>
<p><strong>平均速度</strong>（单位时间内质点的位移）：<span class="math inline">\(\bar{v}=\frac{\Delta \pmb{r}}{\Delta t}.\)</span></p>
<p><strong>瞬时速度</strong>（质点某时刻的速度）：<span class="math inline">\(v=\lim \limits_{\Delta t \to 0}\frac{\Delta \pmb{r}}{\Delta t}\)</span></p>
<blockquote>
<p>直角坐标系中 <span class="math inline">\(\vec{v}=v_{x} \vec{i}+v_{y} \vec{j}+v_{z} \vec{k}\)</span></p>
<p>大小：<span class="math inline">\(v=|\vec{v}|=\sqrt{v_{x}^{2}+v_{y}^{2}+v_{z}^{2}}\)</span></p>
<p>方向：为轨道上质点所在处切线方向并指向前进的一侧</p>
</blockquote>
<p><strong>速率</strong>：</p>
<ul>
<li><p>平均速率：<span class="math inline">\(\bar{v}=\frac{\Delta s}{\Delta t}\)</span></p></li>
<li><p>瞬时速率：<span class="math inline">\(v=|v|=\lim\limits_{\Delta t \to 0} \frac{|\Delta \pmb{r}|}{\Delta t}=\lim\limits_{\Delta t \to 0} \frac {\Delta s}{\Delta t}=\frac{ds}{dt}\)</span></p>
<p>注意：一般情况下：<span class="math inline">\(|\Delta \pmb{r}| \neq \Delta s \quad |\pmb{v}| \neq \bar{v}\)</span></p>
<p>​ 当<span class="math inline">\(\Delta t \to 0\)</span> 时：<span class="math inline">\(|\Delta \vec{r}| \rightarrow|\mathrm{d} \vec{r}|=\mathrm{d} s \quad|\vec{v}|=v\)</span></p></li>
</ul>
<h4 id="加速度acceleration反映瞬时速度的变化">加速度（Acceleration）——反映瞬时速度的变化</h4>
<p>平均加速度：<span class="math inline">\(\bar{a}=\frac{\pmb{v}_2-\pmb{v}_1}{\Delta t}=\frac{\Delta \pmb{v}}{\Delta t}\)</span></p>
<p>瞬时加速度：<span class="math inline">\(a=\lim\limits_{\Delta t \to 0}\frac{v_b-v_a}{\Delta t}=\lim\limits_ {\Delta t \to 0} \frac{\Delta \pmb{v}}{\Delta t}=\frac{d^2 r}{dt^2}\)</span></p>
<ul>
<li><p>加速度的方向：速度增量的方向</p></li>
<li><p>加速度的大小：<span class="math inline">\(|\pmb{a}|=\sqrt{a_{x}^{2}+a_{y}^{2}+a_{z}^{2}}\)</span></p></li>
<li><p>直角坐标系中：<span class="math inline">\(\pmb{a}=a_{x} \pmb{i}+a_{y} \pmb{j}+a_{z} \pmb{k}\)</span></p></li>
</ul>
<p><strong>注意</strong>：一般而言，加速度与同一时刻速度的方向之间并没有一定的关联。</p>
<p><strong>思考</strong>：</p>
<ol type="1">
<li>位矢、速度和加速度，与参考系的选择是否有关？</li>
<li>一旦参考系选定了，它们就与参考点的选择是否有关？</li>
</ol>
<h4 id="矢量描述质点运动的优点">矢量描述质点运动的优点</h4>
<p>矢量描述与具体坐标系的选择无关，因此便于作一般性的定义陈述和公式推导。</p>
<h4 id="坐标系的适当选择">坐标系的适当选择</h4>
<p>具体计算时，根据具体问题的特点选择。例如：</p>
<ol type="1">
<li>质点的加速度为常矢量时，可选用直角坐标系；</li>
<li>质点作平面运动的加速度总是指向空间某一固定点时，可选用平面极坐标系；</li>
<li>质点的运动轨迹固定或已知时，可选用自然坐标系。</li>
</ol>
<h3 id="速度加速度在不同坐标系中的分量表示">速度、加速度在不同坐标系中的分量表示</h3>
<h4 id="直角坐标系的特点">直角坐标系的特点</h4>
<p>各单位矢量<span class="math inline">\((e_x,e_y,e_z)\)</span> 或<span class="math inline">\((i,j,k)\)</span>都是不随时间变化的常矢量，即：<span class="math inline">\(\frac{e_x}{dt}=\frac{e_y}{dt}=\frac{e_z}{dt}=\frac{i}{dt}=\frac{j}{dt}=\frac{k}{dt}=0\)</span></p>
<p>因此有：</p>
<p><span class="math display">\[
\begin{aligned}
r&amp;=x\pmb{i}+y\pmb{j}+z\pmb{k}
\\
v&amp;=\frac{dx}{dt}\pmb{i}+\frac{yx}{dt}\pmb{j}+\frac{dz}{dt}\pmb{k}=v_x\pmb{i}+v_y\pmb{j}+v_z\pmb{k}
\\
a&amp;=\frac{d^2x}{dt}\pmb{i}+\frac{d^2y}{dt}\pmb{j}+\frac{d^2z}{dt}\pmb{k}=a_x\pmb{i}+a_y\pmb{j}+a_z\pmb{k}
\end{aligned}
\]</span></p>
<p><strong>注意</strong>：<span class="math inline">\(v_x,v_y,v_z\)</span>和 <span class="math inline">\(a_x,a_y,a_z\)</span> 都是可正可负的量。</p>
<figure>
<img src="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01a_4.png" class="lazyload" data-srcset="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01a_4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="a的方向"><figcaption aria-hidden="true">a的方向</figcaption>
</figure>
<p><strong>正负号的含义</strong>：如图所示，当质点在<span class="math inline">\(P\)</span>点处时， <span class="math inline">\(a_x\)</span>与<span class="math inline">\(v_x\)</span>的符号相同，说明质点在<span class="math inline">\(x\)</span>轴上的投影是在作加速运动；而<span class="math inline">\(a_y\)</span>与<span class="math inline">\(v_y\)</span>的符号相反，说明质点在<span class="math inline">\(y\)</span>轴上的投影是在作减速运动。</p>
<h4 id="实例">实例</h4>
<p>在地球表面附近不太大的范围内，重力加速度 g 可以看成是常量。在忽略空气阻力的情况下，二维抛体运动的水平分量和竖直分量将互相独立。这时可选取平面直角坐标系，如图所示。[missing Pic]</p>
<p><span class="math display">\[
\begin{cases}
\frac{dx}{dt}=v_0\cos{\theta_0}
\\
\frac{dy}{dt}=v_0\sin{\theta_0}-gt
\end{cases}
\]</span></p>
<p>积分后可得：</p>
<p><span class="math display">\[
\begin{cases}
x=(v_0\cos\theta_0) t
\\
y=(v_0\sin\theta_0) t
\end{cases}
\]</span></p>
<p>消去时间<span class="math inline">\(t\)</span>可得描写抛体运动轨迹的<strong>抛物线方程</strong></p>
<p><span class="math display">\[
y=x\tan\theta_0 - \frac{gx^2}{2v_0^2\cos^{2}{\theta_0}}
\]</span></p>
<p><strong>射高</strong>：由<span class="math inline">\(v_y=0\)</span>可得<span class="math inline">\(t=v_0\sin\theta_0/g\)</span>，由此可确定：</p>
<p><span class="math display">\[
y_{max}=\frac{v_0^2\sin^2\theta_0}{2g}
\]</span></p>
<p><strong>射程</strong>：由<span class="math inline">\(y=0\)</span>可得<span class="math inline">\(t=2v_9\sin\theta_0/g\)</span>，由此可确定</p>
<p><span class="math display">\[
x_{max}=\frac{v_0^2\sin2\theta_0}{g}
\]</span></p>
<h4 id="平面极坐标系横向速度和径向速度">平面极坐标系、横向速度和径向速度</h4>
<figure>
<img src="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01a_6.png" class="lazyload" data-srcset="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01a_6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="微分"><figcaption aria-hidden="true">微分</figcaption>
</figure>
<p>如图所示，在一选定的参考系上选取一点<span class="math inline">\(O\)</span>为<strong>原点</strong>，并从它出发引一条有刻度的射线<span class="math inline">\(Ox\)</span> 为<strong>极轴</strong>，即建立起了一个<strong>平面极坐标系</strong>。</p>
<p>该平面上任意一点 <span class="math inline">\(A\)</span> 的位矢的长度为<span class="math inline">\(\overline{OA}= r\)</span>，它与极轴间的夹角为<span class="math inline">\(\theta\)</span>，称为<strong>辐角</strong>。只要 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(\theta\)</span> 给定，<span class="math inline">\(A\)</span>点的位置就确定了。</p>
<p><span class="math display">\[
\bar{e}_{\theta}\quad \frac{\mathrm{d} \pmb{e}_{\theta}}{\mathrm{d} t}=-\frac{\mathrm{d} \theta}{\mathrm{d} t} \pmb{e}_{r} \\
\pmb{v} =\dot{r} \pmb{e}_{r}+r \dot{\theta} \pmb{e}_{\theta}\\
\pmb{a}=\left(\ddot{r}-r \dot{\theta}^{2}\right) \pmb{e}_{r}+(r \ddot{\theta}+2 \dot{r} \dot{\theta}) \pmb{e}_{\theta}
\]</span></p>
<p>在平面极坐标系中，两个互相垂直的单位矢量<span class="math inline">\(e_r\)</span>和<span class="math inline">\(e_\theta\)</span>，分别沿着 <span class="math inline">\(r\)</span> 和 $$ 增加的方向，它们都不是常矢量。</p>
<p><span class="math display">\[
A(r, \theta) \quad \vec{r}= r \vec{e}_{r}
\\
\frac{\mathrm{d} \pmb{e}_{r}}{\mathrm{d} t}=\frac{\mathrm{d} \theta}{\mathrm{d} t} \pmb{e}_{\theta}
\quad
\frac{\mathrm{d} \pmb{e}_{\theta}}{\mathrm{d} t} =-\frac{\mathrm{d} \theta}{\mathrm{d} t} \pmb{e}_{r}
\]</span></p>
<p>关于各物理量的表达式，可用以下两种方法得到：</p>
<p>（a）图解法</p>
<figure>
<img src="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01a_6b.png" class="lazyload" data-srcset="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01a_6b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="01a_6b"><figcaption aria-hidden="true">01a_6b</figcaption>
</figure>
<p><strong>位矢</strong>：<span class="math inline">\(\pmb{r}=r\pmb{e}_r\)</span></p>
<p><strong>位移</strong>：<span class="math inline">\(\Delta \boldsymbol{r}=\Delta \boldsymbol{r}_{1}+\Delta \boldsymbol{r}_{2}\)</span></p>
<p><strong>横向位移</strong>：<span class="math inline">\(\Delta \boldsymbol{r}_{1}=\overline{AC}\)</span></p>
<p><strong>径向位移</strong>:<span class="math inline">\(\Delta r_{2}=\overline{C B}\)</span></p>
<p>当<span class="math inline">\(\Delta t\)</span>很小时，由</p>
<p><span class="math display">\[
\begin{cases}
&amp;|O A|=|O C|=r\\
&amp;|O B|-|O C|=\Delta r
\end{cases}
\]</span></p>
<p>可得：</p>
<p><span class="math display">\[
\begin{aligned}
\Delta \boldsymbol{r}_{1} &amp; \approx r \Delta \theta \boldsymbol{e}_{\theta} \\
\Delta \boldsymbol{r}_{2} &amp; \approx \Delta r \boldsymbol{e}_{r} \\
\boldsymbol{v}&amp;=\lim _{\Delta t \rightarrow 0} \frac{\Delta \boldsymbol{r}}{\Delta t}=\lim_{\Delta t \rightarrow 0} \frac{r \Delta \theta \boldsymbol{e}_{\theta}}{\Delta t}+\lim_{\Delta t \rightarrow 0} \frac{\Delta r \boldsymbol{e}_{r}}{\Delta t} \\
&amp;=r \dot{\theta} \boldsymbol{e}_{\theta}+\dot{r} \boldsymbol{e}_{r}=v_{\theta} \boldsymbol{e}_{\theta}+v_{r} \boldsymbol{e}_{r}
\end{aligned}
\]</span></p>
<p><strong>横向速度</strong>：<span class="math inline">\(v_{\theta} e_{\theta}=r \dot{\theta} e_{\theta}\)</span></p>
<p><strong>径向速度</strong>：<span class="math inline">\(v_{r} \boldsymbol{e}_{r}=\dot{r} \boldsymbol{e}_{r}\)</span></p>
<p>​ 其中：<span class="math inline">\(\dot{\theta}=\mathrm{d} \theta / \mathrm{d} t, \quad \dot{r}=\mathrm{d} r / \mathrm{d} t\)</span></p>
<p>（b）矢量微分法</p>
<p>根据<span class="math inline">\(\pmb{e}_r\)</span>和<span class="math inline">\(\pmb{e}_{\theta}\)</span>与<span class="math inline">\(\pmb{i}\)</span>和<span class="math inline">\(\pmb{j}\)</span>之间的关系式：<span class="math inline">\(\pmb{e}_{r}=\pmb{i} \cos \theta+\pmb{j} \sin \theta \quad \pmb{e}_{\theta}=-\pmb{i} \sin \theta+\pmb{j} \cos \theta\)</span></p>
<p>按照矢量求导规则，可得：</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\mathrm{d} \pmb{e}_{r}}{\mathrm{d}t}&amp;=\lim\limits_{\Delta t \rightarrow 0} \frac{\Delta e_{r}}{\Delta t}=\lim\limits_{\Delta t \rightarrow 0} \frac{\Delta \theta}{\Delta t} \pmb{e}_{\theta}=\dot{\theta} \pmb{e}_{\theta} \\
\frac{\mathrm{d} \pmb{e}_{\theta}}{\mathrm{d} t}&amp;=\lim_{\Delta t \rightarrow 0} \frac{\Delta \pmb{e}_{\theta}}{\Delta t}=\lim_{\Delta t \rightarrow 0} \frac{\Delta \theta}{\Delta t}\left(-e_{r}\right)=-\dot{\theta} e_{r}
\\
\boldsymbol{v} &amp;=\frac{\mathrm{d} \boldsymbol{r}}{\mathrm{d} t}=\frac{\mathrm{d}\left(r \boldsymbol{e}_{r}\right)}{\mathrm{d} t}=\dot{r} \boldsymbol{e}_{r}+r \frac{\mathrm{d} \boldsymbol{e}_{r}}{\mathrm{d} t}=\dot{r} \boldsymbol{e}_{r}+r \dot{\theta} \boldsymbol{e}_{\theta} \\
\boldsymbol{a} &amp;=\frac{\mathrm{d} \boldsymbol{v}}{\mathrm{d} t}=\frac{\mathrm{d}\left(\dot{\boldsymbol{r}} \boldsymbol{e}_{r}\right)}{\mathrm{d} t}+\frac{\mathrm{d}\left(r \dot{\theta} \boldsymbol{e}_{\theta}\right)}{\mathrm{d} t} \\
&amp;=\dot{r}^{*} \boldsymbol{e}_{r}+\dot{r} \dot{\theta} \boldsymbol{e}_{\theta}+\dot{r} \dot{\theta} \boldsymbol{e}_{\theta}+r \ddot{\theta} \boldsymbol{e}_{\theta}-r \dot{\theta}^{2} \boldsymbol{e}_{r} \\
&amp;=\left(\ddot{r}-r \dot{\theta}^{2}\right) \boldsymbol{e}_{r}+(r \ddot{\theta}+2 \dot{r} \dot{\theta}) \boldsymbol{e}_{\theta}
\end{aligned}
\]</span></p>
<p><strong>径向加速度</strong>：<span class="math inline">\(a_{r} \boldsymbol{e}_{r}=\left(\ddot{r}-r \dot{\theta}^{2}\right) \boldsymbol{e}_{r}\)</span></p>
<p><strong>横向加速度</strong>：<span class="math inline">\(a_{\theta} \boldsymbol{e}_{\theta}=(r \ddot{\theta}+2 \dot{r} \dot{\theta}) \boldsymbol{e}_{\theta}\)</span></p>
<h4 id="自然坐标系切向加速度和法向加速度在质点运动轨迹已知的情况下选用sst">自然坐标系、切向加速度和法向加速度（在质点运动轨迹已知的情况下选用）<span class="math inline">\(S=S(t)\)</span></h4>
<p><strong>自然坐标系</strong>：选定轨迹上任一点<span class="math inline">\(O\)</span>为原点，用轨迹的长度<span class="math inline">\(s\)</span>描写质点位置，并规定两个正交单位矢量——<strong>切向</strong>单位矢量<span class="math inline">\(\pmb{e}_t\)</span>和<strong>法向</strong>单位矢量<span class="math inline">\(\pmb{e}_n\)</span>.</p>
<p><strong>曲率圆</strong>：通过曲线上的一点<span class="math inline">\(A\)</span>及其两个邻近的点作一个圆，在这三个点无限趋近的极限情况下，这个圆称为<span class="math inline">\(A\)</span>点的曲率圆，其半径称为曲率半径<span class="math inline">\(\rho\)</span>。</p>
<figure>
<img src="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01b_7.png" class="lazyload" data-srcset="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01b_7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="曲率"><figcaption aria-hidden="true">曲率</figcaption>
</figure>
<p><strong>速度</strong>：<span class="math inline">\(\boldsymbol{v}=\boldsymbol{v} \boldsymbol{e}_{t}=\frac{\mathrm{d}s}{\mathrm{d}t}\pmb{e}_t\)</span>（只有切向）</p>
<p><strong>速率</strong>：<span class="math inline">\(v=\frac{\mathrm{d} s}{\mathrm{d} t}\)</span></p>
<p><strong>加速度</strong>：<span class="math inline">\(\vec{a}=\dot{v} \vec{e}_{t}+\frac{v^{2}}{\rho} \vec{e}_{n}\)</span></p>
<ul>
<li>切向加速度：<span class="math inline">\(a_t=\frac{\mathrm{d}v}{\mathrm{d}t}\)</span></li>
<li>法向加速度：<span class="math inline">\(a_n=\frac{v^2}{\rho}\)</span></li>
</ul>
<p>当<span class="math inline">\(\Delta t\)</span>很小时，<span class="math inline">\(\Delta \pmb {e}_{t} \approx \pmb{e}_{n} \Delta \varphi\)</span>，利用</p>
<p><span class="math display">\[
\begin{cases}
&amp;\frac{1}{\rho}=\lim _{\Delta s \rightarrow 0} \frac{\Delta \varphi}{\Delta s}=\frac{\mathrm{d} \varphi}{\mathrm{d} s}\\
&amp;\mathrm{d} e_{\mathrm{t}}=e_{\mathrm{n}} \mathrm{d} \varphi=e_{\mathrm{n}} \frac{\mathrm{d} s}{\rho}
\end{cases}
\]</span></p>
<p>可得：</p>
<p><span class="math display">\[
\begin{aligned}
a &amp;=\frac{\mathrm{d} v}{\mathrm{d} t}=\frac{\mathrm{d}}{\mathrm{d} t}\left(v \boldsymbol{e}_{\mathrm{t}}\right)=\frac{\mathrm{d} v}{\mathrm{d} t} \boldsymbol{e}_{\mathrm{t}}+v \frac{\mathrm{d} \boldsymbol{e}_{\mathrm{t}}}{\mathrm{d} t} \\
&amp;=\frac{\mathrm{d} v}{\mathrm{d} t} \boldsymbol{e}_{\mathrm{t}}+v \frac{\mathrm{d} s}{\mathrm{d} t} \frac{1}{\rho} \boldsymbol{e}_{\mathrm{n}} \\
&amp;=\frac{\mathrm{d} v}{\mathrm{d} t} \boldsymbol{e}_{\mathrm{t}}+\frac{v^{2}}{\rho} \boldsymbol{e}_{\mathrm{n}}=a_{\mathrm{t}} \boldsymbol{e}_{\mathrm{t}}+a_{\mathrm{n}} \boldsymbol{e}_{\mathrm{n}}
\end{aligned}
\]</span></p>
<h2 id="相对运动">相对运动</h2>
<blockquote>
<p>在解决实际问题时，常常需要处理参考系与参考系之间变换的问题。</p>
</blockquote>
<p>如图 1 - 10 所示，参考系<span class="math inline">\(S&#39;\)</span>相对于参考系<span class="math inline">\(S\)</span>作平移。</p>
<figure>
<img src="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01b_10.png" class="lazyload" data-srcset="/2020/06/08/study/Physics/Ch1KinematicsOfMassPoint/01b_10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="坐标系变换"><figcaption aria-hidden="true">坐标系变换</figcaption>
</figure>
<p>设参考系 相对于参考系<span class="math inline">\(S\)</span>的位矢为<span class="math inline">\(R\)</span>，则参考系<span class="math inline">\(S&#39;\)</span>和参考系<span class="math inline">\(S\)</span>间的</p>
<p>相对运动速度(牵连速度)：<span class="math inline">\(\pmb{v}_r=\frac{\mathrm{d} \pmb{R}}{\mathrm{d}t}\)</span></p>
<p>加速度<span class="math inline">\(\pmb{a}_r\)</span>(牵连加速度)：<span class="math inline">\(\pmb{a}_r=\frac{\mathrm{d} \pmb{v}_r}{\mathrm{d}t}=\frac{\mathrm{d}^2 \pmb{R}}{\mathrm{d}t^2}\)</span></p>
<p>若质点 P 在参考系<span class="math inline">\(S\)</span>和<span class="math inline">\(S&#39;\)</span>中的位矢、速度和加速度分别为<span class="math inline">\(r,v,a\)</span>和<span class="math inline">\(r&#39;,v&#39;,a&#39;\)</span>, 则它们间的变换关系分别为：</p>
<p><span class="math display">\[
\begin{aligned}
\pmb{r}&#39;&amp;=\pmb{r}-\pmb{R}
\\
\pmb{v}&#39;&amp;=\frac{\mathrm{d}\pmb{r}}{\mathrm{d} t}=\frac{\mathrm{d}\pmb{R}}{\mathrm{d}t}=\pmb{v} -\pmb{v}_r
\\
\pmb{a}&#39;&amp;=\frac{\mathrm{d}\pmb{v}}{\mathrm{d}t}-\frac{\mathrm{d}\pmb{v}_r}{\mathrm{d}t}=\pmb{a}-\pmb{a}_r
\end{aligned}
\]</span></p>
<p>这些变换关系式是建立在绝对时空观基础上的，在相对论中它们将被建立在相对论时空观基础上的洛伦兹变换所取代。</p>
<p><strong>经典力学时空观：</strong></p>
<p>在两个作相对运动的参考系中，时间的测量是绝对的，空间的测量也是绝对的，与参考系无关。时间和长度的的绝对性是经典力学或牛顿力学的基础。</p>
<h2 id="习题">习题</h2>
<div class="note"><p>primary</p></div>
<p><strong>坐标系变换</strong></p>
<p>一般是飞机在空中飞行的风速和飞机速度，或者水中的行船问题等类似的问题</p>
<blockquote>
<p>画个图就 vans</p>
</blockquote>
<p>当然坐标系变换也可以是证明题，例如：</p>
<blockquote>
<p>证明：把两个物体以不同的速度抛出，则二者的相对速度是常矢量</p>
</blockquote>
<p><strong>坐标系的互化</strong></p>
<p>常用的坐标系有：</p>
<ul>
<li>直角坐标系</li>
</ul>
<blockquote>
<p>在一个倾角为<span class="math inline">\(\alpha\)</span>的山坡上开炮，相同的速度大小情况下，当发射角为多少时最远。（真的就高中题目呗）</p>
</blockquote>
<ul>
<li>极坐标系</li>
</ul>
<blockquote>
<p>一根细棒在水平面内以恒定角速度 <span class="math inline">\(\omega\)</span> 旋转，有一只昆虫从圆心出发，以恒定速率 <span class="math inline">\(u\)</span> 向外爬，求爬行速度和加速度。</p>
<p><strong>径向加速度</strong>：<span class="math inline">\(a_{r} \boldsymbol{e}_{r}=\left(\ddot{r}-r \dot{\theta}^{2}\right) \boldsymbol{e}_{r}\)</span></p>
<p><strong>横向加速度</strong>：<span class="math inline">\(a_{\theta} \boldsymbol{e}_{\theta}=(r \ddot{\theta}+2 \dot{r} \dot{\theta}) \boldsymbol{e}_{\theta}\)</span></p>
<p><strong>速度</strong>：<span class="math inline">\(v=r \dot{\theta} \boldsymbol{e}_{\theta}+\dot{r} \boldsymbol{e}_{r}\)</span></p>
<p><em>实际上只需要记住：</em><span class="math inline">\(\dot e_\theta =-\dot \theta e_r,\dot e_r = \dot\theta e_\theta\)</span></p>
</blockquote>
<!-- TODO: endnote-->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
        <tag>运动学</tag>
      </tags>
  </entry>
  <entry>
    <title>机械能守恒</title>
    <url>/2020/06/08/study/Physics/Ch3ConservationofMechanicalEnergy/</url>
    <content><![CDATA[<p>基础物理学Ch3 机械能守恒 这部分就简单提一句</p>
<span id="more"></span>
<h2 id="功-动能定理">功 动能定理</h2>
<h3 id="功work">功（Work）</h3>
<blockquote>
<p>力对质点所作的功为力在质点位移方向的分量（大小）与位移大小的乘积。（功是标量，过程量）</p>
</blockquote>
<ul>
<li><p>一段位移的功<span class="math inline">\(\mathrm dW=\vec F\cdot \mathrm d {\vec r}\)</span></p>
<p>注：功的大小和参考系有关。</p></li>
<li><p>合力的功（第二型曲线积分）</p></li>
<li><p><strong>功率（Power）</strong>：反应做功快慢程度的物理量</p>
<ul>
<li>平均功率</li>
<li>瞬时功率</li>
<li>功率单位</li>
</ul></li>
</ul>
<div class="note"><p>primary</p></div>
<h3 id="质点的动能定理theorem-of-kinetic-energy">质点的动能定理（Theorem of Kinetic Energy）</h3>
<ul>
<li><p><strong>动能</strong>：<span class="math inline">\(E_\mathrm{k}= \frac{1}{2}mv^2=\frac{p^2}{2m}\)</span></p></li>
<li><p><strong>动能定理</strong>：合外力对质点所做的功，等于质点动能的增量。</p></li>
</ul>
<blockquote>
<p>功和动能都与参考系有关，动能定理只能适用于惯性系！</p>
</blockquote>
<!-- TODO: endnote-->
<h2 id="保守力-势能">保守力 势能</h2>
<h3 id="万有引力重力弹性力做功的特点">万有引力、重力、弹性力做功的特点</h3>
<div class="note"><p>primary</p></div>
<h4 id="万有引力做功">万有引力做功</h4>
<p><strong>万有引力：</strong><span class="math inline">\(\vec F=-G\frac{m&#39;m}{r^3}\vec r\)</span></p>
<p><strong>做功：</strong><span class="math inline">\(W=(-G\frac{m&#39;m}{r_A})-(-G\frac{m&#39;m}{r_B})\)</span></p>
<h4 id="重力做功">重力做功</h4>
<p><span class="math inline">\(\vec P=-mg\vec k\)</span></p>
<p><span class="math inline">\(W=\int_A^b \vec P \cdot \mathrm d \vec r=mgz_A-mgz_B\)</span></p>
<h4 id="弹性力做功">弹性力做功</h4>
<p><span class="math inline">\(W=\frac{1}{2}kx_A^2-\frac{1}{2}kx_B^2\)</span></p>
<!-- TODO: endnote-->
<h3 id="保守力和非保守力">保守力和非保守力</h3>
<p><strong>保守力：</strong>力所做的功与路径无关，仅取决于质点的<strong>始末位置</strong>，具有这种特征的力统称为<strong>保守力</strong>。</p>
<ul>
<li>物体沿闭合路径运动一周，保守力对它所做功为零</li>
</ul>
<blockquote>
<p>实则是旋度为零</p>
</blockquote>
<p><strong>非保守力</strong>：做功与路径有关</p>
<blockquote>
<p>旋度不恒为零</p>
</blockquote>
<p>有关旋度，参见 <a href="#">Post not found: Advanced-Mathematics/Vectors-and-Analytic-Geometry-Integration</a></p>
<h3 id="势能potential-energy">势能（Potential Energy）</h3>
<ul>
<li><p>保守力做功等于势能的减少或势能增量的负值。</p>
<p>势能：与物体间相互作用及相对位置有关的能量</p></li>
<li><p>势能是空间位置的函数</p></li>
<li><p>势能具有相对性，势能大小与势能零点的选取有关 .</p></li>
<li><p>势能是属于系统的 ，所以又称为相互作用势能.</p></li>
<li><p>势能的计算：物体在某位置时的势能</p></li>
</ul>
<ol type="1">
<li><strong>引力势能</strong>，以无穷远处为势能零点</li>
<li><strong>重力势能</strong>，以地面为势能零点</li>
<li><strong>弹性势能</strong>，以物体为势能零点</li>
</ol>
<h3 id="势能函数与保守力的关系">势能函数与保守力的关系</h3>
<p><strong>积分形式：</strong><span class="math inline">\(W= - \Delta E_p\)</span></p>
<p><strong>微分形式：</strong><span class="math inline">\(\vec F \mathrm d\vec r= -\mathrm d E_p\)</span>（对<span class="math inline">\(\vec r\)</span>的偏导）</p>
<p><span class="math inline">\(\nabla\)</span>算符举例：</p>
<p><span class="math display">\[
\nabla=(
\begin{matrix}
\frac{\mathrm d}{\mathrm d x},
\frac{\mathrm d}{\mathrm d y},
\frac{\mathrm d}{\mathrm d z}
\end{matrix})
\]</span></p>
<p><strong>保守体系的平衡及平衡条件</strong>：</p>
<figure>
<img src="/2020/06/08/study/Physics/Ch3ConservationofMechanicalEnergy/03_0.jpg" class="lazyload" data-srcset="/2020/06/08/study/Physics/Ch3ConservationofMechanicalEnergy/03_0.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="stable"><figcaption aria-hidden="true">stable</figcaption>
</figure>
<ul>
<li>稳定平衡</li>
<li>不稳定平衡</li>
<li>随遇平衡</li>
</ul>
<p>条件：<span class="math inline">\(\nabla E_p=0\)</span></p>
<h3 id="功能原理-机械能守恒定律">功能原理 机械能守恒定律</h3>
<h4 id="质点系的动能定理">质点系的动能定理</h4>
<p><span class="math inline">\(\sum W_i =W_{ext}+W_{int}\)</span></p>
<p><span class="math inline">\(\Rightarrow W_{ext}+W{int}=\sum E_{ki}+ \sum E_{ki0}\)</span></p>
<h4 id="质点系的功能原理">质点系的功能原理</h4>
<p>质点系在运动过程中，所有外力的功和系统内非保守内力的功的总和等于系统机械能够的增量。<span class="math inline">\(W_{ext}+W_{int(非保守力)}=E-E_0\)</span></p>
<h4 id="机械能守恒定律">机械能守恒定律</h4>
<p>当<span class="math inline">\(W_{ext}+W_{int(非保守力)}=0\)</span>时：<span class="math inline">\(E=E_0\)</span></p>
<p>当作用于质点系的外力和非保守内力都不做功或所做功的代数和等于零时，系统的总机械能保持不变。</p>
<ul>
<li>功总是和能量的变化与转换过程相联系，功是能量变化和转换的一种量度，而能量是代表物体系统在一定条件下所具有的作功本领。</li>
<li>守恒定律的特点和优点：不研究过程细节而能对系统的状态下结论。</li>
</ul>
<h4 id="势能函数">势能函数</h4>
<h2 id="质心参考系">质心参考系</h2>
<h3 id="质心的定义">质心的定义</h3>
<p>由 n 个质点组成的质点系，其质心的位矢：<span class="math inline">\(\vec r_C=\frac{\sum m\vec r}{\sum m}\)</span></p>
<h3 id="质心运动定理">质心运动定理</h3>
<p><span class="math inline">\(\vec F^{ex}=m\vec a_c\)</span></p>
<h3 id="质心参考系的特点">质心参考系的特点</h3>
<p><strong>零动量参考系</strong>：</p>
<ul>
<li><span class="math inline">\(\sum p = \sum m\vec v = 0\)</span></li>
<li><span class="math inline">\(\sum m\vec r = 0,\quad \sum m\vec a =0\)</span></li>
</ul>
<p><strong>克尼希定理</strong>：</p>
<ul>
<li>质点系相对基本参考系的动能（<em>绝对动能</em>） 等于质点系在质心参考系中的动能（<em>相对动能</em>）加上<em>质心动能</em></li>
<li><span class="math inline">\(E_k = \frac{1}{2} mv_c^2 + E_k&#39;= \frac{1}{2} mv_c^2 + \sum \frac{1}{2} m_i v_i ^2\)</span></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>角动量守恒</title>
    <url>/2020/06/08/study/Physics/Ch4/</url>
    <content><![CDATA[<p>基础物理学Ch4 角动量守恒</p>
<span id="more"></span>
<h2 id="角动量角动量守恒定律">角动量、角动量守恒定律</h2>
<p><strong>「角动量」</strong>：<span class="math inline">\(\vec L = \vec r \times \vec p = \vec r \times m \vec v\)</span>（角动量、动量矩）</p>
<p>在圆周运动中：<span class="math inline">\(L = mr^2 w\)</span></p>
<div class="note"><p>success</p></div>
<p><strong>角动量守恒定律</strong>：<span class="math inline">\(L_1+L_2 = const\)</span></p>
<blockquote>
<p>一个系统由两个质点组成，若两个质点只受到它们之间的相互作用，则这个系统的总角动量保持恒定。</p>
</blockquote>
<!-- TODO: endnote-->
<h2 id="力矩-角动量定理">力矩 、角动量定理</h2>
<h4 id="力矩质点的角动量定理">力矩、质点的角动量定理</h4>
<ul>
<li><span class="math inline">\(L = r\times p\Rightarrow\)</span> (对t微分) <span class="math inline">\(\displaystyle\frac{\mathrm d L}{\mathrm d t} = r\times F\)</span> 定义为<span class="math inline">\(M\)</span>（力矩）</li>
<li>反之，对上式积分，<span class="math inline">\(\int \vec M \mathrm d t = \vec L _ 2 - \vec L _ 1\)</span>（角冲量）（或者写成 <span class="math inline">\(\mathrm d \vec L = \vec M \mathrm d t\)</span> ）地方</li>
</ul>
<p><strong>「角动量定理」 %}</strong>：质点对任一固定点的角动量的时间变化率，等于外力对该点的力矩。</p>
<h4 id="质点系的角动量定理">质点系的角动量定理</h4>
<blockquote>
<p><span class="math inline">\(L = \sum L = \sum r \times p=\sum r\times mv\)</span></p>
<p>对 <span class="math inline">\(t\)</span> 求导：<span class="math inline">\(\frac{\mathrm d L}{\mathrm d t} = M^{ex}+M^{in}\)</span></p>
<p>而在质点系中，由牛顿第三定律：<span class="math inline">\(M^{in}=0\)</span></p>
</blockquote>
<p><strong>「质点系的角动量定理」 %}</strong>： - 质点系对惯性系中某个参考点的角动量的时间变化率，等与作用在该质点系上的所有外力对该给定参考点的总力矩。 - <span class="math inline">\(\frac {\mathrm d L}{\mathrm d t} = M^{ex}\)</span></p>
<p><strong>「质点系的角动量守恒定律」 %}</strong>：（总外力矩为零时）<span class="math inline">\(L = const , \mathrm dL =0\)</span></p>
<h4 id="质心系的角动量定理">质心系的角动量定理</h4>
<p><strong>「质点组相对于质心的角动量」 %}</strong>：</p>
<ul>
<li><span class="math inline">\(L = \vec r_c \times m\vec v_c+\sum \vec r_i \times m_i \vec v_i&#39; = L_c+m\boldsymbol r_c\times\boldsymbol a_c\)</span></li>
<li>质点系对固定点 O 的角动量 L，等于质点系对其质心 C 的角动量 <span class="math inline">\(L_c\)</span> 加上质量集中在质心上随之运动时对 O 点的角动量 <span class="math inline">\(m\boldsymbol r_c\times\boldsymbol a_c\)</span></li>
</ul>
<p><strong>「质心系角动量定理」 %}</strong></p>
<ul>
<li><span class="math inline">\(M_c^{ex} = \frac{\mathrm dL_c}{\mathrm dt}\)</span></li>
<li>质点系对质心的角动量的时间变化率，等与作用在该质点系上的所有外力对质心的总力矩。</li>
</ul>
<p><strong>「质点组对质心的角动量守恒」 %}</strong></p>
<h2 id="质点在有心力场中的运动">质点在有心力场中的运动</h2>
<h4 id="质心在有心力场中运动的一般描述">质心在有心力场中运动的一般描述</h4>
<p><span class="math display">\[
\begin{cases}
  e_r方向\qquad m(\ddot{r} - r\dot\theta^2)=F(r)\\
  e_\theta 方向\qquad m(2\dot r\dot\theta + r\ddot\theta)=0
\end{cases}
\]</span></p>
<h4 id="机械能守恒和角动量守恒-离心势能和有效势">机械能守恒和角动量守恒 离心势能和有效势</h4>
<p>机械能守恒定律可以改写为：<span class="math inline">\(\displaystyle\tilde{E}_p(r)=E_p(r)+\frac{L^2}{2mr^2}\)</span></p>
<ul>
<li>有效势能</li>
<li>离心势能</li>
</ul>
<blockquote>
<p>将二维问题，化为一维问题。</p>
</blockquote>
<div class="note"><p>info</p></div>
<p><strong>「守恒定律」 %}</strong></p>
<ol type="1">
<li>动量</li>
<li>能量</li>
<li>角动量</li>
<li>质量</li>
<li>电荷</li>
<li>宇称守恒定律</li>
</ol>
<!-- TODO: endnote-->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>刚体运动学</title>
    <url>/2020/06/08/study/Physics/Ch5/</url>
    <content><![CDATA[<p>基础物理学Ch5 刚体运动学</p>
<span id="more"></span>
<p>基本问题：</p>
<ol type="1">
<li>运动</li>
<li>动力学</li>
<li>能量</li>
</ol>
<h2 id="刚体运动学">刚体运动学</h2>
<p><strong>「刚体」 %}</strong>：在外力作用下，形状大小不变的物体（任意两个质点之间的距离保持不变）<code>这是一个理想模型！</code></p>
<p><strong>「运动形式」 %}</strong>：</p>
<ul>
<li>平动</li>
<li>转动
<ul>
<li>定轴转动</li>
<li>定点转动</li>
</ul></li>
<li>滚动（平面平行运动）</li>
</ul>
<h3 id="刚体的平动">刚体的平动</h3>
<p><strong>平动</strong>：所有点的运动轨迹都保持完全相同（任意两点连线总平行与初始位置间的连线）</p>
<p><strong>特点</strong>：各点运动特征相同</p>
<blockquote>
<p>化为质点运动求解</p>
</blockquote>
<h3 id="定轴转动">定轴转动</h3>
<ul>
<li><strong>角坐标</strong>：<span class="math inline">\(\theta(t)\)</span></li>
<li><strong>角位移</strong>：<span class="math inline">\(\Delta \theta\)</span></li>
<li><strong>角速度矢量</strong>：<span class="math inline">\(\omega = \lim \frac{\Delta \theta}{\Delta t}\)</span></li>
</ul>
<p>定轴转动的特点：</p>
<ol type="1">
<li>每个质点均做圆周运动 ，圆面为转动平面。</li>
<li>任一质点运动<span class="math inline">\(\Delta \theta \omega \alpha\)</span>相同，但是<span class="math inline">\(v,a\)</span>不同</li>
<li>运动描述仅需一个角坐标</li>
</ol>
<p><strong>角量<span class="math inline">\(\omega\)</span>与线量<span class="math inline">\(v\)</span>的关系</strong>：<span class="math inline">\(\vec v = \omega r \vec{e_t} = \vec \omega \times \vec r\)</span></p>
<p><strong>「匀变速定轴转动的运动学公式」 %}</strong></p>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th>质点平动</th>
<th>刚体绕轴转动</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(v=v_0+at\)</span></td>
<td><span class="math inline">\(\omega = \omega_0+\alpha t\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(x=x_0+v_0t+\frac 1 2 at^2\)</span></td>
<td><span class="math inline">\(\theta = \theta_0+\omega_0 t + \frac 1 2 \alpha t^2\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(v^2 = v_0^2 + 2 a (x -x_0)\)</span></td>
<td><span class="math inline">\(\omega^2 = \omega_0^2 +2 a (\theta -\theta_0)\)</span></td>
</tr>
</tbody>
</table>
<h3 id="平面平行运动滚动">平面平行运动（滚动）</h3>
<p>平面平行运动可以看成：</p>
<ol type="1">
<li>刚体随质心的<strong>平动</strong>：<span class="math inline">\(\vec v,~\vec a\)</span></li>
<li>刚体绕质心的<strong>转动</strong>：<span class="math inline">\(\vec \omega,~\vec \alpha\)</span></li>
</ol>
<p>只考虑纯滚动的情况下（<strong>接触点速度为 0</strong>）：</p>
<ul>
<li>平动路程<span class="math inline">\(s = R \theta\)</span></li>
<li>质心速度大小<span class="math inline">\(v_c = R\omega\)</span></li>
<li>质心加速度大小<span class="math inline">\(a = R \alpha\)</span></li>
</ul>
<h2 id="刚体动力学">刚体动力学</h2>
<h3 id="转动惯量">转动惯量</h3>
<p><strong>意义</strong>：转动惯性的量度</p>
<blockquote>
<p>计算方法：</p>
<ol type="1">
<li>离散：<span class="math inline">\(\sum m r ^2\)</span></li>
<li>连续：<span class="math inline">\(\int r^2 \mathrm d m\)</span></li>
</ol>
<p>取决于质量、形状、位置。</p>
</blockquote>
<div class="note"><p>primary</p></div>
<p>质量是<span class="math inline">\(m\)</span>长度<span class="math inline">\(l\)</span>的棒，以中点为轴：<span class="math inline">\(I = \frac{1}{12} ml^2\)</span></p>
<p>质量是<span class="math inline">\(m\)</span>长度<span class="math inline">\(l\)</span>的棒，以一个端点为轴：<span class="math inline">\(I = \frac{1}{3} ml^2\)</span></p>
<p>质量是<span class="math inline">\(m\)</span>半径<span class="math inline">\(R\)</span>的圆盘，以中心为轴：<span class="math inline">\(I = \frac{1}{2} mR^2\)</span></p>
<p><strong>平行轴定理</strong>：质量为 m 的刚体，如果对其质心轴的转动惯量为 <span class="math inline">\(I_C\)</span> 则，对于任意与该轴平行的轴而言，相距为 d 时的转动惯量：<span class="math inline">\(I_O=I_C+md^2\)</span></p>
<p><strong>垂直轴定理</strong>（对于一个薄板而言）：<span class="math inline">\(I_z = I_x +I_y\)</span></p>
<!-- TODO: endnote-->
<h3 id="刚体定轴转动的角动量定理和角动量守恒">刚体定轴转动的角动量定理和角动量守恒</h3>
<p><strong>「刚体定轴转动的角动量」 %}</strong>：<span class="math inline">\(L_z = \sum\limits_i m_i r_i^2\omega = I\omega\)</span></p>
<p><strong>「刚体定轴转动的角动量定理」 %}</strong>：<span class="math inline">\(\int M_z \mathrm{d}t = I\omega_2 -I \omega_1\)</span></p>
<p><strong>「刚体定轴转动的角动量守恒定律」 %}</strong>：<span class="math inline">\(if M_z = 0 ,\ then \  L_z = I\omega = const\)</span></p>
<p><strong>「刚体定轴转动的角冲量定理」 %}</strong>：<span class="math inline">\(\int M_z\mathrm dt=I_z\omega -I_z\omega_0\)</span></p>
<h3 id="刚体定轴转动的动能定理">刚体定轴转动的动能定理</h3>
<p>微分形式<span class="math inline">\(\mathrm{ d} W = \vec{F}\cdot \mathrm d \vec{r} = F_t r\mathrm{d} \theta = M_z \mathrm d \theta\)</span></p>
<p>力矩对定轴转动刚体做功：<span class="math inline">\(W = \int _{\theta_1}^{\theta_2}M_z \mathrm{d} \theta\)</span></p>
<p>力矩的功率：<span class="math inline">\(P= \frac{\mathrm{d} W}{\mathrm{ d} t}=M_z \omega\)</span></p>
<p><strong>「刚体定轴转动的动能」 %}</strong>：<span class="math inline">\(E_k = \frac 1 2 I\omega^2\)</span></p>
<p><strong>「刚体绕定轴转动的动能定理」 %}</strong>：<span class="math inline">\(W = \int_{\theta_1}^{\theta_2} I \omega \mathrm{d} \omega = E_{k2} - E_{k1 = }=\frac 1 2 I\omega_2^2-\frac 1 2 I\omega_1^2\)</span></p>
<h3 id="刚体的定点转动进动precession">刚体的定点转动（进动）（Precession）</h3>
<p>陀螺的进动角速度：<span class="math inline">\(\omega_\mathrm p = \frac {\mathrm d \phi}{\mathrm d t} = \frac{|\mathrm d L|}{\mathrm d t\cdot L\sin \theta} = \frac{mgr_c}{I\omega}\)</span> <div class="note"><p>warning</p></div></p>
<p>注意角加速度的方向。</p>
<p>注意理解场平架陀螺仪工作原理。</p>
<!-- TODO: endnote-->
<h3 id="刚体动力学总结">刚体动力学：总结</h3>
<p>质心运动定理：<span class="math inline">\(\vec{F}= m\vec{a_c}\)</span></p>
<p>转动定律：<span class="math inline">\(M_c = I_c \alpha ,\quad v_c = R \omega\)</span></p>
<p>平面平行运动能量：（科尼希定理）<span class="math inline">\(E_k = E_{kc} +E_k&#39; = \frac{1}{2} mv_c^2 + \frac{1}{2}I_c \omega^2\)</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>振动与波</title>
    <url>/2020/06/04/study/Physics/Ch6VibrationAndWaves/</url>
    <content><![CDATA[<p>基础物理学第六章-振动与波。后续会把其他这个学期学过的内容补上。</p>
<span id="more"></span>
<h2 id="简谐振动">简谐振动</h2>
<h4 id="描述简谐振动的特征量">描述简谐振动的特征量</h4>
<ul>
<li><strong>Def</strong>：简谐运动或简谐振动</li>
<li>描述简谐振动幅度和时间周期性的特征量
<ul>
<li>振幅</li>
<li>周期</li>
<li>频率</li>
<li>角频率</li>
</ul></li>
<li><strong>Def</strong>：（相位）描述简谐振动瞬时运动状态的特征量</li>
</ul>
<h4 id="简谐振动的合成">简谐振动的合成</h4>
<ul>
<li>同方向、同频率的两个简谐振动的合成
<ul>
<li>矢量图解法
<ul>
<li><span class="math inline">\(\tan \varphi_0 = \frac{A_1\sin\varphi_{10}+A_2\sin\varphi_{20}}{A_1\cos\varphi_{10}+A_2\cos\varphi_{20}}\)</span></li>
<li><span class="math inline">\(A=\sqrt{A_1^2+A_2^2+2A_1A_2\cos (\varphi_{20}-\varphi_{10})}\)</span></li>
<li><span class="math inline">\(x=A\cos (\omega t+\varphi_0)\)</span></li>
</ul></li>
<li>复数法
<ul>
<li><span class="math inline">\(\displaystyle\tilde x = Ae^{i(\omega t+\varphi_0)}\)</span></li>
</ul></li>
</ul></li>
<li>同方向、不同频率的两个简谐振动的合成
<ul>
<li>形成<strong>拍</strong>现象</li>
<li><span class="math inline">\(x=2A\cos\frac{(\omega_2-\omega_1)t}{2}\cos\frac{(\omega_2+\omega_1)t}{2}\)</span></li>
</ul></li>
<li>相互垂直、同频率的两个简谐振动的合成
<ul>
<li>圆、椭圆</li>
<li>稳定的</li>
</ul></li>
<li>相互垂直、不同频率的两个简谐振动的合成
<ul>
<li>利萨如图形</li>
<li>不稳定</li>
</ul></li>
</ul>
<h4 id="振动的分解-fourier-transformation">振动的分解 Fourier Transformation</h4>
<ul>
<li>周期函数的频谱分析和傅里叶级数
<ul>
<li>傅里叶级数【高等数学】</li>
</ul></li>
<li>非周期函数的频谱分析和傅里叶变换</li>
</ul>
<h2 id="弹性系统的振动">弹性系统的振动</h2>
<h4 id="谐振子的自由振动">谐振子的自由振动</h4>
<ul>
<li>固有频率、固有角频率</li>
<li>谐振子</li>
<li><span class="math inline">\(-kx=m\frac{\mathrm d^2x}{\mathrm dt^2}\)</span></li>
<li><span class="math inline">\(\omega_0=\sqrt{k/m}=\sqrt{g/l}\)</span></li>
<li><span class="math inline">\(E=E_k+E_p=\frac 1 2 kA^2\)</span></li>
</ul>
<h4 id="谐振子的阻尼振动">谐振子的阻尼振动</h4>
<ul>
<li><span class="math inline">\(\boldsymbol F_V=-\gamma\boldsymbol v\)</span></li>
<li><span class="math inline">\(2\delta = \gamma/m\)</span> 是表征系统阻尼大小的 changliang</li>
<li>欠阻尼振动 <span class="math inline">\(x=A_0e^{-\delta t}\cos(\omega t+\varphi_0)\)</span></li>
<li>过阻尼振动 <span class="math inline">\(\displaystyle x(t) = c_1e^{-(-\delta - \sqrt{\delta^2-\omega_0})t}+c_2e^{-(-\delta+ \sqrt{\delta^2-\omega_0})t}\)</span></li>
<li>临界阻尼振动 <span class="math inline">\(x(t) = (c_1+c_2)e^{-\delta t}\)</span></li>
</ul>
<h4 id="谐振子的受迫振动和共振">谐振子的受迫振动和共振</h4>
<ul>
<li>受迫振动的运动方程及其解的可叠加性
<ul>
<li>受迫振动驱动力为 <span class="math inline">\(F_d= F_{d0}\cos \omega_dt\)</span></li>
<li>受迫振动的解为<span class="math inline">\(x(t) = A_0e^{-\delta t}\cos (\omega t+\varphi_0)+B\cos(\omega_dt+\varphi_d)\)</span>，其中第一项称为暂态解，第二项称为定态解</li>
<li>（复数法）定态解的振幅<span class="math inline">\(\displaystyle B=|x|=\frac{\alpha}{\sqrt{(\omega_0^2-\omega_d^2)^2+4\delta^2\omega_d^2}}\)</span></li>
<li>定态解的相位<span class="math inline">\(\displaystyle\varphi_d=\arctan\frac{-2\delta \omega_d}{\omega_0^2-\omega_d^2}\)</span></li>
</ul></li>
<li>共振
<ul>
<li>当<span class="math inline">\(\omega_d= \sqrt{\omega_0^2-2\delta^2}\)</span> 受迫振动达到极大值</li>
</ul></li>
</ul>
<h2 id="机械波的产生和传播">机械波的产生和传播</h2>
<h4 id="简谐波的描述">简谐波的描述</h4>
<ul>
<li>横波、纵波</li>
<li>波速、波长、相速 <span class="math inline">\(u=\frac \lambda T=v\lambda=\frac{\omega\lambda}{2\pi}\)</span></li>
<li>振动位移表达式<span class="math inline">\(\xi(x,t) = A\cos[\omega(t-\frac x u)+\varphi_0]\)</span></li>
<li>角波数<span class="math inline">\(k=\frac{2\pi}{\lambda},~~\xi(x,t) = A\cos[\omega t-kx+\varphi_0]\)</span></li>
</ul>
<div class="note"><p>primary</p></div>
<p><strong>「相位落后法」 %}</strong></p>
<!-- TODO: endnote-->
<h4 id="波动方程">波动方程</h4>
<ul>
<li>波动方程</li>
<li>对应函数<span class="math inline">\(\xi(x,t) = A\cos(\omega t-\boldsymbol k\cdot \boldsymbol x+\varphi_0)\)</span></li>
</ul>
<h4 id="波的能量">波的能量</h4>
<ul>
<li><span class="math inline">\(dV\)</span>上的动能 <span class="math inline">\(dE_k=\frac 12 \rho\omega^2A^2\sin^2(\omega t-kx)dV\)</span></li>
<li>势能 <span class="math inline">\(dE_k=\frac 12 Ek^2A^2\sin^2(\omega t-kx)dV\)</span></li>
<li>平均能量密度 <span class="math inline">\(\overline w=\frac 1 T \int_0^T w\mathrm dt = \frac 1 2 \rho \omega^2A^2\)</span></li>
</ul>
<h4 id="声波">声波</h4>
<h2 id="驻波">驻波</h2>
<h4 id="驻波的形成和特点">驻波的形成和特点</h4>
<ul>
<li><strong>Def</strong>：（相干波）频率相同、振动方向相同、有固定相位差的两个波源发出的简谐波</li>
<li>干涉现象</li>
<li>驻波是特殊的干涉，两列波的振幅相同，传播方向相反</li>
<li>驻波方程 <span class="math inline">\(y=A\cos(\omega t-kx)+A\cos (\omega t+kx)=2A\cos\frac{2\pi x}{\lambda}\cos \omega t\)</span></li>
</ul>
<h4 id="两端固定的弦中的驻波多自由度系统的简正模">两端固定的弦中的驻波、多自由度系统的简正模</h4>
<h4 id="半波损失">半波损失</h4>
<ul>
<li>在均匀介质中沿直线传播的波在遇到另外一种介质时，会发生<strong>反射</strong>和<strong>折射</strong>现象，定义<strong>特性阻抗</strong> <span class="math inline">\(Z=\rho u\)</span></li>
<li>从波密介质到波疏介质中，相位不变，方向相反</li>
<li>从波疏介质到波密介质中，相位改变 <span class="math inline">\(\pi\)</span>，方向相反，称为半波损失</li>
</ul>
<h2 id="多普勒效应">多普勒效应</h2>
<ul>
<li><p>波源或观测者的运动造成观测频率与波源频率不同的现象</p></li>
<li><p>波源和观察者同时相对于介质运动时 <span class="math inline">\(\displaystyle\nu&#39;=\frac{u+v_o}{u-v_s}\nu\)</span>，其中 <span class="math inline">\(v_o\)</span> 为观察者向波源运动速度，<span class="math inline">\(v_s\)</span> 为波源向观察者运动的速度</p></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
        <tag>波</tag>
      </tags>
  </entry>
  <entry>
    <title>狭义相对论</title>
    <url>/2020/06/08/study/Physics/Ch7/</url>
    <content><![CDATA[<p>基础物理学Ch7 狭义相对论</p>
<span id="more"></span>
<h2 id="狭义相对论的基本假设">狭义相对论的基本假设</h2>
<h3 id="绝对时空观与伽利略相对性原理">绝对时空观与伽利略相对性原理</h3>
<ol type="1">
<li>长度、时间间隔、质量、相互作用力与参考系无关</li>
<li>速度、位移、加速度满足伽利略变换关系（速度变换式、时空变换式）</li>
</ol>
<h3 id="电磁学发展及其与绝对时空观的规律">电磁学发展及其与绝对时空观的规律</h3>
<ol type="1">
<li>电磁学规律：
<ul>
<li>Maxwell方程组</li>
<li><span class="math inline">\(c = \frac{1}{\sqrt{\epsilon_0 \mu_0}}\)</span></li>
</ul></li>
<li>电磁学规律与绝对时空观的矛盾
<ul>
<li>光速与参考系无关</li>
</ul></li>
<li>矛盾解决
<ul>
<li>伽利略速度变换正确，而光速只适用于特殊的参考系：<code>以太参考系</code></li>
<li>相对性原理对电磁学规律也适用，为了保持光速不变，需要建立新的时空变换关系</li>
</ul></li>
</ol>
<h3 id="狭义相对论的基本内容">狭义相对论的基本内容</h3>
<ul>
<li>事件何时发生？在哪里发生？</li>
<li>事件之间相隔多远？相隔多久？</li>
<li>时间和空间是否有关联？</li>
<li>时间和长度的测量与参考系是否有关？</li>
<li>物体的质量与运动是否有关？</li>
</ul>
<h3 id="两个基本假设">两个基本假设</h3>
<ol type="1">
<li>相对性原理（The Relativity Postulate）：物理性质在所有惯性系中具有相同的表达形式</li>
<li>光速不变原理（The Speed of Light Postulate）</li>
</ol>
<h3 id="相对论时空观">相对论时空观</h3>
<p><span class="math inline">\(S\)</span>系观测，<span class="math inline">\(S&#39;\)</span>系运动</p>
<ol type="1">
<li>同时具有相对意义。</li>
<li>时间延缓（Time Dilation） <strong>固有时</strong>：某个参考系中同一个地点发生的两事件的时间间隔 在<span class="math inline">\(S\)</span>系中观测：<span class="math inline">\(\Delta t=\frac{\Delta t_0}{ \sqrt{1-(v/c)^2}}\)</span> <em>运动的钟走得慢</em> 时间间隔是<strong>相对的</strong>，与参考系有关。</li>
<li>长度收缩（length contraction） <strong>固有长度</strong>：静止棒在一个静止的坐标系中的长度 在<span class="math inline">\(S\)</span>系中观测：<span class="math inline">\(l = l&#39; \sqrt{1-(v/c)^2}\)</span> 运动的棒长度变短或收缩，长度或时间间隔是<strong>相对</strong>的，与参考系有关。</li>
</ol>
<h2 id="洛伦兹变换">洛伦兹变换</h2>
<p><span class="math display">\[
\begin{cases}
    （S观测\rightarrow S&#39;观测）已知P在S系中的时空坐标t,x:
    \\ \qquad x = vt+x&#39;\sqrt{1-\beta^2} \rightarrow x&#39; = \frac{x- vt}{\sqrt{1-\beta ^2}}\\
    （S观测\rightarrow S&#39;观测）已知P在S系中的时空坐标t,x：
    \\ \qquad x&#39; = x\sqrt{1-\beta^2} - vt&#39;\rightarrow t&#39; = \frac{t-\frac v c^2 x}{\sqrt{1-\beta^2}}
\end{cases}
\]</span> <span class="math display">\[
\Rightarrow
\begin{cases}
    x&#39; = \gamma (x- vt)\\
    y&#39; = y\\
    z&#39; = z\\
    t&#39; = \gamma(t -\frac{v}{c^2}x)\\
    \gamma = \frac{1}{\sqrt{1 - \beta ^2}}
\end{cases}
\]</span></p>
<p>做全微分：</p>
<p><span class="math display">\[
\begin{aligned}
   &amp;dx&#39; =\gamma({dx - vdt}),\\
   &amp;dt&#39; = \gamma(dt - (v/c^2)dx)\\
   \Rightarrow &amp;u_x&#39; = \frac{dx}{dt} = \frac{u_x -v}{1-\frac v {c^2}u_x }\\
\end{aligned}
\]</span></p>
<p>类似的，可以得到：</p>
<p>正变换：</p>
<p><span class="math display">\[
\left\{
   \begin{aligned}
      u_{x}^{\prime}&amp;=\frac{u_{x}-v}{1-\frac{v}{c^{2}} u_{x}} \\
      u_{y}^{\prime}&amp;=\frac{u_{y}}{\gamma\left(1-\frac{v}{c^{2}} u_{x}\right)} \\
      u_{z}^{\prime}&amp;=\frac{u_{z}}{\gamma\left(1-\frac{v}{c^{2}} u_{x}\right)}
   \end{aligned}
\right.
\]</span></p>
<p>逆变换：</p>
<p><span class="math display">\[
\left\{
   \begin{aligned}
      u_{x} &amp;=\frac{u_{x}^{\prime}+v}{1+\frac{v}{c^{2}} u_{x}^{\prime}} \\
      u_{y}&amp;= \frac{u_{y}^{\prime}}{\gamma\left(1+\frac{v}{c^{2}} u_{x}^{\prime}\right)} \\
      u_{z} &amp;=\frac{u_{z}^{\prime}}{\gamma\left(1+\frac{v}{c^{2}} u_{x}^{\prime}\right)}
   \end{aligned}
\right.
\]</span></p>
<h3 id="同时的相对性">同时的相对性</h3>
<p>在S'系中观测S系的事件：<span class="math inline">\(\Delta t&#39; = \frac{\Delta t - \frac{v}{c^2}\Delta x}{\sqrt{1-\beta^2}}\)</span></p>
<ol type="1">
<li>因果律不变</li>
<li>两件事有因果关系，则<span class="math inline">\(\Delta x/ \Delta t&lt;c\)</span></li>
<li>两件事没有因果关系，则可能<span class="math inline">\(\Delta x /\Delta t &gt; c\)</span></li>
</ol>
<h2 id="相对论动力学">相对论动力学</h2>
<h3 id="动量与质量">动量与质量</h3>
<p><span class="math inline">\(m = \frac{m}{\sqrt{1-\beta^2}}\)</span></p>
<p><strong>相对论动量</strong>：<span class="math inline">\(\vec p = m\vec v = \gamma m_0\vec v\)</span></p>
<p>其中<span class="math inline">\(m_0\)</span>称为<strong>静质量</strong>。</p>
<h3 id="力功动能">力、功、动能</h3>
<p><span class="math inline">\(\vec F = \frac{d\vec p}{dt} = m \frac{d\vec{ v}}{dt}+\vec v \frac{dm}{dt}\)</span></p>
<p>相对论动能：<span class="math inline">\(E_k -0 = \sum_0^v \vec v\cdot d\vec p = \frac{m_0v^2}{\sqrt{1-v^2/c^2}}+m_0c^2\sqrt{1-v^2/c^2} -m_0c^2=mc^2-m_0c^2\)</span></p>
<h3 id="能量质能关系">能量、质能关系</h3>
<p><strong>静质量</strong>：<span class="math inline">\(E_0 = m_0c^2\)</span></p>
<p><strong>质量亏损</strong>：<span class="math inline">\(B = \sum m_{0i} -m_0 = \Delta m\)</span></p>
<p><strong>结合能</strong>：<span class="math inline">\(E_B = Bc^2=\Delta m c^2\)</span></p>
<p><strong>相对论质能关系</strong>：$E = mc^2 = m_0c^2 +E_k $</p>
<p><strong>总能量</strong>：<span class="math inline">\(E = mc^2\)</span></p>
<h3 id="能量动量的关系">能量、动量的关系</h3>
<p><span class="math inline">\(E^2-p^2c^2 = m_0^2 c^4,\qquad E^2 = E_0^2 +p^2c^2\)</span></p>
<p>光的波粒二象性<span class="math inline">\(E = h\mu ,\quad p = h/\lambda\)</span></p>
<h3 id="能量动量力的相对论变换">能量、动量、力的相对论变换</h3>
<h4 id="动量能量的相对论变换">动量、能量的相对论变换</h4>
<ol type="1">
<li>E，p关系：<span class="math inline">\(E^2/c^2 - p^2\)</span>和时空变换：<span class="math inline">\(c^2t^2 -r^2\)</span>是洛伦兹不变量。</li>
<li>对应关系</li>
</ol>
<p><span class="math display">\[
\left\{\begin{aligned}
   p&#39;_{x&#39;} &amp;= \gamma (p_x - u \frac{E}{c^2})\\
   p&#39;_{y&#39;} &amp;= p_y\\
   p&#39;_{z&#39;} &amp;= p_z\\
   E&#39; &amp;= \gamma (E - up_x)
\end{aligned}\right.
\]</span></p>
<h4 id="力的相对论变换">力的相对论变换</h4>
<p><span class="math inline">\(F_x =F_x&#39;\)</span></p>
<p><span class="math inline">\(F_y = F_y&#39; /\gamma\)</span></p>
<p><span class="math inline">\(F_z = F_z&#39; /\gamma\)</span></p>
<h2 id="广义相对论">广义相对论</h2>
<ol type="1">
<li>等效原理</li>
<li>广义协变性原理</li>
<li>马赫原理</li>
</ol>
<h4 id="广义相对论的数学基础">广义相对论的数学基础</h4>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>静电场</title>
    <url>/2020/08/20/study/Physics/Ch8_9/</url>
    <content><![CDATA[<p>基础物理学第 8 - 9 章</p>
<span id="more"></span>
<div class="note"><p>secondary</p></div>
<ul>
<li>静电场
<ul>
<li>电相互作用</li>
<li>静电场的高斯定理</li>
<li>静电场的环路定理、电势</li>
</ul></li>
<li>静电场中的导体、电介质
<ul>
<li>静电场中的导体</li>
<li>静电场中的电介质</li>
<li>静电场的能量</li>
</ul></li>
</ul>
<!-- TODO: endnote-->
<h2 id="电相互作用-真空中的静电场">电相互作用 真空中的静电场</h2>
<h3 id="电相互作用">电相互作用</h3>
<p><strong>「电荷守恒定律」 %}</strong>：在一个与外界没有点和交换的系统内，正负电荷的代数和，在任何物理过程中都保持不变。</p>
<p>**元电荷 e %} 的整数倍。</p>
<h4 id="库仑定律">库仑定律</h4>
<p><strong>「库仑定律」 %}</strong>：</p>
<ul>
<li><p>在真空中，两个静止点电荷之间的相互作用力大小，与它们的电量的乘积成正比，与其距离平方成反比，作用力方向沿着它们的连线，同号电荷相斥，异号电荷相吸。</p></li>
<li><p><span class="math inline">\(\displaystyle\boldsymbol{F} _ {12}=k\frac{q _ 1q _ 2}{r _ {12}^2}\boldsymbol{e} _ {12}=\frac{1}{4\pi\varepsilon _ 0}\frac{q _ 1q _ 2}{r _ {12}^2}\boldsymbol{e} _ {12}\)</span></p></li>
</ul>
<p><strong>「静电力的叠加原理」 %}</strong>：总静电力等于其他点电荷单独存在作用在该点电荷上的静电力的矢量和</p>
<h4 id="电场和电场强度">电场和电场强度</h4>
<ul>
<li>电场、电场力、场强</li>
</ul>
<p><strong>「场强的叠加原理」 %}</strong>：（类似静电力的叠加原理）</p>
<div class="note"><p>primary</p></div>
<p>通过线积分、面积分、体积分计算电场强度。</p>
<!-- TODO: endnote-->
<div class="note"><p>warning</p></div>
<p><strong>「电偶极子」 %}</strong>：由两个大小相等，符号相反的点电荷 +q 和 -q 组成。从负电荷到正电荷的矢量称为电偶极子的臂 l，电荷 q 和 l 的乘积称为电偶极矩 p（电矩）。</p>
<!-- TODO: endnote-->
<h3 id="静电场的高斯定理">静电场的高斯定理</h3>
<h4 id="电场线">电场线</h4>
<p>数量和场强大小成正比</p>
<h4 id="电场通量">电场通量</h4>
<ul>
<li>通量（Flux）</li>
</ul>
<h4 id="静电场的高斯定理-1">静电场的高斯定理</h4>
<p>静电场中任何闭合曲面 S 的电场通量 <span class="math inline">\(\varPhi _ E\)</span> 等于该曲面内所包围的电荷的代数和 <span class="math inline">\(\sum q _ i\)</span> 除以 <span class="math inline">\(\varepsilon _ 0\)</span></p>
<div class="note"><p>primary</p></div>
<p><strong>「注意」 %}</strong></p>
<ol type="1">
<li>如何证明？</li>
<li>类比到引力场</li>
</ol>
<!-- TODO: endnote-->
<h4 id="静电场高斯定理的微分形式">静电场高斯定理的微分形式</h4>
<ul>
<li><span class="math inline">\(\displaystyle\nabla\cdot\boldsymbol{E} =\frac{1}{\varepsilon}\rho _ c\)</span></li>
</ul>
<h3 id="静电场的环路定理-电势">静电场的环路定理 电势</h3>
<h4 id="静电场的环路定理">静电场的环路定理</h4>
<ul>
<li>静电场力所作的功，与路径无关（静电场力是保守力）</li>
</ul>
<p><strong>「静电场的环路定理」 %}</strong>：静电场中，场强沿任意闭合环路的线积分恒等于 0：</p>
<ul>
<li><span class="math inline">\(\displaystyle\oint\boldsymbol{E}\cdot\mathrm{d}\boldsymbol{l}=0\)</span></li>
</ul>
<p>微分形式：</p>
<ul>
<li><span class="math inline">\(\nabla\times \boldsymbol{E}=0\)</span></li>
</ul>
<h4 id="电势差和电势">电势差和电势</h4>
<ul>
<li><span class="math inline">\(\displaystyle U _ {PQ}=\int _ P^Q\boldsymbol{E}\cdot\mathrm{d}\boldsymbol{l}\)</span></li>
<li>常常选用无穷远为势能零点</li>
</ul>
<h4 id="电势叠加原理">电势叠加原理</h4>
<p><strong>「电势叠加原理」 %}</strong>：点电荷系中电子厂中某点的电势，是哥哥点电荷单独存在时电场在该点的电势的代数和。</p>
<h4 id="等势面-电势的梯度">等势面 电势的梯度</h4>
<ul>
<li><span class="math inline">\(\boldsymbol{E}=-\mathrm{grad}~V\)</span></li>
</ul>
<blockquote>
<p>**静电场的基本微分方程</p>
<p>泊松方程：<span class="math inline">\(\nabla^2V=-\frac{1}{\varepsilon _ 0}\rho _ e\)</span></p>
<p>拉普拉斯方程：<span class="math inline">\(\nabla^2V=0\)</span></p>
</blockquote>
<hr>
<h2 id="静电场中的导体">静电场中的导体</h2>
<h3 id="静电场中的导体-1">静电场中的导体</h3>
<h4 id="导体的静电平衡条件">导体的静电平衡条件</h4>
<p><strong>「条件」 %}</strong>：导体内场强处处为 0</p>
<blockquote>
<p>利用了：<strong>静电场边值问题的唯一性定理</strong></p>
</blockquote>
<div class="note"><p>primary</p></div>
<ol type="1">
<li>导体是等势体，导体表面是等势面</li>
<li>导体内部没有静电荷，电荷只分布在导体表面上</li>
<li>导体以外靠近其表面处的场强处处与表面垂直，其大小取决于导体表面的面电荷密度。</li>
</ol>
<!-- TODO: endnote-->
<h4 id="导体壳-静电屏蔽">导体壳 静电屏蔽</h4>
<p><strong>「腔内无带电梯」 %}</strong>：在静电平衡状态下，导体壳的内表面上处处没有电荷，电荷只分布在外表面上，空腔内没有电场。</p>
<p><strong>「有带电体」 %}</strong>：内表面和腔内电荷的代数和为 0.</p>
<p><strong>「静电屏蔽」 %}</strong>：接地良好的道题刻可以把内部带电梯对外界的影响全部消除。</p>
<h4 id="电容-电容器">电容 电容器</h4>
<p><strong>「孤立导体的电容」 %}</strong>：<span class="math inline">\(C = \frac{q}{V}\)</span></p>
<p><strong>「电容器的电容」 %}</strong>：<span class="math inline">\(C = \frac{q}{U_{AB}}\)</span></p>
<div class="note"><p>primary</p></div>
<p><strong>电容计算</strong>：</p>
<ol type="1">
<li>平行板电容器</li>
<li>同心球电容器</li>
<li>同轴柱形电容器</li>
</ol>
<p>并联的电容：加和</p>
<p>串联的电容：倒数 = 倒数加和</p>
<!-- TODO: endnote-->
<h3 id="静电场中的电介质">静电场中的电介质</h3>
<h4 id="电介质计划">电介质计划</h4>
<ul>
<li>位移极化、取向极化、极化电荷、束缚电荷</li>
</ul>
<h4 id="极化强度和极化电荷">极化强度和极化电荷</h4>
<p><span class="math inline">\(P = \frac{\sum \boldsymbol p_i}{\Delta V}\)</span></p>
<p>闭合曲面 S 内向外移动的极化电荷总量为净余的极化电荷总量的负值：</p>
<ul>
<li><span class="math inline">\(\displaystyle\iint_{(S)}P\cdot \mathrm d S=-\sum q&#39;_i\)</span></li>
</ul>
<h4 id="各向同性线性电介质的极化规律">各向同性线性电介质的极化规律</h4>
<ul>
<li><span class="math inline">\(P=\chi_e\varepsilon_0 E\)</span></li>
</ul>
<p>产生<strong>退极化场</strong>：E'</p>
<h4 id="电位移-有电介质时的高斯定理">电位移 有电介质时的高斯定理</h4>
<ul>
<li><span class="math inline">\(D=\varepsilon_0E+P\)</span></li>
<li><span class="math inline">\(D=\varepsilon_r\varepsilon_0E=\varepsilon E\)</span></li>
</ul>
<p><strong>「D的高斯定理」 %}</strong>：<span class="math inline">\(\nabla\cdot D=\rho_0\)</span></p>
<ul>
<li><span class="math inline">\(D = \varepsilon E=\varepsilon_r\varepsilon_0E\)</span></li>
<li><span class="math inline">\(C=\varepsilon_rC_0\)</span></li>
</ul>
<h3 id="静电场的能量">静电场的能量</h3>
<h4 id="带点体系的静电能">带点体系的静电能</h4>
<ul>
<li>点电荷之间的相互作用能
<ul>
<li><span class="math inline">\(\displaystyle W_{int}=\frac{1}{8\pi\varepsilon_0}\sum\sum\frac{q_iq_j}{r_{ij}}\)</span></li>
</ul></li>
<li>电荷连续分布情形的静电能
<ul>
<li><span class="math inline">\(\displaystyle W=\frac{1}{2}\sum qV\)</span></li>
</ul></li>
<li>电荷在外电场中的能量</li>
<li>电容器储能
<ul>
<li><span class="math inline">\(\displaystyle W=\frac{1}{2}QU\)</span></li>
</ul></li>
</ul>
<h4 id="电场的能量和能量密度">电场的能量和能量密度</h4>
<p><strong>「电能密度」 %}</strong>：<span class="math inline">\(\displaystyle w_e = \frac{W_e}{V} = \frac{1}{2}DE\)</span></p>
<p>各向同性时：</p>
<ul>
<li><span class="math inline">\(\displaystyle w_e=\frac{1}{2}\varepsilon_0E^2(or~\frac{1}{2}\varepsilon_r\varepsilon_0E^2)\)</span></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
        <tag>波</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言和 Lambda 演算叙旧</title>
    <url>/2020/06/09/study/ComputerScience/LambdaCalculi/LambdaCalc0/</url>
    <content><![CDATA[<p>摘自Wikipedia，知乎等。</p>
<span id="more"></span>
<h2 id="lambda-演算历史">Lambda 演算历史</h2>
<p>在 20 世纪 60 年代中期的一系列论文中，Landin<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>阐述了关于编程语言的两个重要观察。首先，他认为所有编程语言都共享一套用于指定计算的基本工具，但在数据和数据原语的选择上存在差异。这组通用工具包含名称、过程、应用程序、异常机制、可变数据结构，以及其他形式的非局部控制（non-local control）。用于数值计算的应用程序的语言通常包括几种形式的数值常量和大型数值原语集，而用于字符串操作的语言通常提供高效的字符串匹配和操作原语。</p>
<p>其次，Landin 敦促程序员和实现者（implementors）都应该把编程语言看作是一种先进的、符号形式的算术和代数。由于我们在幼儿园和高中的时候就已经习惯了用数字、布尔值和更复杂的数据结构进行计算，用程序进行计算应该也很容易。程序评估、许多形式的程序编辑、程序转换和优化只是简单的、更复杂的计算形式。这种计算处理的不是简单的算术表达式，而是程序和程序片段。</p>
<p>Landin 定义了编程语言 <code>Iswim</code>。他设计的基础是 Church<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 的 Lambda 演算。Church 提出 Lambda 演算作为一种函数的演算（calculus of functions）。鉴于 Landin 对于在程序中，过程（Procedure）起到核心作用，并且作为所有语言的通用工具的理解，Lambda 演算是一个十分自然的构建起点（a nature starting point）。然而，为了支持基本数据和相关原语以及赋值和控制构造， Landin 使用适当的构造扩展了 Lambda 演算。他将扩展后的编程语言的语义与一台抽象机进行了类比，因为他不知道如何将 Lambda 演算理论扩展为完整的编程语言理论。实际上，（Landin 提出的）Lambda 演算甚至没有解释纯函数子语言的语义，因为 <code>Iswim</code> 总是对过程（Procedure）中的参数进行计算（意为执行该 Procedure 中的计算操作）。因此，Landin 并没有完成他的目标，即建立所有编程语言的一个理想的核心，并定义其语义的等式演算方法。</p>
<p>从 Plotkin<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> 在 20 世纪 70 年代中期关于抽象机器与等式计算器的关系的研究开始，Landin 的研究未完成的部分由许多研究者共同填补，包括 Felleisen、Mason、Talcott 和他们的合作者。Plotkin 的工作包括创建一个实现了 <code>Iswim</code> 的基本功能的子语言，这需要在此基础上采用一种名为 Lambda 演算的“值代入”（call-by-value variant of the lambda-calculus）的计算方法。Felleisen 和他的同事用公理扩展了等式理论，这些公理解释了几种不同类型的命令式语言工具。梅森和塔尔科特研究了将等式理论用于完全类似 <code>Iswim</code> 的语言，作为程序验证和转换编程（Transformational Programming）的工具。</p>
<p>尽管 <code>Iswim</code> 并未成为一个被广泛应用的语言，<code>Iswim</code> 的设计哲学依旧体现在现代编程语言中，最值得注意的是 Scheme 和 ML，和它的语言（语义？）分析（langurage analysis）和设计方法基本上适用于所有编程语言。</p>
<p>这本书的目的是为了说明设计、分析和使用的等式理论像 Lambda 演算在编程语言内容（content of programming langurage）中的设计与分析。着眼于 ML 和 Scheme，但针对的是一般的高阶语言。</p>
<p>Landin 的 <code>ISWIM</code> 的功能核心是对 Church 的纯 Lambda 演算的扩展，使用原始数据及其相关的原始函数。Church 以一种函数的演算，提出了 Lambda 演算。Lambda 演算提供了一个简单且规范的语法来编写 donw 函数，以及一个简单的等式系统（指等式理论）来指定程序的行为。由于在编程语言中，由用户定义的过程是函数的直观对等物（intuitive counterpart of functions），所以对于希望仅基于数据和用户定义过程定义编程语言的 Landin 来说，该系统是一个自然的选择。与纯演算不同，<code>ISWIM</code> 包含基本常量和函数常量来模拟原始数据；为了避免特殊化（Specialization），我们的 <code>ISWIM</code> 变体包含用于原始数据操作的通用子语言。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://www.wanweibaike.com/wiki-Peter%20J.%20Landin">Peter John Landin</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://www.wanweibaike.com/wiki-Alonzo%20Church">Alonzo Church</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://popl18.sigplan.org/profile/gordonplotkin">Gordon Plotkin</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Lambda演算</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 演算简介（1）</title>
    <url>/2020/06/09/study/ComputerScience/LambdaCalculi/LambdaCalc1/</url>
    <content><![CDATA[<p>摘自 Wikipedia，知乎等。</p>
<span id="more"></span>
<h2 id="何为-lambda-演算">何为 Lambda 演算</h2>
<p>Lambda 演算（Lambda Calculus）是一套从数理逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用，以及以递归的形式定义、实现一个系统。它由数学家阿隆佐·邱奇在 20 世纪 30 年代首次发表。Lambda 演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值，它能模拟单一磁带图灵机的计算过程；尽管如此，Lambda 演算强调的是变换规则的运用，而非实现它们的具体机器。</p>
<p>Lambda 演算可比拟是最根本的编程语言，它包括了一条变换规则（变量替换）和一条将函数抽象化定义的方式。因此普遍公认是一种更接近软件而非硬件的方式。对函数式编程语言造成很大影响，比如<code>Lisp</code>、<code>ML</code>语言和<code>Haskell</code>语言。在 1936 年邱奇利用 Lambda 演算给出了对于判定性问题（Entscheidungs problem）的否定：关于两个 Lambda 表达式是否等价的命题，无法由一个“通用的算法”判断，这是不可判定性能够证明的头一个问题，甚至还在停机问题之先。</p>
<div class="note"><p>primary</p></div>
<h3 id="后文中使用的一些-racket-语义">后文中使用的一些 Racket 语义</h3>
<p><span class="math inline">\(\sum\limits_{i=0}^ni\)</span>：<code>(define (sumto n) (/ (* n (+ n 1)) 2))</code></p>
<p>求整数的位数：<code>(define (crunch n) (if (&lt; n 10) 1 (+ 1 (crunch (/ n 10)))))</code></p>
<p>断言：<code>posn?</code>，<code>number?</code>，<code>zero?</code>，<code>positive?</code>...</p>
<p>多分支判断：<code>cond</code>相当于 c 中的 <code>switch-case</code> 语句（等价 <code>(if p a1 a2)</code> 递归）</p>
<h4 id="复杂数据类型">复杂数据类型</h4>
<p>复杂数据类型构成：<code>make-posn p q</code>，<code>posn?</code>，<code>posn-x</code>，<code>posn-y</code></p>
<p>元组化：<code>(define (bunchify n) (if (= n 1) 1 (make-posn n (bunchify (- n 1))))))</code></p>
<p>元组个数：<code>bunch-size</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (bunch-size b)</span><br><span class="line">  (if (number? b)</span><br><span class="line">  1</span><br><span class="line">  (+ (bunch-size (posn-x b)) (bunch-size (posn-y b)))))</span><br></pre></td></tr></table></figure>
<p>从 <code>bunch</code> 中删除 <code>e</code>：<code>delete-es b e</code></p>
<h4 id="高级数据结构">高级数据结构</h4>
<p>二元组：<code>cons</code> （<code>(define-struct cons (car cdr))</code>）</p>
<p>取第一个：<code>car</code></p>
<p>取第二个：<code>cdr</code></p>
<p>列表：<code>list</code></p>
<!-- TODO: endnote-->
<h2 id="计算模型computation-models">计算模型（Computation Models）</h2>
<p>图灵机是一种<strong>抽象机器</strong>，它在无限长磁带上进行计算。如果一个问题可以用图灵机解决，我们说它是<strong>可计算的</strong>。否则，它是<strong>不可计算的</strong>。</p>
<div class="note"><p>primary</p></div>
<h3 id="停机问题">停机问题</h3>
<p>不可计算的一个例子：<strong>停机问题</strong>。它询问是否存在一个程序，该程序接受一个程序作为输入，并决定它是否停止。现在思考这样的 Racket 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (doesnthalt x) (doesnthalt x))</span><br><span class="line"></span><br><span class="line">(define (foo x)</span><br><span class="line">  (if (halts? x) (doesnthalt 10) true))</span><br></pre></td></tr></table></figure>
<p>这里的 <code>doesnthalt</code> 函数形成无穷递归。</p>
<p>进而我们证明 <code>(foo foo)</code> 是不可确定的</p>
<blockquote>
<ol type="1">
<li><p>如果 <code>(foo foo)</code> 停机，则 <code>foo</code> 停机，则<code>(foo foo) =&gt; (doesnthalt 10)</code></p>
<p><code>(foo foo)</code> 是不可计算的，形成矛盾。</p></li>
<li><p>如果 <code>(foo foo)</code> 不停机，则 <code>(foo foo) =&gt; true</code> ，<code>foo</code> 停机，形成矛盾。</p></li>
</ol>
<p>在两种情况下，都产生了矛盾，故停机问题是不可计算的。</p>
</blockquote>
<!-- TODO: endnote-->
<h2 id="lambda-演算语法">Lambda 演算语法</h2>
<p>Lambda 演算包括了建构 Lambda 项，和对 Lambda 项运行归约的操作。Lambda 演算只有三类表达式：</p>
<ol type="1">
<li>变量（Variable）：<span class="math inline">\(\mathrm{x,y,a,b}\)</span></li>
<li>抽象（Abstraction）：<span class="math inline">\(\mathrm{(\lambda x.~expression)}\)</span> <span class="math inline">\(\mathrm{expression}\)</span> 是一个 Lambda 表达式</li>
<li>应用（Application）：<span class="math inline">\(\mathrm{(e_1,e_2)}\)</span> 其中 <span class="math inline">\(e_1,e_2\)</span> 为 Lambda 表达式</li>
</ol>
<div class="note"><p>primary</p></div>
<h3 id="常用表示法">常用表示法</h3>
<p><span class="math inline">\(\mathrm{(\lambda x . expression)}\)</span>：<code>(lambda x. expression)</code></p>
<p><span class="math inline">\(\mathrm{(\lambda x.plus~x~x)~y}\)</span>：<code>(lambda x. plus x x) y</code>（前缀表达式）</p>
<p>在后文中都使用这种记法，并且采用前缀表达式。下面介绍一些速记：</p>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>等价记法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>(lambda x. expression)</code></td>
<td><code>lambda x. expression</code></td>
</tr>
<tr class="even">
<td><code>(e)</code></td>
<td><code>e</code></td>
</tr>
<tr class="odd">
<td><code>e1 e2 e3</code></td>
<td><code>(e1 e2) e3</code></td>
</tr>
<tr class="even">
<td><code>lambda x.e1 e2</code></td>
<td><code>lambda x. (e1 e2)</code></td>
</tr>
</tbody>
</table>
<p>这里给出一些 Lambda 表达式的例子：</p>
<ol type="1">
<li><code>x</code></li>
<li><code>x x</code></li>
<li><code>x y z</code></li>
<li><code>lambda x. x</code></li>
<li><code>lambda x. x x</code></li>
<li><code>lambda x.(lambda y. x)</code></li>
<li><code>(lambda x. x) (lambda y. y)</code></li>
</ol>
<h3 id="lambda-演算技巧柯里化">Lambda 演算技巧：柯里化</h3>
<p>如果仔细看 Lambda 演算的定义，便会发现，Lambda 演算只接受一个参数，这似乎是一个极大的问题，因为我们连加法都无法合理的处理，因而我们将其使用柯里化。</p>
<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。在直觉上，柯里化声称：</p>
<div class="note"><p>primary</p></div>
<p>“如果你固定某些参数，你将得到接受余下参数的一个函数”<!-- TODO: endnote--></p>
<p>由这个理论，我们来构建一个加法运算：<code>lambda x.(lambda y. plus x y)</code></p>
<p>如果我们可以简化运算、并且提升可阅读性的话，我们也可以用前一种记法，即 <code>lambda x y. plus x y</code>。这就是柯里化的最简单使用方法，也就是说，一个复杂的多参数函数可以柯里化为一个函数。添加多个参数的函数并没有真正添加任何东西，只不过简化了语法，所以下面继续介绍的时候，在方便的时候用到多参数函数。</p>
<!-- TODO: endnote-->
<h3 id="自由变量">自由变量</h3>
<p>我们在此给出自由变量的严格定义：</p>
<blockquote>
<p>用 <span class="math inline">\(\mathrm{FV[exp]}\)</span> 表示一个集合，表示在一个 Lambda 表达式 <span class="math inline">\(\mathrm{exp}\)</span> 中的所有自由变量：</p>
<ol type="1">
<li><span class="math inline">\(\mathrm{exp}\)</span> 是变量，则 <span class="math inline">\(\mathrm{FV(exp) = \{exp\}}\)</span></li>
<li><span class="math inline">\(\mathrm{exp}\)</span> 是应用 <span class="math inline">\(\mathrm{(e1~e2)}\)</span>，则 <span class="math inline">\(\mathrm{FV(exp) = FV[e1]\cup FV[e2]}\)</span></li>
<li><span class="math inline">\(\mathrm{exp}\)</span> 是抽象 <span class="math inline">\(\lambda \mathrm{x.~deri}\)</span>，则 <span class="math inline">\(\mathrm{FV(exp) = FV(deri) \backslash \{x\}}\)</span></li>
</ol>
</blockquote>
<p>例如：</p>
<ul>
<li><code>lambda x . plus x y</code>：在这个表达式中，<code>y</code> 和 <code>plus</code> 是自由的，而 <code>x</code> 不是自由的。</li>
<li><code>lambda x y . y x</code>：在这个表达式中<code>x</code>和<code>y</code>都不是自由的。</li>
<li><code>lambda y . (lambda x . plus x y)</code>：在内层演算<code>lambda x . plus x y</code>中，<code>y</code>和<code>plus</code>是自由的，<code>x</code>不是自由的。在完整表达中，<code>x</code>和<code>y</code>不是自由的，<code>plus</code> 是自由的</li>
</ul>
<p>我们会经常使用<code>free(x)</code>来表示在表达式<code>x</code>中自由的标识符。</p>
<h2 id="lambda-演算中的代换法">Lambda 演算中的代换法</h2>
<p><span class="math inline">\(\mathrm{e1[x\leftarrow e2]}\)</span> 表示代换。代换可以不严谨地理解为：将 <span class="math inline">\(\mathrm{e1}\)</span> 中的所有出现的<strong>自由变量</strong> <span class="math inline">\(\mathrm x\)</span> 替换为 <span class="math inline">\(\mathrm{e2}\)</span>。</p>
<p>严格的定义如下：</p>
<ol type="1">
<li><span class="math inline">\(\mathrm{x[x\leftarrow e]}\Longrightarrow\mathrm e\)</span></li>
<li><span class="math inline">\(\mathrm{(e1,e2)[x\leftarrow e3]}\Longrightarrow \mathrm{(e1[x\leftarrow e3],e2[x\leftarrow e3])}\)</span></li>
<li><span class="math inline">\(\mathrm{(\lambda x.e1)[x\leftarrow e2]}\Longrightarrow \mathrm{(\lambda x.e1)}\)</span> （在其中，<span class="math inline">\(\mathrm x\)</span> 不是自由变量）</li>
<li><span class="math inline">\(\mathrm{(\lambda y.e1)[x\leftarrow e2]}\Longrightarrow \mathrm{(\lambda y.e1[x\leftarrow e2])}\)</span></li>
</ol>
<h3 id="lambda-演算原则">Lambda 演算原则</h3>
<p>为了推广这个代换法，我们引入 <span class="math inline">\(\alpha\)</span>-转化和 <span class="math inline">\(\beta\)</span>-规约的概念：</p>
<h4 id="alpha-转化">alpha-转化</h4>
<p>如果两个 Lambda 表达式<span class="math inline">\((\mathrm{\lambda x.e1}),(\mathrm{\lambda y.e2})\)</span>满足<span class="math inline">\(\mathrm y\not\in\mathrm{FV[e1]}\)</span> 并且 <span class="math inline">\(\mathrm{e2=e1[x\leftarrow y]}\)</span> 则称这两个表达式是 <span class="math inline">\(\alpha\)</span>-等价（<span class="math inline">\(\alpha\)</span>-equivalent）的。用符号 <span class="math inline">\(\mathop{\rightarrow}\limits^\alpha\)</span> 表示这一转化。</p>
<blockquote>
<p><span class="math inline">\(\alpha\)</span>-转化翻译成 <strong>转化</strong> 一词，是因为其注重了其转化的语义。</p>
<p>在英文中我们使用：<em>equivalent</em> 表示该关系，实则描述的是一种等价关系。</p>
</blockquote>
<h4 id="beta-规约">beta-规约</h4>
<p><span class="math inline">\(\beta\)</span>-规约是一个操作：将<span class="math inline">\(\mathrm{(\lambda x.e1)~e2}\)</span>，转化为 <span class="math inline">\(\mathrm{e1[x\leftarrow e2]}\)</span>。用符号 <span class="math inline">\(\mathop {\rightarrow}\limits^\beta\)</span> 表示这一操作。</p>
<blockquote>
<p>规约来自：<em>reduction</em> 一词，个人认为翻译为 <strong>约化</strong> 更为准确。</p>
</blockquote>
<div class="note"><p>primary</p></div>
<h4 id="alpha-转化和-beta-规约的实例">alpha-转化和 beta-规约的实例</h4>
<p><span class="math display">\[
\begin{aligned}
\mathrm{(\lambda x.a~x~b)~(\lambda y.y)}&amp;\mathop {\rightarrow}\limits^\beta\mathrm{a~(\lambda y.y)~b}\\
\mathrm{(\lambda x.a~x~b)~(\lambda y.x)}&amp;\mathop {\rightarrow}\limits^\alpha\mathrm{(\lambda q.a~q~b)~(\lambda y.x)}\\
&amp;\mathop{\rightarrow}\limits^\beta \mathrm{a~(\lambda y.x)~b}
\end{aligned}
\]</span></p>
<!-- TODO: endnote-->
<h4 id="约化">约化</h4>
<p>若给出一个从 <span class="math inline">\(\mathrm {e1}\)</span> 到 <span class="math inline">\(\mathrm{e2}\)</span> 演算序列，且 <span class="math inline">\(\mathrm e2\)</span> 无法继续演算，则称 <span class="math inline">\(\mathrm e1\)</span> 约化为 <span class="math inline">\(\mathrm{e2}\)</span>。</p>
<p>如果一个表达式 <span class="math inline">\(\mathrm e1\)</span> 存在一个约化，则称其为<strong>可约化的</strong>（called redex）</p>
<h3 id="开始我们的演算">开始我们的演算</h3>
<p>以 <span class="math inline">\(\mathrm{(\lambda x.a~x~b)~((\lambda y.y)~z)}\)</span> 为例，下面给出两种可能的方案去约化 Lambda 表达式。</p>
<p><strong>普通（惯常）顺序（Normal Order）</strong>：从最外层的可约化的式子开始，先化为<span class="math inline">\(\mathrm{a~((\lambda y.y)~z)~b}\)</span></p>
<p><strong>应用（调用）顺序（Applicative Order）</strong>：也从最外层开始，但先化为 <span class="math inline">\(\mathrm{(\lambda x.a~x~b)~z}\)</span></p>
<blockquote>
<p>请读者指出这两种顺序的区别：（注：在 non-lazy 非惰性计算时使用的是第二种顺序）</p>
</blockquote>
<p>一个<strong>完全约化</strong>（fully-reduced）的 Lambda 表达式形式没有可约化的表达式。同时，若给出从 <span class="math inline">\(\mathrm {e1}\)</span> 到 <span class="math inline">\(\mathrm{e2}\)</span> 演算序列，则 <span class="math inline">\(\mathrm e2\)</span> 不可约化，且在该演算序列中的所有表达式都约化为 <span class="math inline">\(\mathrm e2\)</span>（存在且唯一）。</p>
<div class="note"><p>warning</p></div>
<p><strong>一个无穷递归的例子</strong></p>
<p><span class="math inline">\(\mathrm{(\lambda x.x~x)~(\lambda x.x~x)}\)</span></p>
<p>毫不夸张的说，这是世界上最小的无穷循环（递归）。</p>
<p>但是，思考这样的例子：</p>
<p><span class="math inline">\(\mathrm{(\lambda x.y)~((\lambda x.x~x)~(\lambda x.x~x))}\)</span></p>
<p>对于普通顺序演算，结果为 <span class="math inline">\(y\)</span> ，对于应用顺序演算，结果则是无穷递归。</p>
<p>更一般的说，若一个 Lambda 表达式可以（可能）被约化为一个完全约化的表达式，则普通顺序<strong>一定</strong>能演算到该形式，但应用顺序可能无法导出答案。</p>
<!-- TODO: endnote-->
<h2 id="惰性计算lazy-evaluation">惰性计算（Lazy-Evaluation）</h2>
<p>惰性计算需要我们对可约化的表达式进行注释（annotate）。以下面一个表达式为例，我们对表达式进行约化：</p>
<p><span class="math display">\[
\mathrm{(\lambda x.f~x~x)~((\lambda y.y)~z)}
\]</span></p>
<p>使用<strong>普通顺序</strong>：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{(\lambda x.f~x~x)~((\lambda y.y)~z)}\\
\Rightarrow&amp;\mathrm{f~((\lambda y.y)~z)~((\lambda y.y)~z)}\\
\Rightarrow&amp;\mathrm{f~z~((\lambda y.y)~z)}\\
\Rightarrow&amp;\mathrm{f~z~z}
\end{aligned}
\]</span></p>
<p><strong>普通顺序</strong>先对第一个抽象（abstraction）使用 <span class="math inline">\(\beta\)</span>-规约</p>
<p>使用<strong>应用顺序</strong>：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{(\lambda x.f~x~x)~((\lambda y.y)~z)}\\
\Rightarrow&amp;\mathrm{(\lambda x.f~x~x)~z}\\
\Rightarrow&amp;\mathrm{f~z~z}
\end{aligned}
\]</span></p>
<p><strong>应用顺序</strong>先对第二个抽象（abstraction）使用 <span class="math inline">\(\beta\)</span>-规约</p>
<p>使用<strong>惰性计算</strong>：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{(\lambda x.f~x~x)~((\lambda y.y)~z)}\\
\Rightarrow&amp;\mathrm{f~((\lambda y.y)~z)~((\lambda y.y)~z)}\\
\Rightarrow&amp;\mathrm{f~z~z}
\end{aligned}
\]</span></p>
<p>看似惰性计算很像普通顺序，但是，除了在后台运算时，所有等价的可约化表达式，在约化后会同时被替换。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Lambda演算</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 演算简介（2）</title>
    <url>/2020/06/11/study/ComputerScience/LambdaCalculi/LambdaCalc2/</url>
    <content><![CDATA[<p>Lambda 演算中的常见概念</p>
<span id="more"></span>
<h2 id="布尔函数列表等基本数据类型">布尔、函数、列表等基本数据类型</h2>
<h3 id="布尔值的表示与运算">布尔值的表示与运算</h3>
<table>
<thead>
<tr class="header">
<th>概念</th>
<th>Lambda 表达式</th>
<th>记法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>f(x) = expr</code></td>
<td><span class="math inline">\(\mathrm{\lambda x.expr}\)</span></td>
<td><code>lambda x.expr</code></td>
</tr>
<tr class="even">
<td><code>true</code></td>
<td><span class="math inline">\(\mathrm{\lambda x.\lambda y.x}\)</span></td>
<td><code>lambda x.lambda y.x</code></td>
</tr>
<tr class="odd">
<td><code>false</code></td>
<td><span class="math inline">\(\mathrm{\lambda x.\lambda y.y}\)</span></td>
<td><code>lambda x.lambda y.y</code></td>
</tr>
<tr class="even">
<td><code>e1 and e2</code></td>
<td><span class="math inline">\(\mathrm{[e1][e2][false]}\)</span></td>
<td><code>[e1][e2][false]</code></td>
</tr>
<tr class="odd">
<td><code>e1 or e2</code></td>
<td><span class="math inline">\(\mathrm{[e1][true][e2]}\)</span></td>
<td><code>[e1][true][e2]</code></td>
</tr>
<tr class="even">
<td><code>not e1</code></td>
<td><span class="math inline">\(\mathrm{[e1][false][true]}\)</span></td>
<td><code>[e1][false][true]</code></td>
</tr>
<tr class="odd">
<td><code>(if q tp fp)</code></td>
<td><span class="math inline">\(\mathrm{[q][tp][fp]}\)</span></td>
<td><code>[q][tp][fp]</code></td>
</tr>
</tbody>
</table>
<p>毫无疑问，这是一个联结词完备集，现在来简单验证一下这个定义是正确的：</p>
<p><code>true and false =&gt; (lambda x.lambday.y) = false</code></p>
<p>当然，读者也可以尝试着写出 <code>not and or</code> 的表达式，证明其正确性。在此略去。</p>
<p>这样看 Lambda 表达式并不是很直观，但是如果认为这些 Lambda 表达式是柯里化后的表达式，则可以给出：</p>
<ul>
<li><code>true &lt;=&gt; lambda x y.x</code></li>
<li><code>false &lt;=&gt; lambda x y.y</code></li>
<li><code>(if q tp fp) &lt;=&gt; lambda q tp fp.(q tp fp)</code>（注意结合 <code>true</code> 和 <code>false</code> 的定义看）</li>
</ul>
<h3 id="多元函数列表的递归定义">多元函数、列表的递归定义</h3>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 47%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>Lambda 表达式</th>
<th>记法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>f(x, y) = expr</code></td>
<td><span class="math inline">\(\mathrm{\lambda x.\lambda y.expr}\)</span></td>
<td><code>lambda x.lambda y.expr</code>（柯里化）</td>
</tr>
<tr class="even">
<td><code>cons e1 e2</code></td>
<td><span class="math inline">\(\mathrm{\lambda a.\lambda b.(\lambda s.s~a~d)~e1~e2}\)</span></td>
<td><code>lambda a.lambda d.(lambda s.s a d) e1 e2</code></td>
</tr>
<tr class="odd">
<td><code>car expr</code></td>
<td><span class="math inline">\(\mathrm{[expr][true]}\)</span></td>
<td><code>[expr] [true]</code></td>
</tr>
<tr class="even">
<td><code>cdr expr</code></td>
<td><span class="math inline">\(\mathrm{[expr]~[false]}\)</span></td>
<td><code>[expr] [false]</code></td>
</tr>
<tr class="odd">
<td><code>empty</code></td>
<td><span class="math inline">\(\mathrm{\lambda x.[true]}\)</span></td>
<td><code>lambda x.[true]</code></td>
</tr>
<tr class="even">
<td><code>empty? expr</code></td>
<td><span class="math inline">\(\mathrm{[expr](\lambda x.\lambda y.[false])}\)</span></td>
<td><code>[expr](lambda x.lambda y.[false])</code></td>
</tr>
<tr class="odd">
<td><code>(list e1 e2...)</code></td>
<td><span class="math inline">\(\mathrm{[cons][e1][cons][e2]\dots[empty]}\)</span></td>
<td><code>[cons][e1][cons][e2]...[empty]</code></td>
</tr>
</tbody>
</table>
<p>其中：</p>
<ul>
<li><code>car cons e1 e2</code> <span class="math inline">\(\mathop {\rightarrow}\limits^\beta\)</span> <code>e1</code></li>
<li><code>cdr cons e1 e2</code> <span class="math inline">\(\mathop {\rightarrow}\limits^\beta\)</span> <code>e2</code></li>
</ul>
<div class="note"><p>primary</p></div>
<p><strong>演算提示</strong></p>
<p>不得不说，这个代数定义实在精彩，希望读者能拿纸笔算一算。在这里给出一定的提示</p>
<ul>
<li><p><code>cons = lambda a.lambda d.(lambda s.s a d)</code> 一式中：</p>
<ul>
<li><code>a</code> 为 <code>car</code>（二元组的第一元素）</li>
<li><code>d</code> 为 <code>cdr</code>（二元组的第二元素）</li>
<li><code>s</code> 为 选择器（selector），注意 <code>true</code> 和 <code>false</code> 的定义。</li>
</ul>
<p><code>cons</code> 实则返回的是一个选择器（也就是一个函数）。</p></li>
<li><p>请读者计算<code>empty? (cons e1 e2)</code> 和 <code>empty? empty</code>。</p></li>
</ul>
<!-- TODO: endnote-->
<h3 id="数">数</h3>
<table>
<thead>
<tr class="header">
<th>概念</th>
<th>Lambda 表达式</th>
<th>记法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0</code></td>
<td><span class="math inline">\(\mathrm{[empty]}\)</span></td>
<td><code>[false]</code></td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td><span class="math inline">\(\mathrm{[cons][true][false]}\)</span></td>
<td><code>[true]</code></td>
</tr>
<tr class="odd">
<td><code>add1 n</code></td>
<td><span class="math inline">\(\mathrm{[cons][true][}n]\)</span></td>
<td><code>[cons][true][n]</code></td>
</tr>
<tr class="even">
<td><code>sub1 n</code></td>
<td><span class="math inline">\(\mathrm{[cdr][n]}\)</span></td>
<td><code>[cdr][n]</code></td>
</tr>
<tr class="odd">
<td><code>zero? n</code></td>
<td><span class="math inline">\(\mathrm{[empty?][}n]\)</span></td>
<td><code>[empty?][n]</code></td>
</tr>
</tbody>
</table>
<p>需要注意的是，如果我们不用 <code>[true]</code> 和 <code>[false]</code> 表示 <code>0</code> 和 <code>1</code> ，而将其适当展开，我们可以得到这样的表达式：</p>
<ul>
<li><code>[0] = lambda x y.y</code></li>
<li><code>[n+1] = lambda x y.x [n]</code></li>
</ul>
<p>读者应该发现，在定义集合的势的时候，我们用了类似的处理方法：</p>
<blockquote>
<p>一个自然数可以定义为集合：</p>
<ul>
<li><span class="math inline">\(0=\emptyset\)</span></li>
<li>后继：<span class="math inline">\(n^+=n\cup\{n\}\)</span></li>
</ul>
<p>一个有穷集的势定义为与其等势的一个自然数。</p>
</blockquote>
<p>在定义这些运算之后，我们给出加法的定义：</p>
<table>
<colgroup>
<col style="width: 8%">
<col style="width: 56%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>Lambda 表达式</th>
<th>记法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>add x y</code></td>
<td><span class="math inline">\(\mathrm{\lambda x.\lambda y.\lambda s.\lambda z.(x~s~(y~s~z))}\)</span></td>
<td><code>lambda x y.lambda s z.(x s (y s z))</code></td>
</tr>
</tbody>
</table>
<p>以后在使用时，即可直接使用这些<strong>概念</strong>，进行演算。</p>
<h2 id="简单类型的lambda-演算">简单类型的Lambda 演算</h2>
<p>回顾前文中所有的Lambda 演算，我们发现，我们所有的演算，都是在Lambda 表达式中进行的，并没有脱开这些表达式，没有用到 <code>数</code> <code>布尔</code> 等常见的<strong>类型</strong>，在此引入这些概念：</p>
<p>类型化lambda演算的主要变化是增加了一个叫做「基类型」（base types）的概念。在类型化lambda演算中，你可以使用一些由原子值构成的论域（universe）， 这些值分为不同的简单类型。因此，例如，我们可以有一个类型 <span class="math inline">\(N\)</span>，它由包含了自然数集合，也可以有一个类型 <span class="math inline">\(B\)</span>，对应布尔值<code>true</code> / <code>false</code>，以及一个对应于字符串类型的类 <span class="math inline">\(S\)</span>。</p>
<p>现在我们有了基本类型，接下来我们讨论函数的类型。函数将一种类型（参数的类型）的值映射到的第二种类型（返回值的类型）的值。对于一个接受类型A的输入参数，并且返回类型B的值的函数，我们将它的类型写为<span class="math inline">\(A \rightarrow B\)</span> 。<span class="math inline">\(\rightarrow\)</span>叫做函数类型构造器（function type constructor），它是右关联的，所以 <span class="math inline">\(A \rightarrow B \rightarrow C\)</span> 表示 <span class="math inline">\(A \rightarrow (B \rightarrow C)\)</span>。</p>
<p>TODO: 未完待续</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Lambda演算</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 演算简介（3）</title>
    <url>/2020/06/11/study/ComputerScience/LambdaCalculi/LambdaCalc3/</url>
    <content><![CDATA[<p>Lambda 演算中的 Y 组合子</p>
<span id="more"></span>
<h2 id="y-组合子递归实现">Y 组合子：递归实现</h2>
<p>在之前，我们都在做一些简单的操作，例如实现了分支结构 <code>s e1 e2</code> ，现在我们要考虑如何实现第二种结构：循环与递归（recursion）。</p>
<p>在 Lambda 演算的世界里，递归是容易实现的，利用如下的 Y 组合子：</p>
<p><code>Y = lambda y.(lambda x.y (x x)) (lambda x.y (x x))</code></p>
<p>即：<span class="math inline">\(\mathrm{Y = \lambda y.(\lambda x.y~(x~x))~(\lambda x.y~(x~x))}\)</span></p>
<p>我们试着计算 <code>Y Y</code> 的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         Y Y</span><br><span class="line">(beta) =&gt;(lambda x.Y (x x)) (lambda x.Y (x x))</span><br><span class="line">(alpha)=&gt;(lambda x.Y (x x)) (lambda z.Y (z z))</span><br><span class="line">(beta) =&gt;Y ((lambda z.Y (z z)) (lambda z.Y (z z)))</span><br><span class="line">(alpha)=&gt;(lambda a. (lambda b . a (b b)) (lambda b. a (b b)))</span><br><span class="line">         ((lambda z. Y (z z)) (lambda z. Y (z z)))</span><br><span class="line">(beta) =&gt;Y (Y Y)</span><br><span class="line">...... =&gt;Y (Y (Y Y))</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>可以发现，Y 组合子通过 <code>Y Y</code> 创造了自身！这似乎是一个无穷递归，我们换一个例子看一看：假定 <code>f</code> 是一个关于 <code>x</code> 的函数，例如<code>f = (lambda x.add1 x)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         (Y f) x</span><br><span class="line">(beta) =&gt;(lambda y.(y (lambda x.y (x x) lambda x.y(x x))) f) x</span><br><span class="line">(alpha)=&gt;(f ((lambda x.f (x x)) (lambda x.f (x x)))) x</span><br><span class="line">(beta) &lt;=(f (Y f)) x</span><br><span class="line">...... &lt;=(f (f ( ... f(Y f))...) x</span><br></pre></td></tr></table></figure>
<p>这还不够，因为 <code>f</code> 是一个一元的函数，按照这个形式，即使给 <code>f</code> 一定的条件，使之在某处停下，我们也无法使之<strong>停下的条件</strong>与任何一个 <code>x</code> 有关。就以上面的表达式为例：</p>
<p><code>(Y f) =&gt; add1 (add1 (add1 ... )) x</code> 内部的 <code>add1</code> 并不会停下！</p>
<p>例如：<code>f (f (f)) x</code> 在这里，前面是先演算的内容，但是很明显在第三层停下递归并不是 <code>x</code> 所控制的。这并不是我们想要的，但是已经十分接近了！给这个形式做一些改变，则需要一个形式保留下来这个结构，并且将 <code>add1</code> 换为一个二元运算 <code>mult</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         (Y (lambda t.lambda x.mult x (t x)))) a</span><br><span class="line">...... =&gt;(lambda t.lambda x.mult x (t x) (Y lambda t.lambda x.mult(t x)) x) a</span><br><span class="line">(alpha)=&gt;(lambda t.lambda x&#x27;.mult x&#x27; (t x&#x27;) (Y lambda t.lambda x.mult(t x)) x) a</span><br><span class="line">(beta) =&gt;(lambda x&#x27;. mult x&#x27; (Y (lambda t.lambda x.mult x (t x))) x)) a</span><br><span class="line">(beta) =&gt;mult a (Y (lambda t.lambda x.mult x (t x))) a)</span><br><span class="line">...... =&gt;mult a (mult a (mult a ( ... )))</span><br></pre></td></tr></table></figure>
<p>最后我们加上一些判断，使之在某个地方停下，以及对于 <code>x</code> 的变换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LET: metafact = lambda fact . (lambda n . IsZero n 1 (Mult n (fact (Pred n))))</span><br><span class="line"></span><br><span class="line">   metafact (Y metafact) n</span><br><span class="line">=&gt; lambda n. zero? n 1 (mult n (Y metafact (Pred n))) n</span><br><span class="line">=&gt; mult n (Y metafact (Pred n))</span><br><span class="line">=&gt; mult n (metafact ((lambda x.metafact (x x)) (lambda x.metafact (x x))) (Pred n))</span><br><span class="line">=&gt; mult n (metafact (Y metafact) (Pred n))</span><br></pre></td></tr></table></figure>
<div class="note"><p>primary</p></div>
<p><strong>一点思考</strong></p>
<p>读者应分析结构：<code>lambda t.lambda x.f (t x) x</code>，指出其中 <code>f</code> 和 <code>t</code> 的作用：（在此仅给出个人的理解）</p>
<ul>
<li><code>f</code> 为函数算子</li>
<li><code>t</code> 为传入形式的复制</li>
</ul>
<p>如果从柯里化的角度看 Y 组合子是否更好？</p>
<!-- TODO: endnote-->
<h2 id="ski组合子">SKI组合子</h2>
<p>先给出 SKI 组合子的定义：</p>
<ul>
<li><code>S = (lambda x y z.(x z (y z)))</code></li>
<li><code>K = (lambda x y. x)</code></li>
<li><code>I = (lambda x.x)</code></li>
</ul>
<p>这个定义时很奇怪的，如何说呢，请看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  S K K x</span><br><span class="line">=&gt;(K x) (K x)</span><br><span class="line">=&gt;(lambda x y. x) x (K x)</span><br><span class="line">=&gt;x</span><br></pre></td></tr></table></figure>
<p>也就是说 <code>I = S K K</code>，其中 <code>=</code> 表示<strong>外延等价</strong>（extensional equivalence），当 <code>E x</code> 和 <code>E' x</code> <strong>总是</strong>有相同的约化结果恒成立，则称 <code>E = E'</code>。（另一种等价指<strong>内涵等价</strong>（intensional equivalence），当<code>E</code> 与 <code>E</code> 完全相同或经过 <span class="math inline">\(\alpha\)</span>-转换后有相同的结果）。</p>
<blockquote>
<p>在此略去 <strong>组合子演算</strong> 部分，这一部分可以参考<a href="http://cgnail.github.io/academic/lambda-5/">这篇文章</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Lambda演算</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式文法</title>
    <url>/2020/07/01/study/ComputerScience/mixed/RegExp/</url>
    <content><![CDATA[<p>正则表达式规则</p>
<span id="more"></span>
<h1 id="正则表达式">正则表达式</h1>
<h2 id="描述模式">描述模式</h2>
<table>
<tbody>
<tr class="odd">
<td>连接操作</td>
<td><code>AB &lt;=&gt; &#123;AB&#125;</code></td>
</tr>
<tr class="even">
<td>或操作</td>
<td><code>A|B &lt;=&gt;&#123;A,B&#125;</code></td>
</tr>
<tr class="odd">
<td>闭包操作</td>
<td><code>A* &lt;=&gt; U&#123;A^i&#125; i&gt;=0</code></td>
</tr>
<tr class="even">
<td>空字符串</td>
<td><code>eps</code></td>
</tr>
<tr class="odd">
<td>括号</td>
<td>提升优先级</td>
</tr>
</tbody>
</table>
<h3 id="正则表达式的定义">正则表达式的定义</h3>
<p>一个正则表达式可以是：</p>
<ol type="1">
<li>空字符串</li>
<li>单个字符</li>
<li>被括号包含的一个正则表达式</li>
<li>两个正则表达式连接成的表达式</li>
<li>由或运算分隔的两个表达式</li>
<li>由闭包运算标记的表达式</li>
</ol>
<h5 id="section"></h5>
<h3 id="描述符">描述符</h3>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>记法</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>通配符</td>
<td><code>.</code></td>
<td><code>A.B</code></td>
</tr>
<tr class="even">
<td>指定的集合</td>
<td>包含在<code>[]</code>中的字符</td>
<td><code>[ABC]*</code></td>
</tr>
<tr class="odd">
<td>范围</td>
<td>包含在<code>[]</code>中，由<code>-</code>分隔</td>
<td><code>[A-Z0-9]</code></td>
</tr>
<tr class="even">
<td>补集</td>
<td>包含在<code>[]</code>中的，且以<code>^</code>开头</td>
<td><code>[^A-Z]</code></td>
</tr>
</tbody>
</table>
<h3 id="闭包的简写">闭包的简写</h3>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>记法</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>至少一次</td>
<td><code>+</code></td>
<td><code>[0-9]+</code>（与下面这个等价）</td>
</tr>
<tr class="even">
<td>至少 0 次</td>
<td><code>*</code></td>
<td><code>[0-9][0-9]*</code></td>
</tr>
<tr class="odd">
<td>指定次数 <code>n</code></td>
<td><code>A&#123;n&#125;</code></td>
<td><code>[0-9]&#123;11&#125;</code></td>
</tr>
<tr class="even">
<td>指定次数范围 <code>a &lt;= n &lt;= b</code></td>
<td><code>A&#123;a-b&#125;</code></td>
<td><code>[A-Z]&#123;0-2&#125;</code></td>
</tr>
</tbody>
</table>
<h3 id="转义符">转义符：</h3>
<ul>
<li>任意空白字符：<code>\s</code></li>
<li>表示闭包的字符：<code>\*</code>，...</li>
<li>其他常见的字符：<code>\n</code>，<code>\t</code>，...</li>
</ul>
<figure>
<img src="/2020/07/01/study/ComputerScience/mixed/RegExp/image-20200622153014750.png" class="lazyload" data-srcset="/2020/07/01/study/ComputerScience/mixed/RegExp/image-20200622153014750.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200622153014750"><figcaption aria-hidden="true">image-20200622153014750</figcaption>
</figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习</title>
    <url>/2020/08/19/study/ComputerScience/mixed/datastructure-review/</url>
    <content><![CDATA[<p>数据结构复习</p>
<span id="more"></span>
<h3 id="绪论">0、绪论</h3>
<h4 id="碎碎念">碎碎念</h4>
<p>四种基本的逻辑结构：</p>
<ol type="1">
<li>集合结构</li>
<li>线性结构</li>
<li>树结构</li>
<li>图结构</li>
</ol>
<p><code>ADT</code>的概念：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ADT 数据类型 &#123;</span><br><span class="line">  数据对象：&lt;Definition&gt;</span><br><span class="line">  数据关系：&lt;Definition&gt;</span><br><span class="line">    基本操作：&lt;Definition&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意C和C++的区别，以及常用的语句</p>
<ol type="1">
<li>没有 template，没有 class</li>
<li><code>#define</code> 的使用</li>
<li><code>typedef</code>、<code>union</code> 的使用</li>
<li>异常处理：用的是 <code>Status</code> 表示（就是 <code>int</code> ），也有用 <code>exit</code> 的</li>
</ol>
<p>简单提一下 <code>#define</code> 和 <code>typedef</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDENTIFIER expr</span></span><br><span class="line"><span class="comment">// 在编译时会被直接替换成 expr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDENTIFIER(x,y,z) expr</span></span><br><span class="line"><span class="comment">// 在编译时会被直接替换成expr，并且将expr中的 x y z 替换</span></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 1.57 + 1.57</span></span><br><span class="line">cout &lt;&lt; PI; <span class="comment">// 编译时替换成 cout &lt;&lt; 1.57 + 1.57;</span></span><br><span class="line"><span class="comment">// 想一想 PI*PI 是什么</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISROOT(node) (node-&gt;father == nullptr)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">ISROOT</span>(tree._root_ptr);</span><br><span class="line"><span class="comment">// 编译时替换成 cout &lt;&lt; (tree._root_ptr -&gt; father == nullptr);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line">Status x; <span class="comment">// 等价于 int x;</span></span><br><span class="line"><span class="comment">// 注意：不能有 template&lt;</span></span><br></pre></td></tr></table></figure>
<div class="note"><p>primary</p></div>
<p><em>「再碎碎念一下」 %}</em></p>
<p><code>template</code> 还记得多少。</p>
<p><code>new</code> <code>delete</code> 填程序可能考的（释放空间，析构函数）</p>
<p>万一出卷老师一时兴起，和我一样作死用 <code>virtual</code> 写 <code>avl::bst</code> 咋办</p>
<p><code>typedef</code> 和 <code>#define</code> 定义的顺序不一样</p>
<p>我慌了。</p>
<!-- TODO: endnote-->
<h4 id="时间复杂度">时间复杂度</h4>
<p><strong>「全场暴毙」 %}</strong>：写出下面这个算法的时间复杂度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n 为 str 长度</span></span><br><span class="line"><span class="comment">// 则 func 是 o(?)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i)</span><br><span class="line">    <span class="keyword">if</span> (str[i] == c) cnt ++;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ans：<span class="math inline">\(O(n^2)\)</span></p>
</blockquote>
<h4 id="评估算法">评估算法</h4>
<p><strong>「算法的特性」 %}</strong>：</p>
<ol type="1">
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入</li>
<li>输出</li>
</ol>
<p><strong>「算法的评估」 %}</strong>：</p>
<ol type="1">
<li>高效性</li>
<li>正确性</li>
<li>健壮性</li>
<li>可读性</li>
</ol>
<div class="note"><p>info</p></div>
<p><strong>「要点：」 %}</strong></p>
<blockquote>
<ol type="1">
<li>时间复杂度如何？</li>
<li>空间复杂度如何？</li>
<li>相比其他算法的优缺点？</li>
<li>如何实现？（注意细节）</li>
<li>能手算吗？</li>
</ol>
</blockquote>
<!-- TODO: endnote-->
<h3 id="线性表">1、线性表</h3>
<p><strong>「顺序表」 %}</strong></p>
<ol type="1">
<li>静态 <code>#define MAXSIZE 100</code></li>
<li>动态 <code>new</code> or <code>malloc</code></li>
</ol>
<p>内存中的特点如何？</p>
<ul>
<li>插入o(n)：
<ul>
<li>思考：能不能用 <code>memcpy</code> 函数？</li>
</ul></li>
<li>删除o(n)：
<ul>
<li>这两个都要注意：表的长度要减少1</li>
</ul></li>
<li>搜索o(n)：
<ul>
<li>成功的平均比较次数 ASL = ？</li>
<li>失败的比较次数？</li>
</ul></li>
<li>合并
<ul>
<li>无序：<span class="math inline">\(O(na*nb)\)</span></li>
<li>有序：<span class="math inline">\(O(na+nb)\)</span></li>
</ul></li>
</ul>
<p><strong>「链表」 %}</strong></p>
<ol type="1">
<li>单链表存储、插入、删除、合并</li>
<li>循环链表</li>
<li>双向链表</li>
</ol>
<blockquote>
<p>应用</p>
<ol type="1">
<li>多项式的表示</li>
</ol>
</blockquote>
<h3 id="栈与队列">2、栈与队列</h3>
<p>链式存储！</p>
<ol type="1">
<li><strong>「栈」 %}</strong>：LIFO</li>
<li>定义</li>
<li>初始化</li>
<li>压栈</li>
<li>出栈 Q：一个 n 元素序列依次进栈，则其不同的出栈队列有多少种 A：卡特兰数</li>
<li><strong>「队列」 %}</strong>：FIFO</li>
<li>链式表示</li>
<li>循环队列（这个定义是啥？） 1. 重点是如何判断 overflow 2. 入队？出队？</li>
</ol>
<h3 id="串">3、串</h3>
<p>如何定义？</p>
<ol type="1">
<li>截止符 <code>\0</code></li>
<li>编码方式：Unicode or ASCII ？「这个考到就离谱」</li>
<li>子串</li>
<li>定长存储表示（堆分配）</li>
</ol>
<p>操作：</p>
<ol type="1">
<li>连接</li>
<li>求子串</li>
<li>插入（类似顺序表）</li>
<li>链式存储（块链）</li>
</ol>
<p>模式匹配算法</p>
<ol type="1">
<li>BF算法（一个个找）</li>
<li>KMP算法（跳转表）「如何求 <code>next</code> 表」</li>
</ol>
<ul>
<li>类似于有限状态自动机状态转移</li>
<li>KMP的时间复杂度（求 <code>next</code> 表）</li>
</ul>
<h3 id="数组和广义表">4、数组和广义表</h3>
<ul>
<li>一维数组</li>
<li>多维数组
<ul>
<li>【写给自己】记得别再傻傻的用 <code>new int **</code> 了！</li>
</ul></li>
</ul>
<p>特殊矩阵压缩：</p>
<ol type="1">
<li>对称：只存储对角线及以上（下）</li>
</ol>
<ul>
<li>行号、列号的计算？</li>
</ul>
<ol start="2" type="1">
<li>三对角矩阵： <code>k = 2 * i + j</code></li>
<li>稀疏矩阵：</li>
<li>存放方式（三元组法）</li>
<li>快速转置算法</li>
<li>矩阵乘法</li>
<li>十字链表存储</li>
</ol>
<p>广义表：</p>
<ol type="1">
<li>都是指针、链式！</li>
<li>表头表尾如何定义（链表结点）
<ol type="1">
<li>原子节点：tag=0+原子的值</li>
<li>表节点：tag = 1 + <code>表头指针 hp</code> + <code>表尾指针 tp</code></li>
</ol></li>
<li>第二种定义：
<ol type="1">
<li>分三个：<code>utype</code>，<code>info</code>，<code>tp</code></li>
</ol></li>
</ol>
<table>
<thead>
<tr class="header">
<th>utype</th>
<th>info</th>
<th>tp</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>被引用次数</td>
<td>表头</td>
</tr>
<tr class="even">
<td>1</td>
<td>数据值（atom）</td>
<td>下一个节点</td>
</tr>
<tr class="odd">
<td>2</td>
<td>（子）表</td>
<td>下一个节点</td>
</tr>
</tbody>
</table>
<h3 id="树">5、树</h3>
<ol type="1">
<li>定义（高度、兄弟、……）
<ol type="1">
<li>性质</li>
<li>完全二叉树、满二叉树</li>
</ol></li>
<li>存储方式
<ol type="1">
<li>（完全）二叉树的顺序存储：有可能编号从 1 开始</li>
<li>链表存储：
<ol type="1">
<li>二叉链表：<code>lc</code> + <code>data</code> + <code>rc</code></li>
<li>三叉链表：<code>lc</code> + <code>data</code> + <code>father</code> + <code>rc</code></li>
</ol></li>
</ol></li>
<li>二叉树深度优先遍历（先中后）
<ol type="1">
<li>表达式求值 【危】</li>
</ol></li>
<li>二叉树层次遍历
<ol type="1">
<li>其中使用了____（线性数据结构）？</li>
</ol></li>
<li>线索化
<ol type="1">
<li><code>prec</code> + <code>lc</code> + <code>data</code> + <code>rc</code> + <code>suss</code></li>
<li>中序遍历建立</li>
</ol></li>
<li>树的存储方式
<ol type="1">
<li>双亲法、</li>
<li>指针法、</li>
<li>链表法、</li>
<li>孩子兄弟法</li>
</ol></li>
<li>树和二叉树的转换</li>
<li>树的各种遍历法</li>
<li>森林化为二叉树</li>
</ol>
<div class="note"><p>primary</p></div>
<p><strong>应用</strong></p>
<ol type="1">
<li><strong>「堆」 %}</strong>：上浮下沉
<ol type="1">
<li>用的是完全二叉树的顺序存储</li>
</ol></li>
<li><strong>「Huffman编码树」 %}</strong></li>
</ol>
<!-- TODO: endnote-->
<h3 id="查找">6、查找</h3>
<ol type="1">
<li><strong>查找表</strong></li>
<li>关键字</li>
<li>属性</li>
<li>（无序）顺序表查找</li>
<li>检查哨？（这玩意的意义到现在也没懂）</li>
<li><code>ASL = (n + 1) / 2</code></li>
<li><code>ASL = n + 1 (fail)</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(SeqTable st, KeyTp key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  st.elem[<span class="number">0</span>].key = key;</span><br><span class="line">  <span class="keyword">for</span> (i = st.length; st.elem[i].key != key; --i);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>（有序）顺序表查找「二分查找法」</li>
<li>可以得到「判定树<code>Decision Tree</code>」</li>
<li>索引顺序表（分块查找）</li>
<li>特点：块间有序，块内无序</li>
<li>附加索引表（关键字有序）</li>
</ol>
<p>【顺序表查找方法比较】</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>顺序查找</th>
<th>折半查找</th>
<th>分块查找</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ASL</td>
<td>最大</td>
<td>最小</td>
<td>折中</td>
</tr>
<tr class="even">
<td>表结构</td>
<td>有序、无序</td>
<td>有序</td>
<td>分块有序</td>
</tr>
<tr class="odd">
<td>存储结构</td>
<td>顺序存储结构、线性链表</td>
<td>顺序存储</td>
<td>顺序存储结构线性链表</td>
</tr>
</tbody>
</table>
<h4 id="二叉搜索树bst">二叉搜索树（BST）</h4>
<p>定义：<code>lc.key &lt;= self.key &lt;= rc.key (lc, rc exists)</code></p>
<ol type="1">
<li>如何搜索？
<ol type="1">
<li>递归</li>
<li><strong>注意宏定义！！！</strong>（不清楚看：§1.碎碎念）
<ol type="1">
<li><code>#define EQ(a, b) ((a) == (b))</code> <em>（没必要）</em></li>
</ol></li>
</ol></li>
<li>插入
<ol type="1">
<li><strong>先搜索，看这个元素存不存在！</strong>
<ol type="1">
<li>搜索成功，已经有这个元素（不插入？替换？看题目）</li>
<li>不成功，插入这个元素（作为叶子）</li>
</ol></li>
</ol></li>
<li>通过无序表构造二叉搜索树</li>
<li>删除结点
<ol type="1">
<li>叶子？</li>
<li>左右子女有一个为空？</li>
<li>都非空？（直接后继：右子树“最左侧”的结点）</li>
</ol></li>
<li>这边莫名q了一下「卡特兰数」：对于有 n 个关键字的集合，其关键字有 n! 种不同排列，可构成的不同的二叉搜索树有 <span class="math inline">\(\frac{1}{n-1}C^n_{2n}\)</span> 颗。<br>
</li>
<li>“匀称”？AVL
<ol type="1">
<li>平衡条件：<code>-1 &lt;= lc.height - rc.height &lt;= 1</code> 其中：<code>lc.height - rc.height</code> 被称为「平衡因子」。</li>
<li>维持平衡方法：旋转
<ol type="1">
<li>单旋：
<ol type="1">
<li><code>right(node)</code></li>
<li><code>left(node)</code></li>
</ol></li>
<li>双旋：
<ol type="1">
<li>左右 <code>leftright(node) = left(node-&gt;lc) + right(node)</code></li>
<li>右左 <code>rightleft(node) = right(node -&gt; rc) + left(node)</code></li>
</ol></li>
</ol></li>
<li>什么时候用？
<ol type="1">
<li><code>left</code> ：<code>node-&gt;lc-&gt;lc</code> 高</li>
<li><code>right</code>：<code>node-&gt;rc-&gt;rc</code> 高</li>
<li><code>leftright</code>：<code>node-&gt;lc-&gt;rc</code> 高</li>
<li><code>rightleft</code>：<code>node-&gt;rc-&gt;lc</code> 高</li>
</ol></li>
<li>插入：
<ol type="1">
<li>先按BST插入</li>
<li>检查、维持平衡</li>
</ol></li>
</ol></li>
</ol>
<p><strong>「B 树」 %}</strong></p>
<blockquote>
<p>盲猜会考【迷之自信】</p>
</blockquote>
<ol type="1">
<li>定义
<ol type="1">
<li>实际上和BST(AVL)很像（算是BST(AVL)的推广？）</li>
<li>BST(AVL)在每个结点上都是用一个 <code>key</code> 把原来的有序表分成了两块，例如：<code>(key=1, lc = &#123;key &lt; 1&#125;, rc = &#123;key &gt; 1&#125;)</code> 【意会一下】</li>
<li>B树（思想上）就是分成了k块（<code>m/2 &lt;= k &lt;= m</code>）：<code>(ptr[0] = &#123;key &lt; key[1]&#125;, key[1], ptr[1] = &#123;key[1] &lt; key &lt; key[2]&#125;, key[2], ... , ptr[k] = &#123;key[k] &lt; key &lt; key[k+1]&#125;, key[k+1], ptr[k+1] = &#123;key[k+1] &lt; key])</code>（还是提一下：分成k块只要切k-1刀，所以key从1开始索引）</li>
<li>细节看ppt。（平衡因子 = 0、叶子结点为 F 的作用）</li>
</ol></li>
<li>查找<code>targ_key</code>：
<ol type="1">
<li>从根结点开始 <code>current_node = root</code></li>
<li>如果<code>current_node</code> 是 F（叶子），返回<code>not found</code>，否则在这个结点上找<code>targ_key</code>（顺序查找！就那么几个点，二分很可能效率更低！）
<ol type="1">
<li>找到：返回</li>
<li>没找到，在 <code>ptr[next]</code> 中继续找，其中 ：
<ol type="1">
<li>next = x <code>(key[x] &lt; targ_key &lt; key[x+1])</code></li>
<li>next = k <code>(key[k] &lt; targ_key &amp;&amp; 该结点只有 k+1 个key)</code></li>
<li>next = 0 <code>(targ_key &lt; key[0])</code></li>
</ol></li>
</ol></li>
<li>转 2</li>
<li>【类比二叉搜索树的查找】</li>
</ol></li>
<li>插入：
<ol type="1">
<li>平衡维持：分裂</li>
<li>看ppt吧，我也写不清楚，画图比较好，也就几种情况：</li>
<li>father 的 ptr 数目（度）&lt; m？</li>
<li>father 的 ptr 数目（度）= m？</li>
<li>这个分裂的结点是root？</li>
</ol></li>
<li>构造：不断插入</li>
</ol>
<p><strong>「B+」 %}</strong> 1. 注意和B树的区别： 1. m 还是 m + 1？ 2. 看清楚上一层的key实则是子树的key的最大值 3. 最底层从左到右排列就是原表（有序） 2. 插入： 1. 平衡维持：分裂 2. 看ppt吧，我也写不清楚，画图比较好，也就几种情况： 1. father 的 ptr 数目（度）&lt; m？ 2. father 的 ptr 数目（度）= m？ 3. 这个分裂的结点是root？</p>
<p><strong>「Hash」 %}</strong></p>
<ol type="1">
<li>两个问题：
<ol type="1">
<li>均匀的散列函数（简单快速）</li>
<li>解决冲突的方案</li>
</ol></li>
<li>Hash函数：
<ol type="1">
<li>「直接定址法」：<code>Hash(key) = a * key + b</code>（适合相对连续的数字）</li>
<li>「数字分析法」：选择近乎随机的某几位（书上讲的好点）</li>
<li>「除留余数法」：<code>Hash(key) = key % p</code></li>
<li>「平方取中法」：一般取散列地址总数为 8 的 r 次幂，则取平方数中间的 r 位</li>
<li>「折叠法」：<code>123456789</code> -&gt; <code>123+456+789</code></li>
</ol></li>
<li>冲突解决：
<ol type="1">
<li>「开放地址法」：线性探测法、二次探测法、伪随机探测法（书上例子挺好的，摘在下面）</li>
<li>「再哈希法」</li>
<li>「链地址法」：每一个 key 都对应一个链表</li>
<li>「公共区溢出法」（书上没有）</li>
</ol></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hash(key) = key % <span class="number">11</span>;</span><br><span class="line">[\ \ \ \ \ <span class="number">60</span> <span class="number">17</span> <span class="number">29</span> \ \ \]</span><br><span class="line"><span class="comment"># 插入 38， 且产生随机数 9</span></span><br><span class="line"><span class="comment"># 线性探测：(d = 3)</span></span><br><span class="line">[\ \ \ \ \ <span class="number">60</span> <span class="number">17</span> <span class="number">29</span> <span class="number">38</span> \ \]</span><br><span class="line"><span class="comment"># 二次：（d = -1)</span></span><br><span class="line">[\ \ \ \ <span class="number">38</span> <span class="number">60</span> <span class="number">17</span> <span class="number">29</span> \ \ \]</span><br><span class="line"><span class="comment"># 伪随机：(d = 9)</span></span><br><span class="line">[\ \ \ <span class="number">38</span> \ <span class="number">60</span> <span class="number">17</span> <span class="number">29</span> \ \ \]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>ASL(success)</th>
<th>ASL(fail)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>线性探测</td>
<td><span class="math inline">\(\frac 1 2(1+\frac 1{1-\alpha})\)</span></td>
<td><span class="math inline">\(\frac 1 2(1+\frac 1{(1-\alpha})^2)\)</span></td>
</tr>
<tr class="even">
<td>二次/伪随机</td>
<td><span class="math inline">\(-\frac 1 \alpha \ln(1-\alpha)\)</span></td>
<td><span class="math inline">\(\frac 1 {1-\alpha}\)</span></td>
</tr>
<tr class="odd">
<td>链地址法</td>
<td><span class="math inline">\(1 + \frac \alpha 2\)</span></td>
<td><span class="math inline">\(\alpha + e^{-\alpha}\)</span></td>
</tr>
</tbody>
</table>
<h3 id="图">7、图</h3>
<p>基础概念：自己看离散「超凶」：<span class="btn 2020/05/28/study/ComputerScience/DiscreteMath/GraphTheory/"><a class="button" href="图的基本概念" title="图的基本概念">图的基本概念</a></span></p>
<ol type="1">
<li>存储方式
<ol type="1">
<li>「邻接矩阵」：<code>A[i, j] = ( &lt; i, j &gt; in E) ? weight(i, j) : ((i == j) ? 0 : UNDEFINED)</code>
<ol type="1">
<li>稀疏时严重的空间浪费！</li>
</ol></li>
<li>「邻接表」：<code>adj[i]</code> 为 i 的出边（无向图：相临边）
<ol type="1">
<li>逆临接表</li>
</ol></li>
</ol></li>
<li>遍历（<del>不会吧不会吧，不会真的有人不会吧</del>）
<ol type="1">
<li>「DFS」</li>
<li>「BFS」</li>
</ol></li>
<li>「MST」
<ol type="1">
<li>「Prim」：增加点</li>
<li>「Kruskal」：不断连接连通分支</li>
</ol></li>
<li>AOV
<ol type="1">
<li>「拓扑排序」：O(n+e)</li>
</ol></li>
<li>AOE
<ol type="1">
<li>关键路径：
<ol type="1">
<li>路径上的点都是关键活动点 是 该路径为关键路径的 _____ 条件？</li>
<li>最早可能开始时间 <code>e[k]</code> = 最迟允许开始时间 <code>l[k]</code></li>
<li>有点像DP（拓扑）？怎么手算？</li>
</ol></li>
</ol></li>
<li>最短路径
<ol type="1">
<li><strong>「Dijkstra算法」</strong>
<ol type="1">
<li>念叨一句使用条件：『无负权边』</li>
</ol></li>
<li><strong>「Floyd算法」</strong>（ppt 里面没有）</li>
<li>「SPFA」！！（书上 ppt 都没有）：无负边的时候，绝对是最快的</li>
</ol></li>
</ol>
<h3 id="排序">8、排序</h3>
<p>简单提几句就行了、叭、、</p>
<table>
<thead>
<tr class="header">
<th>alg</th>
<th>时间复杂度</th>
<th>稳定？</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>插入</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>y</td>
<td>想想打牌的时候理牌的过程</td>
</tr>
<tr class="even">
<td>选择</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>n</td>
<td>选剩下的最大的扔到最后</td>
</tr>
<tr class="odd">
<td>希尔</td>
<td><span class="math inline">\(O(n log n)\)</span></td>
<td>n</td>
<td>玄学算法复杂度（缩小增量）</td>
</tr>
<tr class="even">
<td>冒泡</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>y</td>
<td>冒泡赛</td>
</tr>
<tr class="odd">
<td>「快排」</td>
<td><span class="math inline">\(O(n log n)\)</span></td>
<td>n</td>
<td>重点</td>
</tr>
<tr class="even">
<td>堆排</td>
<td><span class="math inline">\(O(n log n)\)</span></td>
<td>n</td>
<td>建立（升序建立大根堆）堆，抽堆顶，维护堆</td>
</tr>
<tr class="odd">
<td>归并</td>
<td><span class="math inline">\(O(n log n)\)</span></td>
<td>y</td>
<td>常见（C++ STL）</td>
</tr>
<tr class="even">
<td>基数</td>
<td><span class="math inline">\(O(n log n)\)</span></td>
<td>n</td>
<td>分配、收集</td>
</tr>
</tbody>
</table>
<p><strong>「快速排序」 %}</strong>：主要思想是选一个数，做交换，让序列中左边的数都比这个数小，右边的数都比这个数大。</p>
<p>q一下以前见过的一个讲的很好的解释【找不到链接了，如果找到了请评论区发一下】：</p>
<blockquote>
<p>快排可以用挖坑 + 填坑来理解（这个看ppt上有一个图）</p>
<ol type="1">
<li>记住pivot，然后把pivot的位置上挖个坑，并且设置 <code>i, j = l, r</code></li>
<li>在右侧（j 从右向左）找一个比pivot大的，填到坑里，并且把 j 这里挖个坑【此时若出现 i &gt;= j 转 4 】</li>
<li>在左侧（i 从左向右）找一个比pivot小的，填到坑里，并且把 i 这里挖个坑【此时若出现 i &gt;= j 转 4 】</li>
<li>这个时候 i == j，而且在这里有个坑可以填，将pivot填进去</li>
<li>对左侧序列，右侧序列执行快排。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个是 Pivot</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span>(<span class="params">seq : <span class="built_in">list</span>, l : <span class="built_in">int</span>, r : <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pivot = seq[l]</span><br><span class="line">    i, j = l, r</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j):</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j <span class="keyword">and</span> seq[j] &gt;= pivot):</span><br><span class="line">            j--</span><br><span class="line">        seq[i] = seq[j]</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j <span class="keyword">and</span> seq[i] &lt;= pivot):</span><br><span class="line">            i++</span><br><span class="line">        seq[j] = seq[i]</span><br><span class="line">    <span class="comment"># 此时 i == j</span></span><br><span class="line">    seq[i] = pivot</span><br><span class="line">    <span class="comment"># 对左右两侧的表分别排序</span></span><br><span class="line">    qsort(seq, l, i - <span class="number">1</span>)</span><br><span class="line">    qsort(seq, i + <span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机 Pivot</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span>(<span class="params">seq: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    p = randint(l, r)</span><br><span class="line">    pivot = seq[p] <span class="comment"># 随便选一个 pivot</span></span><br><span class="line">    i, j = l, r</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j):</span><br><span class="line">        <span class="keyword">while</span> (pivot &lt;= seq[r] <span class="keyword">and</span> l &lt; r):</span><br><span class="line">            r--</span><br><span class="line">        p, seq[p] = r, seq[r]</span><br><span class="line">        <span class="keyword">while</span> (pivot &gt;= seq[l] <span class="keyword">and</span> l &lt; r):</span><br><span class="line">            l++</span><br><span class="line">        p, seq[p] = l, seq[l]</span><br><span class="line">    seq[i] = pivot</span><br><span class="line">    qsort(seq, l, i - <span class="number">1</span>)</span><br><span class="line">    qsort(seq, i + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不保证正确。嘿嘿😶</p>
</blockquote>
<p>插入排序</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="插入排序"><figcaption aria-hidden="true">插入排序</figcaption>
</figure>
<p>希尔排序</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="希尔排序"><figcaption aria-hidden="true">希尔排序</figcaption>
</figure>
<p>冒泡排序</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="冒泡排序"><figcaption aria-hidden="true">冒泡排序</figcaption>
</figure>
<p>快速排序</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="快速排序"><figcaption aria-hidden="true">快速排序</figcaption>
</figure>
<p>选择排序</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="选择排序"><figcaption aria-hidden="true">选择排序</figcaption>
</figure>
<p>堆排序</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="堆排序1"><figcaption aria-hidden="true">堆排序1</figcaption>
</figure>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="堆排序2"><figcaption aria-hidden="true">堆排序2</figcaption>
</figure>
<p>归并排序</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="归并排序"><figcaption aria-hidden="true">归并排序</figcaption>
</figure>
<p>基数排序</p>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="基数排序"><figcaption aria-hidden="true">基数排序</figcaption>
</figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>「复变函数」</title>
    <url>/2020/11/20/study/Math/ComplexFunctions/ch1/</url>
    <content><![CDATA[<p>复数与复变函数</p>
<span id="more"></span>
<h2 id="ch1-复数与复变函数">Ch1 复数与复变函数</h2>
<h3 id="复数的概念与运算">复数的概念与运算</h3>
<h4 id="复数的概念">复数的概念</h4>
<p><strong>Def</strong>（复数）<span class="math inline">\((x,y)\)</span> -&gt; <span class="math inline">\(z=x+iy,i^2=-1\)</span></p>
<ol type="1">
<li><span class="math inline">\(\mathrm{Re}(z)\)</span></li>
<li><span class="math inline">\(\mathrm{Im}(z)\)</span></li>
<li>相等：实部虚部对应相等</li>
</ol>
<h5 id="复数的代数运算">复数的代数运算</h5>
<ol type="1">
<li>加减</li>
<li>乘除</li>
</ol>
<p>满足的运算规律：</p>
<ol type="1">
<li>交换</li>
<li>结合</li>
<li>分配</li>
</ol>
<h5 id="共轭复数">共轭复数</h5>
<p><span class="math inline">\(\bar z = x - iy\)</span></p>
<p><strong>共轭复数的性质</strong>：</p>
<ol type="1">
<li><span class="math inline">\(z \bar z = |z|\)</span></li>
<li><span class="math inline">\(\overline{z_1\pm z_2} = \bar{z_1}\pm\bar{z_2}\)</span></li>
<li><span class="math inline">\(\overline{z_1z_2} = \bar{z_1}\bar{z_2}\)</span></li>
<li><span class="math inline">\(z+\bar z = \mathrm{Re}(z)\)</span></li>
<li><span class="math inline">\((z-\bar z)/i = \mathrm{Im}(z)\)</span></li>
</ol>
<h4 id="复数的几何表示">复数的几何表示</h4>
<ol type="1">
<li><p>点表示：<span class="math inline">\(z=x+iy\leftrightarrow (x,y)\)</span> 复平面、实轴、虚轴</p></li>
<li><p>向量表示</p></li>
<li><p>三角表达：<span class="math inline">\(z=r(\cos\theta+i\sin \theta)\)</span></p></li>
</ol>
<h5 id="复数的模和辐角">复数的模和辐角</h5>
<ol type="1">
<li>模 <span class="math inline">\(|z| = r = \sqrt{x^2+y^2}\)</span></li>
<li>辐角 <span class="math inline">\(\mathrm{Arg}~z = \theta\)</span></li>
</ol>
<blockquote>
<p>利用欧拉公式：</p>
<ul>
<li><span class="math inline">\(z = re^{i\theta}\)</span></li>
</ul>
<p><span class="math inline">\(z = 0\)</span> 辐角不确定</p>
<p>辐角的主值 <span class="math inline">\(-\pi&lt;\theta_0\le\pi\)</span></p>
</blockquote>
<p>辐角主值计算：</p>
<ol type="1">
<li>求 <span class="math inline">\(\arctan \frac y x\)</span></li>
<li>求 <span class="math inline">\(\theta_0\)</span>，注意：<span class="math inline">\(\theta_0\in(-\pi,\pi]\)</span></li>
</ol>
<div class="note"><p>caution</p></div>
<ul>
<li><span class="math inline">\(\mathrm{Arg}(z_1z_2)=\mathrm{Arg}z_1+\mathrm{Arg}z_2\)</span></li>
<li><span class="math inline">\(\mathrm{Arg}(z_1/z_2)=\mathrm{Arg}z_1-\mathrm{Arg}z_2\)</span></li>
</ul>
<p>注意这里指的是集合相等</p>
<ul>
<li><span class="math inline">\(|z_1z_2|=|z_1||z_2|\)</span></li>
<li><span class="math inline">\(|z_1/z_2|=|z_1|/|z_2|\)</span></li>
</ul>
<!-- TODO: endnote-->
<h4 id="复数的乘幂和方根">复数的乘幂和方根</h4>
<h5 id="复数的乘幂">复数的乘幂</h5>
<p><span class="math display">\[
\begin{aligned}
&amp;z=re^{i\theta} = r(\cos\theta+i\sin\theta)\\
&amp;z^n = z\cdot z\cdot z\cdot\dots\cdot z\\
&amp;z^n=re^{in\theta}=r(\cos n\theta+i\sin n\theta)
\end{aligned}
\]</span></p>
<p><strong>Thm</strong>（棣莫弗公式）<span class="math inline">\(|z|=r=1\)</span> 时：<span class="math inline">\((\cos \theta+i\sin \theta)^n=\cos n\theta + i \sin n\theta\)</span></p>
<h5 id="复数的方根">复数的方根</h5>
<p><span class="math display">\[
\begin{aligned}
&amp;z=re^{i\theta} = r(\cos\theta+i\sin\theta)\\
&amp;\sqrt[n]z= \sqrt[n]r(\cos\frac{\theta + 2k\pi}n+i\sin\frac{\theta + 2k\pi}n)\\
\end{aligned}
\]</span></p>
<h4 id="复数在几何上的应用举例">复数在几何上的应用举例</h4>
<div class="note"><p>primary</p></div>
<p>求解：<span class="math inline">\(z^n=1\)</span></p>
<!-- TODO: endnote-->
<div class="note"><p>primary</p></div>
<p>复数表示复平面上的过<span class="math inline">\(z_1,~z_2\)</span>的直线方程：<span class="math inline">\(z-z_1=t(z_2-z_1)\)</span></p>
<!-- TODO: endnote-->
<div class="note"><p>success</p></div>
<p>复数表示圆方程：<span class="math inline">\(|z-z_0| = R\)</span></p>
<!-- TODO: endnote-->
<div class="note"><p>secondary</p></div>
<ol type="1">
<li>中垂线：<span class="math inline">\(|z-z_1|=|z-z_2|\)</span></li>
<li>特殊直线：<span class="math inline">\(\mathrm{Im}(i+z)=4\)</span></li>
</ol>
<!-- TODO: endnote-->
<h4 id="复球面与无穷远点">复球面与无穷远点</h4>
<ul>
<li>引入无穷远点，表达复数：扩充复平面</li>
</ul>
<h2 id="复变函数的极限与连续性">复变函数的极限与连续性</h2>
<h3 id="复平面上的区域">复平面上的区域</h3>
<h4 id="区域的概念">区域的概念</h4>
<p><strong>Def</strong>（开集）所有点都是集合的内点</p>
<p><strong>Def</strong>（区域）连通的开集</p>
<blockquote>
<p>开集：<span class="math inline">\(\forall z\in A,\exists U(z)\subset A\)</span>，即<span class="math inline">\(\mathrm{int}A = A\)</span></p>
<ul>
<li>内点、外点、边界点 连通：折线连接</li>
<li>单连通、复连通（用闭曲线包围部分是否都在原集合内定义）</li>
</ul>
<p><span class="math inline">\(z_0\)</span> 的 <span class="math inline">\(\delta\)</span> 邻域</p>
<p>去心邻域</p>
<p>同理定义 <span class="math inline">\(\infin\)</span>的邻域和去心邻域</p>
</blockquote>
<h5 id="简单曲线单连通多连通">简单曲线、单连通、多连通</h5>
<p><strong>简单曲线</strong>：</p>
<ul>
<li>连续</li>
<li>导函数连续，且 <span class="math inline">\((x&#39;)^2+(y&#39;)^2 \ne 0\)</span></li>
<li>不相交（没有重点）：<span class="math inline">\(t_1=t_2\Leftrightarrow z(t_1)=z(t_2)\)</span></li>
</ul>
<p><strong>连通区域</strong>：</p>
<ul>
<li>单连通</li>
<li>多连通</li>
</ul>
<h4 id="复变函数的概念">复变函数的概念</h4>
<p><strong>Def</strong>（复变函数）<em>可以是多值的</em></p>
<ul>
<li>映射下的象和原象</li>
<li>复变函数的集合表示</li>
</ul>
<h3 id="复变函数的极限和连续性">复变函数的极限和连续性</h3>
<p><strong>Def</strong>（极限）</p>
<p><strong>Thm</strong>：设<span class="math inline">\(f\)</span>在<span class="math inline">\(z_0\)</span>的某个去心领域有定义，则：</p>
<p><span class="math display">\[
\lim f(z) = A\iff \begin{cases}
   \lim u = \mathrm{Re}(A)\\
   \lim v = \mathrm{Im}(A)
\end{cases}
\]</span></p>
<p>极限的性质：</p>
<ul>
<li>唯一性</li>
<li>局部有界性</li>
<li>有理运算法则</li>
</ul>
<p><strong>Def</strong>（连续、在区域内连续）</p>
<p><strong>Thm</strong>：<span class="math inline">\(f\)</span> 在 <span class="math inline">\(z_0\)</span> 连续. <span class="math inline">\(\iff\)</span> <span class="math inline">\(u\)</span>，<span class="math inline">\(v\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 同时连续</p>
<ul>
<li>有理运算不改变连续性</li>
<li>函数复合不改变连续性</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「复变函数」复变函数的导数和解析函数</title>
    <url>/2020/11/20/study/Math/ComplexFunctions/ch2/</url>
    <content><![CDATA[<p>复变函数的导数和解析函数 <span id="more"></span></p>
<h2 id="ch2-复变函数的导数和解析函数">Ch2 复变函数的导数和解析函数</h2>
<h3 id="解析函数的概念及其判定">解析函数的概念及其判定</h3>
<h4 id="复变函数的导数微分">复变函数的导数、微分</h4>
<p><strong>Def</strong>：复变函数的导数、可导、在 D 内可导</p>
<p>求导公式：有理运算求导、反函数求导</p>
<p><strong>复变函数的可微性</strong>：</p>
<p><strong>Def</strong>（可微）<span class="math inline">\(\mathrm dw=f&#39;(z_0)\Delta z\)</span></p>
<p><strong>Thm</strong>：可微 <span class="math inline">\(\iff\)</span> 可导</p>
<p><strong>Thm</strong>（可导的必要条件）C-R 方程：</p>
<p><span class="math display">\[
\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y},
\frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x},
\]</span></p>
<p><strong>Thm</strong>（可导的充要条件）</p>
<ol type="1">
<li><span class="math inline">\(u,~v\)</span> 在<span class="math inline">\((x,y)\)</span>可微</li>
<li><span class="math inline">\(u,~v\)</span> 在<span class="math inline">\((x,y)\)</span>满足 C-R 方程</li>
</ol>
<h4 id="解析函数">解析函数</h4>
<p><strong>Def</strong>（解析、在区域D内解析）在 <span class="math inline">\(z_0\in C\)</span> 及其某个邻域内处处可导--&gt;解析</p>
<p><strong>Thm</strong> 设函数 <span class="math inline">\(f(z)=u(x,y)+iv(x,y)\)</span> 定义在区域 D 内，若它的任意一点 <span class="math inline">\(z\in D\)</span> 可导，则必有</p>
<ol type="1">
<li><span class="math inline">\(u,v\)</span> 偏导数在 <span class="math inline">\((x,y)\)</span> 出存在</li>
<li>满足 C-R 方程</li>
</ol>
<p><em>Inference</em>：在上述定理的条件下，<span class="math inline">\(f(z)\)</span> 在点 <span class="math inline">\(z\)</span> 处的导数为</p>
<p><span class="math display">\[
f&#39;(z)=\frac{\partial u}{\partial x}+i\frac{\partial v}{\partial x}=
\frac{1}{i}\frac{\partial u}{\partial y} + \frac{\partial v}{\partial y}
\]</span></p>
<p><strong>Thm</strong>：在区域 D 内解析 <span class="math inline">\(\iff\)</span></p>
<ol type="1">
<li><span class="math inline">\(u,~v\)</span> 在 D 可微</li>
<li><span class="math inline">\(u,~v\)</span> 在 D 内任一点处满足 C-R 条件</li>
</ol>
<h5 id="解析函数和调和函数">解析函数和调和函数</h5>
<blockquote>
<p>若二元实函数在D内由二阶连续偏导数，且满足Laplace方程<span class="math inline">\(\displaystyle\frac{\partial^2\varphi}{\partial x^2}+\frac{\partial^2\varphi}{\partial y^2} = 0\)</span>，则称其为D内的调和函数。</p>
</blockquote>
<p><strong>Thm</strong>：<span class="math inline">\(f\)</span>解析，则<span class="math inline">\(u,~v\)</span> 是 D 内的调和函数</p>
<p><strong>Def</strong>（共轭调和函数）解析函数的虚部 <span class="math inline">\(v\)</span> 称为实部 <span class="math inline">\(u\)</span> 的共轭调和函数。</p>
<blockquote>
<p><span class="math inline">\(f = v+iu\)</span>不一定解析。</p>
</blockquote>
<h3 id="基本初等函数">基本初等函数</h3>
<h4 id="指数函数">指数函数</h4>
<p><span class="math inline">\(\displaystyle w = e^z = e^x(\cos y + i \sin y)\)</span></p>
<p><strong>性质</strong>：</p>
<ul>
<li><span class="math inline">\(|e^z| = e^x, Arg~e^z = y+2k\pi\)</span></li>
<li>加法定理：<span class="math inline">\(e^{z_1}e^{z_2}=e^{z_1+z_2}\)</span></li>
<li>周期性：<span class="math inline">\(e^{z+2k\pi i} = e^z\)</span></li>
<li>处处解析：<span class="math inline">\((e^z)&#39;=e^z\)</span></li>
</ul>
<div class="note"><p>primary</p></div>
<ol type="1">
<li><span class="math inline">\(y = 0\Rightarrow w = e^x\)</span></li>
<li><span class="math inline">\(x = 0\Rightarrow w = e^{iy}=\cos y+i\sin y\)</span></li>
</ol>
<!-- TODO: endnote-->
<h4 id="对数函数">对数函数</h4>
<p><span class="math inline">\(\displaystyle w=\mathrm{Ln} z = \ln |z| + i \mathrm{Arg}z =\ln |z| + i (\mathrm{arg}z + 2k\pi)\)</span></p>
<p><strong>性质</strong>：</p>
<ul>
<li><span class="math inline">\(\mathrm{Ln}z\)</span> 为无穷多值函数</li>
<li><span class="math inline">\(\mathrm{Ln}(-1) = (2k+1)\pi i\)</span></li>
<li>运算同 <span class="math inline">\(\ln\)</span></li>
<li>解析性：除<strong>原点</strong>和<strong>负实轴</strong>外的其他点处解析</li>
<li>（对数函数）主值：<span class="math inline">\(\ln z\)</span></li>
</ul>
<p><strong>连续（解析）分支</strong>：使得其成为连续（解析）函数。</p>
<blockquote>
<p>这里就是选取一个合适的 <span class="math inline">\(k\)</span></p>
</blockquote>
<h4 id="幂函数">幂函数</h4>
<p><span class="math inline">\(w = z^\alpha = e^{a\mathrm{Ln} z}\)</span></p>
<ul>
<li>可能是多值函数：考虑<span class="math inline">\(\alpha\)</span>对于<span class="math inline">\(\mathrm{Ln}z = \ln|z| +i(\arg~z+2k\pi)\)</span> 中 <span class="math inline">\(k\)</span> 的影响
<ul>
<li><span class="math inline">\(\alpha\)</span> 是整数：单值函数</li>
<li><span class="math inline">\(\alpha = p/q\)</span> 是有理数：取<span class="math inline">\(k = 0,1,2,\dots,q-1\)</span>的<span class="math inline">\(q\)</span>个值</li>
<li>其他：无穷多个</li>
<li><span class="math inline">\(\mathrm{Ln}z = \ln z\)</span> 时，<span class="math inline">\(z^\alpha = e^{\alpha \ln z}\)</span> 称为（幂函数的）主值</li>
</ul></li>
<li>解析性：除<strong>原点</strong>和<strong>负实轴</strong>外的其他点处解析</li>
</ul>
<h4 id="三角函数">三角函数</h4>
<p><span class="math inline">\(\sin z = \frac{e^{iz}-e^{iz}}{2i},\qquad\cos z = \frac{e^{iz}+e^{-iz}}{2}\)</span></p>
<ul>
<li>以 <span class="math inline">\(2\pi\)</span> 为周期</li>
<li>三角恒等式成立</li>
<li>在复平面上处处解析</li>
<li>没有有界性</li>
<li>复数的欧拉公式 <span class="math inline">\(e^{iz} = \cos z + i\sin z\)</span> 成立</li>
<li><span class="math inline">\(\sin z\)</span> 的零点为 <span class="math inline">\(z= k\pi\)</span> <span class="math inline">\(\cos z\)</span> 的零点为 <span class="math inline">\(z = k\pi + \frac{\pi}{2}\)</span></li>
</ul>
<h4 id="双曲函数">双曲函数</h4>
<p><span class="math inline">\(\sh z=\frac{e^z-e^{-z}}{2},\qquad\ch z=\frac{e^z+e^{-z}}{2}\)</span></p>
<ul>
<li>周期性、奇偶性、解析性</li>
</ul>
<h4 id="反三角函数反双曲函数">反三角函数、反双曲函数</h4>
<p><span class="math display">\[
\begin{cases}
\mathrm{Arccos}~z =-i\mathrm{Ln}(z+\sqrt{z^2-1})\\
\mathrm{Arcsin}~z =-i\mathrm{Ln}(iz+\sqrt{1-z^2})\\
\mathrm{Arch}~z =\mathrm{Ln}(z+\sqrt{z^2+1})\\
\mathrm{Arsh}~z =\mathrm{Ln}(z+\sqrt{z^2-1})\\
\end{cases}
\]</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「复变函数」复变函数积分</title>
    <url>/2020/11/20/study/Math/ComplexFunctions/ch3/</url>
    <content><![CDATA[<p>复变函数的积分</p>
<span id="more"></span>
<h2 id="复变函数的积分">复变函数的积分</h2>
<h3 id="复变函数积分的概念及其计算">复变函数积分的概念及其计算</h3>
<p><strong>Def</strong>（复变函数的积分）同实函数定义：分割求和 <span class="math inline">\(\displaystyle\int_C f(z)\mathrm dz = \lim \limits_{\delta \rightarrow 0}\sum f(\gamma_k)\delta z_k\)</span></p>
<p><strong>Thm</strong>：设 <span class="math inline">\(f(z)\)</span> 是区域 <span class="math inline">\(D\)</span> 内的连续函数，则复变函数 <span class="math inline">\(f(z)\)</span> 沿 <span class="math inline">\(D\)</span> 内简单光滑有向曲线 <span class="math inline">\(C\)</span> 的积分一定存在，且公式 <span class="math inline">\(\int f(z)\mathrm dz=\int u\mathrm dx-v\mathrm dy + i\int v\mathrm dx+u\mathrm dy\)</span> 成立</p>
<p><strong>性质</strong>：</p>
<ul>
<li><span class="math inline">\(\displaystyle\int_Lf\mathrm dz=\int_{L_1}f\mathrm dz+\int_{L_2}f(z)\mathrm dz\)</span></li>
<li>方向性</li>
<li>线性性质</li>
<li>（积分估值不等式）<span class="math inline">\(\displaystyle|\int_Lf\mathrm dz| \le \int_L|f||\mathrm dz|\le MS\)</span></li>
</ul>
<p><strong>计算方法——参数方程法</strong>：</p>
<p><span class="math inline">\(\displaystyle let~z=x(t) + iy(t)\rightarrow \int_Lf\mathrm dz=\int f(z(t)) z&#39;(t)\mathrm dt\)</span></p>
<p>例： <span class="math display">\[\displaystyle\oint_L\frac{1}{(z-z_0)^n}\mathrm dz= \begin{cases}2\pi i,&amp;n=1,\\0,&amp;n\ne 1.\end{cases}\]</span> 其中 <span class="math inline">\(L\)</span> 为圆 利用：<span class="math inline">\(z-z_0=\rho\cdot e^{i\theta}\)</span>，并且注意方向！（<span class="math inline">\(\theta\)</span>的积分方向上）</p>
<h3 id="柯西-古萨基本定理及其推广">柯西-古萨基本定理及其推广</h3>
<p><strong>Thm</strong>（Cauchy 积分定理）若 <span class="math inline">\(f(z) = u(x,y)+iv(x,y)\)</span>在单连通域 <span class="math inline">\(D\)</span> 内解析，<span class="math inline">\(f&#39;\)</span> 连续且<span class="math inline">\(u,v\)</span> 有一节连续偏导数，满足 <span class="math inline">\(C-R\)</span> 方程。则对于任一分段光滑的简单闭曲线 <span class="math inline">\(L_ 1\)</span> 有</p>
<p><span class="math display">\[
\displaystyle \int _ {L _ 1} f(z)\mathrm dz = 0
\]</span></p>
<p><strong>Thm</strong>：若 <span class="math inline">\(f\)</span> 在单连通区域 <span class="math inline">\(B\)</span> 内处处解析，那么 <span class="math inline">\(f\)</span> 沿着任何 <span class="math inline">\(B\)</span> 内的闭曲线的积分等于 0</p>
<p><strong>Thm</strong>：<span class="math inline">\(f(z)\)</span> 在单连通域 <span class="math inline">\(D\)</span> 内解析，<span class="math inline">\(f&#39;\)</span> 在 <span class="math inline">\(D\)</span> 内连续时，复积分 <span class="math inline">\(\displaystyle \int _Lf(z)\mathrm dz\)</span> 与路径无关</p>
<!-- **Thm**（柯西-古萨基本定理）设 $f(z)$ 在简单闭曲线 $L$ 上以及它所围的区域 $D$ 内解析，则$\displaystyle \int _{L} f(z)\mathrm dz = 0$ -->
<h4 id="复合闭路定理">复合闭路定理</h4>
<p><strong>Thm</strong>：设 <span class="math inline">\(f(z)\)</span> 在单连通域 <span class="math inline">\(D\)</span> 内解析，对于 <span class="math inline">\(D\)</span> 内任一分段光滑的闭曲线 <span class="math inline">\(L _ 1\)</span>：<span class="math inline">\(\displaystyle\int _{L_1} f(z)\mathrm dz = 0\)</span></p>
<p><strong>Thm</strong>（复合闭路定理）设 <span class="math inline">\(L, L_k\)</span> 为n+1条取逆时针方向的简单闭曲线，<span class="math inline">\(L_k\)</span> 互不相交，互不包含，<span class="math inline">\(L, L_k\)</span> 围成复连通域<span class="math inline">\(D\)</span>，<span class="math inline">\(f(z)\)</span> 在<span class="math inline">\(\bar D\)</span> 上解析，则： <span class="math display">\[\displaystyle\oint_Lf(z)\mathrm dz = \sum_{k=1}^n\oint_{L_k}f(z) \mathrm dz\]</span></p>
<blockquote>
<p>注意曲线的性质：简单闭曲线、闭曲线</p>
</blockquote>
<h5 id="例">例</h5>
<p><span class="math display">\[\displaystyle\oint_L\frac{1}{(z-z_0)^n}\mathrm dz= \begin{cases}2\pi i,&amp;n=1,\\0,&amp;n\ne 1.\end{cases}\]</span></p>
<p>其中 <span class="math inline">\(L\)</span> 为圆</p>
<blockquote>
<p>利用：<span class="math inline">\(z-z_0=\rho\cdot e^{i\theta}\)</span>，并且注意方向！（<span class="math inline">\(\theta\)</span>的积分方向）</p>
</blockquote>
<p>利用复合闭路定理：<span class="math inline">\(L\)</span> 可以为任意包含<span class="math inline">\(z_0\)</span>的闭曲线。</p>
<p><strong>Thm</strong>：闭路变形定理</p>
<p>重要结论：</p>
<p><span class="math display">\[
\oint_L\frac{1}{(z-z_0)^n}\mathrm dz= \begin{cases}2\pi i,&amp;n=1,\\0,&amp;n\ne 1,n\in \mathrm Z.\end{cases}
\]</span></p>
<h3 id="原函数与不定积分">原函数与不定积分</h3>
<p><strong>Thm</strong>：设 <span class="math inline">\(f(z)\)</span> 在单连通域 <span class="math inline">\(D\)</span> 内解析，则复函数 <span class="math inline">\(F(z)=\int_{z_0}^zf(z)\mathrm dz\)</span> 在 <span class="math inline">\(D\)</span> 内解析，且 <span class="math inline">\(F&#39;=f\)</span></p>
<p><strong>Def</strong>（原函数）若存在<span class="math inline">\(\Phi(z),\forall z\in D,\Phi &#39;(z)=f(z)\)</span> 称 <span class="math inline">\(\Phi(z)\)</span> 为 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(D\)</span> 内的一个原函数</p>
<p><strong>性质</strong>：</p>
<p>单连通域 <span class="math inline">\(D\)</span> 内的解析函数存在原函数</p>
<p>表示全体原函数的表达式：<span class="math inline">\(\int f(z)\mathrm dz\)</span>称为<span class="math inline">\(f\)</span>的不定积分</p>
<p><strong>Thm</strong>：对于解析函数 <span class="math inline">\(f\)</span>，<span class="math inline">\(\Phi(z)\)</span> 是其原函数，则<span class="math inline">\(\int_{z_1}^{z_2}=\Phi(z_2)-\Phi(z_1)\)</span></p>
<h3 id="柯西积分公式高阶导数公式">柯西积分公式、高阶导数公式</h3>
<p><strong>Thm</strong>（Cauchy积分公式）<span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(D\)</span> 和 <span class="math inline">\(D\)</span> 的边界上解析，则 <span class="math inline">\(\forall z\in D, f(z) = \frac{1}{2\pi i}\oint_L\frac{f(\varsigma)}{\varsigma - z}\mathrm d \varsigma\)</span></p>
<p><strong>Thm</strong>（解析函数的平均值公式）<span class="math inline">\(\displaystyle L:|z-z_0|=R\Rightarrow f(z_0) = \frac{1}{2\pi}\int_0^{2\pi}f(z_0+Re^{i\theta})\mathrm d\theta\)</span></p>
<p><strong>Thm</strong>（高阶导数公式）设 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 及其边界上解析，则<span class="math inline">\(f\)</span>在D内有任意阶导数，且<span class="math inline">\(\forall z\in D\)</span>,<span class="math inline">\(\displaystyle f^{(n)}(z) = \frac{n!}{2\pi i}\oint_L\frac{f(\varsigma)}{(\varsigma-z)^{n+1}}\mathrm d\varsigma\)</span></p>
<h4 id="不等式">不等式</h4>
<p><strong>Thm</strong>（柯西不等式）设 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 内解析，<span class="math inline">\(z_0\in D\)</span>，圆周 <span class="math inline">\(K_R\)</span> 及其内部均含于 <span class="math inline">\(D\)</span>，则<span class="math inline">\(|f^{(n)}(z_0)|\le \frac{n! M(R)}{R^n}\)</span>，<span class="math inline">\(M(R) = \max_{|z-z_0|=R}|f(z)|\)</span></p>
<p><strong>Thm</strong>（柳维尔定理）<span class="math inline">\(f(z)\)</span> 在整个复平面上解析且有界，则 <span class="math inline">\(f(z)\)</span> 在复平面上恒为常数。</p>
<p><strong>Thm</strong>（莫雷拉定理）<span class="math inline">\(f(z)\)</span> 在单连通区域 <span class="math inline">\(D\)</span> 内解析且有界，且对于任一简单闭曲线<span class="math inline">\(L\)</span>上：<span class="math inline">\(\int_Lf(z)\mathrm dz =0\)</span>，则<span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(D\)</span> 内解析。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「复变函数」复数项级数的概念和性质</title>
    <url>/2021/01/11/study/Math/ComplexFunctions/ch4/</url>
    <content><![CDATA[<p>复数项级数的概念和性质 <span id="more"></span></p>
<h2 id="复数项级数的概念和性质">复数项级数的概念和性质</h2>
<h3 id="复数项级数">复数项级数</h3>
<p><strong>Def</strong>：无穷复数列 <span class="math inline">\(\{c_n\}\rightarrow_{n\rightarrow \infty} A \iff \forall \varepsilon&gt;0,\exist N,n&gt;N\rightarrow |c_n-A|&lt;\varepsilon\)</span></p>
<p><strong>Thm</strong>（判别法则）<span class="math inline">\(c_n=a_n+ib_n\)</span> 收敛于 <span class="math inline">\(a+bi~\iff~a_n\rightarrow a, b_n\rightarrow b\)</span></p>
<p><strong>Def</strong>（复数项级数）<span class="math inline">\(\sum_{n=1}^\infty c_n\)</span>，通项 <span class="math inline">\(c_n\)</span>。</p>
<p><strong>Def</strong>（前 n 项之和）<span class="math inline">\(\sum_{k=1}^n c_k\)</span></p>
<p><strong>Thm</strong>：（必要条件）级数 <span class="math inline">\(\sum c_n\)</span> 收敛，则 <span class="math inline">\(\lim_{n\rightarrow \infty} c_n=0\)</span></p>
<p><strong>Thm</strong>：（柯西收敛准则）<span class="math inline">\(\sum c_n\)</span> 收敛 <span class="math inline">\(\iff \forall \varepsilon&gt;0,\exist N,\forall p\in N_+, n&gt;N\rightarrow|S_{n+p} - S_n|\le \varepsilon\)</span></p>
<h4 id="按模收敛">按模收敛</h4>
<p><strong>Def</strong>（按模收敛）<span class="math inline">\(\sum |c_n|\)</span></p>
<p><strong>Thm</strong>（绝对收敛准则）当 <span class="math inline">\(\sum |c_n|\)</span> 收敛时，<span class="math inline">\(\sum c_n\)</span> 收敛</p>
<p><strong>Def</strong>（条件收敛）<span class="math inline">\(\sum |c_n|\)</span> 不收敛，<span class="math inline">\(\sum c_n\)</span> 收敛</p>
<p><strong>性质</strong>：</p>
<ul>
<li><span class="math inline">\(\sum c_n=s\)</span>，<span class="math inline">\(k\)</span>为任意常数，则<span class="math inline">\(\sum kc_n=k\sum c_n\)</span></li>
<li>线性性质</li>
<li>去掉或加上有限项不改变级数的敛散性。</li>
<li>收敛级数添加括号或改变次序不改变敛散性
<ul>
<li>逆命题不成立</li>
</ul></li>
</ul>
<h3 id="幂级数">幂级数</h3>
<h4 id="函数项级数">函数项级数</h4>
<p>若存在<span class="math inline">\(\sum u_n(z_0)\)</span> 收敛，则称<span class="math inline">\(z_0\)</span> 为收敛点；收敛点的全体为收敛域 <span class="math inline">\(D\)</span>。</p>
<p>对于任一 <span class="math inline">\(z\in D\)</span>，有一个确定的和 <span class="math inline">\(S(z)\)</span> 称为和函数。</p>
<p>如等比级数：<span class="math inline">\(\sum z_n\)</span> 当 <span class="math inline">\(|z|&lt;1\)</span> 时，<span class="math inline">\(|z|=1,~\theta = 2k\pi\)</span> 时收敛，其他情况下发散。</p>
<h4 id="幂级数的收敛性">幂级数的收敛性</h4>
<p><strong>Def</strong>（<span class="math inline">\((z-z_0)\)</span> 的幂级数）<span class="math inline">\(\sum c_i(z-z_0)^i\)</span></p>
<p><strong>Thm</strong>（Abel 定理）</p>
<ul>
<li>若<span class="math inline">\(\sum c_i(z-z_0)^i\)</span> 在 <span class="math inline">\(z=z_0\ne 0\)</span> 收敛，则对<span class="math inline">\(\forall |z|&lt; |z_0|\)</span> 绝对收敛</li>
<li>若<span class="math inline">\(\sum c_i(z-z_0)^i\)</span> 在 <span class="math inline">\(z=z_0\ne 0\)</span> 发散，则对<span class="math inline">\(\forall |z|&gt; |z_0|\)</span> 发散</li>
</ul>
<p><strong>Thm</strong>：若<span class="math inline">\(\lim |c_{n+1}/c_n|=\lambda \ne 0\)</span> or <span class="math inline">\(\lim |c_n|^{1/n}=\lambda \ne 0\)</span> 则 <span class="math inline">\(R=1/\lambda\)</span></p>
<p><strong>性质</strong>：</p>
<ol type="1">
<li>代数运算（线性性质）</li>
<li>柯西乘积</li>
</ol>
<h4 id="幂级数的收敛圆和收敛半径">幂级数的收敛圆和收敛半径</h4>
<p>仅有三种情况：</p>
<ol type="1">
<li>在 <span class="math inline">\(z=0\)</span> 收敛</li>
<li>在圆域内收敛</li>
<li>在复平面内收敛</li>
</ol>
<h5 id="求法">求法</h5>
<p><strong>Thm</strong>：若：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\lim_{n\rightarrow \infty}\left|\frac{c_{n+1}}{c_n}\right|=\lambda\ne 0\\
&amp;\quad or\\
&amp;\lim_{n\rightarrow \infty}\sqrt[n]{|c_n|}=\lambda\ne 0
\end{aligned}
\]</span></p>
<p>则其收敛半径为<span class="math inline">\(\displaystyle R=\frac{1}{\lambda}\)</span></p>
<p><strong>Thm</strong>：设<span class="math inline">\(\sum c_nz^n\)</span>的收敛半径为 <span class="math inline">\(R&gt;0\)</span> 和函数为 <span class="math inline">\(S(z)\)</span> 则：</p>
<ol type="1">
<li>和函数在 <span class="math inline">\(|z|&lt;R\)</span> 解析</li>
<li><span class="math inline">\(S(z)\)</span> 可以逐项求导、逐项积分</li>
</ol>
<h3 id="taylor-级数">Taylor 级数</h3>
<p><strong>Def</strong>（展开为幂级数）若 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(z_0\)</span> 邻域内有任意阶导数，则<span class="math inline">\(\sum \frac{f^{(n)}(z_0)}{n!}(z-z_0)^n\)</span> 为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(z_0\)</span> 的 Taylor 级数，当 <span class="math inline">\(z_0=0\)</span> 时，为麦克劳林级数。</p>
<p><strong>Thm</strong>：<span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 内解析，<span class="math inline">\(z_0\in D\)</span> 则当 <span class="math inline">\(|z-z_0|&lt;R\)</span> 时，<span class="math inline">\(f(z)\)</span> 都可以唯一的展开为 <span class="math inline">\(z-z_0\)</span> 的幂级数。（<span class="math inline">\(R\)</span> 为 <span class="math inline">\(x_0\)</span> 到边界的最小距离）</p>
<p><strong>Thm</strong>：<span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 内解析，<span class="math inline">\(z_0\in D\)</span>，<span class="math inline">\(d\)</span>为到边界上各个点的最短距离，当 <span class="math inline">\(|z-z_0|&lt;d\)</span> 时，<span class="math inline">\(f(z)\)</span> 可以唯一的展开为幂级数</p>
<p><em>Inference</em>：<span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 内解析，<span class="math inline">\(z_0\in D\)</span>，<span class="math inline">\(\alpha\)</span> 为距离 <span class="math inline">\(z _ 0\)</span> 最近的一个奇点，则使得展开成立的 <span class="math inline">\(R=|\alpha-z_0|\)</span></p>
<h3 id="洛朗级数">洛朗级数</h3>
<h4 id="解析函数的洛朗展开定理">解析函数的洛朗展开定理</h4>
<p><strong>Def</strong>（双边幂级数）<span class="math inline">\(\sum_{-\infty}^{\infty}c_n(z-z_0)^n\)</span> （其在收敛圆环域<span class="math inline">\(R_1&lt;|z-z_0|&lt;R_2\)</span> 内解析）</p>
<p><strong>Thm</strong>：<span class="math inline">\(f(z)\)</span> 在圆环域内解析，则在圆域内 <span class="math inline">\(f(z)\)</span> 可以唯一的表示为双边幂级数 <span class="math inline">\(f(z)=\sum_{-\infty}^{\infty}c_n(z-z_0)^n\)</span></p>
<p>其中：<span class="math inline">\(\displaystyle c_n=\frac{1}{2\pi i}\int\frac{f(z)}{(z-z_0)^{n+1}}\mathrm dz \quad(n=0,\pm 1, \pm 2,...)\)</span></p>
<p><strong>求展开的方法</strong>：</p>
<ol type="1">
<li>直接展开法</li>
<li>简介展开法</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「复变函数」留数及其应用</title>
    <url>/2021/01/11/study/Math/ComplexFunctions/ch5/</url>
    <content><![CDATA[<p>留数及其应用</p>
<span id="more"></span>
<h2 id="留数及其应用">留数及其应用</h2>
<h3 id="孤立奇点">孤立奇点</h3>
<p><strong>Def</strong>（孤立奇点）<span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(z_0\)</span> 不解析，在其某个去心邻域内解析，则称<span class="math inline">\(z_0\)</span>为 <span class="math inline">\(f(z)\)</span> 的孤立奇点</p>
<p><strong>可去奇点</strong>：Laurent 级数不含有负幂项 -&gt; 令 <span class="math inline">\(f(z_0)=c_0\)</span></p>
<ul>
<li>只需要重新定义 <span class="math inline">\(f(z_0)=c_0\)</span> 就可以解析，例如 <span class="math inline">\((e^z-1) / z,\quad z=0\)</span></li>
</ul>
<p><strong>（m 阶）极点</strong>：负幂项只有有限个。</p>
<ul>
<li><span class="math inline">\(\lim_{z\rightarrow z_0} f(z)=\infin\)</span></li>
</ul>
<p><strong>本性奇点</strong>：负幂项有无穷多项。</p>
<p><strong>Thm</strong>：设函数 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(0&lt;|z-z_0|&lt;\delta\)</span> 内解析，若 <span class="math inline">\(z_0\)</span> 为本性奇点，则 <span class="math inline">\(\forall a,\exists\{z_n\},\lim_{z_n\rightarrow z_0}f(z_0) = a\)</span></p>
<h4 id="零点和极点的关系">零点和极点的关系</h4>
<p><strong>Def</strong>（零点）<span class="math inline">\(f(z_0)=0\)</span> 则称 <span class="math inline">\(z_0\)</span> 为 <span class="math inline">\(f(z_0)\)</span> 的零点</p>
<p><strong>Def</strong>（m 级零点）若 <span class="math inline">\(f(z)=(z-_0)^m\varphi(z)\)</span> 在 <span class="math inline">\(z_0\)</span> 处解析，且 <span class="math inline">\(\varphi(z)\)</span> 在 <span class="math inline">\(z_0\)</span> 处解析 <span class="math inline">\(\varphi(z_0)\ne0\)</span> 则称 <span class="math inline">\(z_0\)</span> 为 <span class="math inline">\(f(z)\)</span> 的 m 级零点</p>
<p><strong>Thm</strong>：若 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(z_0\)</span> 解析，则： <span class="math inline">\(z_0\)</span> 为 m 阶零点 <span class="math inline">\(\iff f^{(n)}(z_0)=0, (n &lt; m)~,f^{(m)}\ne 0\)</span></p>
<p><strong>Thm</strong>：若 <span class="math inline">\(z_0\)</span> 是 <span class="math inline">\(f(z)\)</span> 的 m 阶极点 <span class="math inline">\(\iff\)</span> <span class="math inline">\(z_0\)</span> 是 <span class="math inline">\(1/f(z)\)</span> 的 m 阶零点。</p>
<p><strong>Thm</strong>：若 <span class="math inline">\(z_0\)</span> 为 <span class="math inline">\(f,g\)</span> 的 <span class="math inline">\(m, n (m&lt;n)\)</span> 级零点，则 <span class="math inline">\(z_0\)</span> 为 <span class="math inline">\(f(z)/g(z)\)</span> 的 <span class="math inline">\(m - n\)</span> 阶零点，为 <span class="math inline">\(f(z)g(z)\)</span> 的 <span class="math inline">\(m+n\)</span> 阶零点。</p>
<h4 id="在无穷远点的形态">在无穷远点的形态</h4>
<p><strong>Def</strong>：若 <span class="math inline">\(f(z)\)</span> 在无穷远点<span class="math inline">\(z=\infin\)</span> 的去心邻域 <span class="math inline">\(U(\infty)=\{z|0&lt;R&lt;|z|&lt;\infty\}\)</span> 内解析，则称 <span class="math inline">\(\infin\)</span> 为 f 的孤立奇点。</p>
<p><strong>Def</strong>：若 <span class="math inline">\(t=0\)</span> 是 <span class="math inline">\(\displaystyle\varphi(t)=f(\frac 1 t)\)</span> 的可去奇点，m 级极点，本性极点，则 <span class="math inline">\(t=\infin\)</span> 是 <span class="math inline">\(f(z)\)</span> 的可去奇点，m 级极点，本性极点。</p>
<h3 id="留数和留数定理">留数和留数定理</h3>
<p><strong>Def</strong>（留数）设<span class="math inline">\(z_0\)</span>为 <span class="math inline">\(f(z)\)</span> 的有限孤立奇点，我们把 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(z_0\)</span> 的去心邻域内的洛朗级数展开式两端逐项积分留下的积分值除以 <span class="math inline">\(2\pi i\)</span> 后得到的数称为 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(z_0\)</span> 的留数：<span class="math inline">\(\mathrm{Res}[f(z),z_0]=\frac{1}{2\pi i}\oint f(z) dz=c_{-1}\)</span></p>
<p><strong>Def</strong>（无穷远处的留数）<span class="math inline">\(Res[f(z),+\infin]=\frac{1}{2\pi i}\oint_{L-}f(z)=-C_{-1}\)</span>（f 在圆环域 <span class="math inline">\(0&lt;R&lt;|z|&lt;\infin\)</span> 解析）</p>
<p><em>留数计算方法</em>：</p>
<ol type="1">
<li>若 <span class="math inline">\(z_0\)</span> 为可去奇点：<span class="math inline">\(Res[f,z_0]=c_{-1}=0\)</span></li>
<li>1 级极点：<span class="math inline">\(Res[f,z_0]=\lim_{z\rightarrow z_0}(z-z_0)f(z)\)</span></li>
<li>m 级极点：<span class="math inline">\(Res[f,z_0]=\frac{1}{(m-1)!}]\lim_{z-z_0}\frac{\mathrm d^{m-1}}{\mathrm dz^{m-1}}[(z-z_0)^mf(z)]\)</span></li>
<li>若 <span class="math inline">\(f(z)=P(z)/Q(z)\)</span>，<span class="math inline">\(P,Q\)</span> 解析，且 <span class="math inline">\(P(z_0)\ne 0,~Q(z_0) = 0,~Q&#39;(z_0)\ne 0\)</span> 则 <span class="math inline">\(\displaystyle Res=\frac{P(z_0)}{Q&#39;(z_0)}\)</span></li>
<li><span class="math inline">\(\displaystyle Res[f(z),\infty]=-Res[-\frac{1}{z^2}f(\frac{1}{z}),0 ]\)</span></li>
</ol>
<p><strong>Thm</strong>（留数定理）设函数 <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(D\)</span> 内除了有限个孤立奇点外处处解析，<span class="math inline">\(L\)</span>是<span class="math inline">\(D\)</span> 内的一个逆时针的简单闭曲线，则<span class="math inline">\(\displaystyle\oint f(z)\mathrm dz =2\pi i\sum_{k=1}^m\mathrm{Res}[f(z),z_k]\)</span></p>
<p><strong>Thm</strong>：若函数<span class="math inline">\(f(z)\)</span> 在扩充复平面内处有限个孤立奇点外解析，则 <span class="math inline">\(f(z)\)</span> 在各个极点的留数和为 0：<span class="math inline">\(\displaystyle\mathrm{Res}[f(z),+\infin]+\sum\mathrm{Res}[f(z),z_k]=0\)</span></p>
<h3 id="利用留数计算某些实积分">利用留数计算某些实积分</h3>
<h4 id="rcos-θ-sin-θ-dθ">∫R(cos θ, sin θ) dθ</h4>
<p>设 <span class="math inline">\(z=e^{i\theta}\)</span> 则：</p>
<p><span class="math display">\[
\oint_{0}^{2\pi}R(\cos \theta,\sin\theta)\mathrm d\theta=\oint_{|z|=1}\frac{1}{iz}R(\frac{z+z^{-1}}{2},\frac{z-z^{-1}}{2i})\mathrm dz
\]</span></p>
<h4 id="rx-dx">∫R(x) dx</h4>
<p>其中</p>
<p><span class="math display">\[
R(x)=\frac{P_m(x)}{Q_n(x)}=\frac{a_0+a_1x+\cdots+a_mx^m}{b_0+b_1x+\cdots+b_nx^n}
\]</span></p>
<p>满足：</p>
<ul>
<li><span class="math inline">\(n-m\ge2\)</span></li>
<li>在实轴上<span class="math inline">\(Q_n(z)\ne 0\)</span></li>
</ul>
<p>则：</p>
<p><span class="math display">\[
\int_{-\infty}^{\infty}R(x)\mathrm dx =2\pi i\sum Res[R(z),z_k]
\]</span></p>
<p>其中 <span class="math inline">\(z_k\)</span> 为上半平面内所有奇点</p>
<h4 id="rx-expiax-dx">∫ R(x) · exp(i·a·x) dx</h4>
<p><span class="math display">\[
R=P(x)/Q(x)
\]</span></p>
<p>其中 <span class="math inline">\(m-n\ge 1,Q(x)\ne 0\)</span></p>
<p>则：</p>
<p><span class="math display">\[
\int_{-\infty}^{\infty}R(x)e^{iax}\mathrm dx = 2\pi i\sum Res(R(z)e^{iax},z_k)
\]</span></p>
<p>其中 <span class="math inline">\(z_k\)</span> 为上半平面内所有奇点</p>
<p>也就是： <span class="math display">\[
\int_{-\infty}^{\infty}R(x)\cos ax\mathrm dx+i\int_{-\infty}^{\infty}R(x)\sin ax\mathrm dx = 2\pi i\sum Res(R(z)e^{iax},z_k)
\]</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「复变函数」共形映射</title>
    <url>/2021/01/11/study/Math/ComplexFunctions/ch6/</url>
    <content><![CDATA[<p>:no_mouth:</p>
<span id="more"></span>
<h2 id="共形映射">共形映射</h2>
<h3 id="共形映射的概念">共形映射的概念</h3>
<h4 id="解析函数导数的几何意义">解析函数导数的几何意义</h4>
<p>复平面上有向曲线的切向量：<span class="math inline">\(z=z(t)\)</span> 的切向量为 <span class="math inline">\(z&#39;(t)\)</span></p>
<p><strong>导数幅角的几何意义</strong>：表示曲线 <span class="math inline">\(C\)</span> 经过 <span class="math inline">\(w=f(z)\)</span> 后在 <span class="math inline">\(z_0\)</span> 的转动角，且大小和方向仅与 <span class="math inline">\(z_0\)</span> 有关，而与 <span class="math inline">\(C\)</span> 无关。</p>
<p><em>旋转角的不变性</em>：</p>
<p>函数 <span class="math inline">\(w=f(z)\)</span> 在 D 内解析，且 <span class="math inline">\(f&#39;\ne0\)</span> 则曲线 <span class="math inline">\(L\)</span> 的象曲线方程为：</p>
<p><span class="math inline">\(\Gamma:w=f(z(t)),~t\in[\alpha,\beta]\)</span>，<span class="math inline">\(\Gamma\)</span> 在 <span class="math inline">\(w=w(t_0)\)</span> 的邻域内光滑，且：</p>
<p><span class="math inline">\(w&#39;(t_0)=f&#39;(z)z&#39;(t_0)\ne 0\)</span> 则<span class="math inline">\(\Gamma\)</span> 在<span class="math inline">\(w_0=f(z_0)\)</span> 的切向量为 <span class="math inline">\(w&#39;(t_0)\)</span></p>
<p>则：<span class="math inline">\(Arg~w&#39;(t_0)=Arg~f&#39;(z_0)+Arg~z&#39;(t_0)\)</span></p>
<p><strong>导数模的几何意义</strong>：经过映射后 <span class="math inline">\(z_0\)</span> 的任何曲线在 <span class="math inline">\(z_0\)</span> 的<strong>伸缩率</strong>。<span class="math inline">\(|f&#39;(z_0)|=\lim_{z\rightarrow z_0} \left|\frac{w-w_0}{z-z_0}\right|\)</span></p>
<p><em>伸缩率不变性</em>：解析函数，伸缩率与曲线 <span class="math inline">\(C\)</span> 无关，具有伸缩率不变性。</p>
<p><strong>Thm</strong>：设函数 <span class="math inline">\(f\)</span> 在 D 内解析，且 <span class="math inline">\(z_0\in D,~f&#39;(z_0)\ne 0\)</span> 则该映射在该点处有保角性和伸缩率不变性</p>
<h4 id="共形映射的概念和单叶解析函数的共形性">共形映射的概念和单叶解析函数的共形性</h4>
<p><strong>Def</strong>（保角）</p>
<ul>
<li>函数在某一点处具有保角性和伸缩率不变性 <span class="math inline">\(\implies\)</span> <strong>保角的</strong></li>
<li>函数在 <span class="math inline">\(D\)</span> 内每一点处都是<strong>保角的</strong> <span class="math inline">\(\implies\)</span> <strong>保角映射</strong></li>
<li><span class="math inline">\(D\)</span>内的单叶、保角映射 <span class="math inline">\(\implies\)</span> 共形映射</li>
</ul>
<p><strong>Thm</strong>：<span class="math inline">\(f\)</span> 为 <span class="math inline">\(D\)</span> 内的解析函数，<span class="math inline">\(z_0\in D\)</span> 若 <span class="math inline">\(f&#39;\ne 0\)</span> 则在<span class="math inline">\(z_0\)</span>是保角的。若对任何 <span class="math inline">\(z\in D\)</span> 都有 <span class="math inline">\(f&#39;\ne 0\)</span> 则为保角映射</p>
<p><strong>Thm</strong>：<span class="math inline">\(w=f(z)\)</span> 是 <span class="math inline">\(D\)</span> 内的单叶映射，则它将 <span class="math inline">\(z\)</span> 平面上的区域 <span class="math inline">\(D\)</span> 共形映射为 <span class="math inline">\(w\)</span> 平面上的区域 <span class="math inline">\(G=f(D)\)</span> 它的反函数 <span class="math inline">\(z=f^{-1}(w)\)</span> 在 <span class="math inline">\(G\)</span> 内单叶解析，且：<span class="math inline">\([f^{-1}(w)]&#39;=\frac{1}{f&#39;(z)}\)</span></p>
<div class="note"><p>primary</p></div>
<h3 id="review">review</h3>
<p>伸缩率：<span class="math inline">\(\|f&#39;\|\)</span></p>
<p>旋转角：<span class="math inline">\(Arg~f&#39;\)</span></p>
<p>解析 &amp; f‘≠ 0 =&gt; 保角性</p>
<!-- TODO: endnote-->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>无穷级数</title>
    <url>/2020/05/25/study/Math/Advanced-Mathematics/ConstantSeries/</url>
    <content><![CDATA[<p>级数部分相关定理。</p>
<span id="more"></span>
<h2 id="常数项级数">常数项级数</h2>
<h3 id="常数项级数的概念性质原理">常数项级数的概念、性质、原理</h3>
<p><strong>Def</strong>：（级数）我们把一个形如 <span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 的式子称为无穷级数</p>
<p><strong>Def</strong>：级数的部分和、级数的敛散性、级数和的定义</p>
<p><strong>Thm</strong>：性质，若 <span class="math inline">\(a_n\)</span> 和 <span class="math inline">\(b_n\)</span> 级数收敛，则</p>
<ul>
<li>线性性质</li>
<li><span class="math inline">\(\sum\limits_{k=0}^{\infty}(a_k+b_k) =\sum\limits_{k=0}^{\infty} a_k+ \sum\limits_{k=0}^{\infty}b_k\)</span></li>
<li>若 <span class="math inline">\(a_n\le b_n\)</span> 则 <span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\le\sum\limits_{k=0}^{\infty}b_n\)</span></li>
<li>任意更改有限项不改变敛散性</li>
<li>在不改变次序的情况下，任意添加括号所得到的新的级数敛散性不变，和不变</li>
</ul>
<p><strong>Thm</strong>：（Cauchy 收敛原理）级数<span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 收敛的充要条件是 <span class="math inline">\(\forall\varepsilon&gt;0,\exists N\in \mathbf{N}_+\forall p\in \mathbf{N}_+(n&gt;N \rightarrow |\sum\limits_{k=n+1}^{n+p}a_k|&lt;\varepsilon)\)</span></p>
<h3 id="正项级数的审敛准则">正项级数的审敛准则</h3>
<p><strong>Thm</strong>：正项级数<span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 收敛的充要条件是其部分和数列 <span class="math inline">\(\{S_n\}\)</span> 有上界</p>
<p><strong>Thm</strong>：（比较准则 1 ）设<span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 和 <span class="math inline">\(\sum\limits_{k=0}^{\infty}b_n\)</span> 是正项级数，且 <span class="math inline">\(\forall n\in \mathbf N_+,a_n\le b_n\)</span>，则</p>
<ol type="1">
<li><span class="math inline">\(\sum\limits_{k=0}^{\infty}b_n\)</span> 收敛，则 <span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 收敛</li>
<li><span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 发散，则 <span class="math inline">\(\sum\limits_{k=0}^{\infty}b_n\)</span> 发散</li>
</ol>
<p><strong>Thm</strong>：（比较准则 2 极限形式）设<span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 和 <span class="math inline">\(\sum\limits_{k=0}^{\infty}b_n\)</span> 是正项级数，且有<span class="math inline">\(\lim \frac{a_n}{b_n} =\lambda\)</span> 则：</p>
<ol type="1">
<li><span class="math inline">\(\lambda&gt;0\)</span> 则两个级数有相同的敛散性</li>
<li><span class="math inline">\(\lambda = 0\)</span> 若 <span class="math inline">\(\sum\limits_{k=0}^{\infty}b_n\)</span> 收敛，则 <span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 收敛</li>
<li><span class="math inline">\(\lambda = \infty\)</span> 若 <span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 发散，则 <span class="math inline">\(\sum\limits_{k=0}^{\infty}b_n\)</span> 发散</li>
</ol>
<p><strong>Thm</strong>：（达朗贝尔判别法、D'Alembert 准则）若正项级数<span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 满足 <span class="math inline">\(\lim\limits_{n\rightarrow \infty} \frac{u_{n+1}}{u_n} = l\)</span> 则</p>
<ol type="1">
<li><span class="math inline">\(l&lt;1\)</span>，收敛</li>
<li><span class="math inline">\(l&gt;1\)</span>，发散</li>
<li><span class="math inline">\(l=1\)</span>，敛散性不定</li>
</ol>
<p><strong>Thm</strong>：（柯西判别法、Cauchy 准则）若正项级数<span class="math inline">\(\sum\limits_{k=0}^{\infty}a_n\)</span> 满足 <span class="math inline">\(\lim\limits_{n\rightarrow \infty} \sqrt[n]{a_n} = \lambda\)</span> 则</p>
<ol type="1">
<li><span class="math inline">\(\lambda&lt;1\)</span>，收敛</li>
<li><span class="math inline">\(\lambda&gt;1\)</span>，发散</li>
<li><span class="math inline">\(\lambda=1\)</span>，敛散性不定</li>
</ol>
<p>*<strong>Thm</strong>：（拉阿伯判别法）若正项级数满足：<span class="math inline">\(\lim\limits_{n\rightarrow \infty} n(\frac{u_n}{u_{n+1}} -1)=R\)</span> 则</p>
<ol type="1">
<li><span class="math inline">\(R&gt;1\)</span>，收敛</li>
<li><span class="math inline">\(R&lt;1\)</span>，发散</li>
<li><span class="math inline">\(R=1\)</span>，敛散性不定</li>
</ol>
<blockquote>
<p>例：讨论 <span class="math inline">\(\displaystyle\sum\limits_{k=0}^{\infty}\frac{(2n-1)!!}{2n!!}\cdot\frac{1}{2n+1}\)</span> 的敛散性</p>
<p>解：应用拉阿伯判别法 <span class="math inline">\(R = \frac 3 2\)</span> 故级数收敛</p>
</blockquote>
<p><strong>Thm</strong>：（积分判别准则）若存在一个单调下降的非负函数 <span class="math inline">\(f(x)\)</span> 使得 <span class="math inline">\(f(n) = u_n\)</span>，则无穷积分与无穷级数有相同的敛散性</p>
<h3 id="任意项级数">任意项级数</h3>
<p><strong>Def</strong>：交错级数 <span class="math inline">\(\sum\limits_{k=0}^{\infty}(-1)^n\cdot a_n\)</span></p>
<p><strong>Thm</strong>：（Leibniz 准则）若交错级数满足</p>
<ol type="1">
<li><span class="math inline">\(u_n\ge u_{n+1}\)</span></li>
<li><span class="math inline">\(\lim\limits_{n\rightarrow \infty} u_n = 0\)</span></li>
</ol>
<p>则该交错级数收敛</p>
<p><strong>Def</strong>：绝对收敛，条件收敛</p>
<p><strong>Thm</strong>：（绝对收敛准则）若级数 <span class="math inline">\(\sum\limits_{n=1}^{\infty} |a_n|\)</span> 收敛，则级数 <span class="math inline">\(\sum\limits_{n=1}^{\infty} a_n\)</span> 收敛</p>
<p><strong>Thm</strong>：若级数绝对收敛，则其的任何一个重排绝对收敛，且和相等</p>
<p><strong>Thm</strong>：若级数 <span class="math inline">\(\sum\limits_{n=1}^{\infty} a_n = A\)</span> 和 <span class="math inline">\(\sum\limits_{n=1}^{\infty} b_n = B\)</span> 绝对收敛，则各项相乘得到的乘积项按任何次序排列得到的级数 <span class="math inline">\(\sum\limits_{n=1}^{\infty} c_n\)</span> 绝对收敛于 <span class="math inline">\(AB\)</span></p>
<p><strong>Lemma</strong>：（Abel 变换式）<span class="math inline">\(\sum\limits_{k =1}^{m}\alpha_k\beta_k = \sum\limits_{k=1}^{m-1}(\alpha_k-\alpha_k+1)B_k +a_mB_m\)</span></p>
<p><strong>Lemma</strong>：（Abel 引理）若数组<span class="math inline">\(\{\alpha_k\}\)</span> 是单调的，又有数组 <span class="math inline">\(\{\beta_k\}\)</span> 的部分和为 <span class="math inline">\(B_n\)</span> 满足不等式 <span class="math inline">\(|B_n| = |\sum\limits_{k=1}^{n}\beta_k|\le M\)</span>，则有 <span class="math inline">\(\sum\limits_{k=1}^m \alpha_k\beta_k\le M(|\alpha_1|+2|\alpha_m|)\)</span></p>
<p><strong>Thm</strong>：（狄利克雷判别法）若 <span class="math inline">\(\{a_n\}\)</span> 单调且 <span class="math inline">\(\lim\limits_{k\rightarrow\infty} a_k=0\)</span> 级数 <span class="math inline">\(\sum\limits_{k=1}^\infty b_k\)</span> 部分和序列有界，则级数 <span class="math inline">\(\sum\limits_{k=1}^\infty a_kb_k\)</span> 收敛</p>
<p><strong>Thm</strong>：（Abel 判别法）若 <span class="math inline">\(\{a_k\}\)</span> 单调有界，且 <span class="math inline">\(\sum\limits_{k=1}^\infty\)</span> 级数收敛，则级数 <span class="math inline">\(\sum\limits_{k=1}^\infty a_kb_k\)</span> 收敛</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>级数</tag>
      </tags>
  </entry>
  <entry>
    <title>外微分形式与微积分</title>
    <url>/2020/05/24/study/Math/Advanced-Mathematics/Exterior-Differential/</url>
    <content><![CDATA[<p>些些写累了，准备 <del>白嫖</del> 维基百科。关于外微分形式与场论中几个公式，在教材中并没有给出完整的说明，在这里简单记录一下。</p>
<span id="more"></span>
<blockquote>
<p>以下内容收集自 Wikipedia</p>
</blockquote>
<h2 id="外微分形式">外微分形式</h2>
<h3 id="定义">定义</h3>
<p>一个 <span class="math inline">\(k\)</span> 阶的微分形式的外微分是 <span class="math inline">\(k+1\)</span> 阶的微分形式。对于一个 <span class="math inline">\(k\)</span> 阶形式的 <span class="math inline">\(ω = f_I\mathrm dx_I\)</span>，其外微分形式为<span class="math inline">\({\displaystyle \mathrm d{\omega }=\sum _{i=1}^{n}{\frac {\partial f_{I}}{\partial x_{i}}}\mathrm dx_{i}\wedge \mathrm dx_{I}}\)</span>。</p>
<p>对于一般的<em>k</em>-形式 <span class="math inline">\(\sum f_I dx_I\)</span> （其中多重指标 <span class="math inline">\(I\)</span> 取遍所有<span class="math inline">\(\{1, ..., n\}\)</span>的为 <span class="math inline">\(k\)</span> 基数的有序子集），我们只作了线性推广。注意如果上面有 <span class="math inline">\(i=I\)</span> 则 <span class="math inline">\(\mathrm dx_{i}\wedge\mathrm dx_{I}=0\)</span>。</p>
<h3 id="性质">性质</h3>
<p>外微分满足：</p>
<ul>
<li><p>线性</p></li>
<li><p>楔积法则：<span class="math inline">\(\displaystyle{ d(\omega \wedge \eta )=d\omega \wedge \eta +(-1)^{ {\rm {deg\,} }\omega }(\omega \wedge d\eta )}\)</span></p></li>
<li><p><span class="math inline">\(\mathrm d^2 =0\)</span></p></li>
</ul>
<h2 id="微积分中的外微分">微积分中的外微分</h2>
<h3 id="梯度">梯度</h3>
<p>对于一个 0-形式，也就是一个光滑函数 <span class="math inline">\(f: R^n\rightarrow R\)</span>，我们有 <span class="math inline">\({\displaystyle df=\sum _{i=1}^{n}{\frac {\partial f}{\partial x_{ i } } }\,dx_{i}}\)</span>，所以对于向量场 <span class="math inline">\(\boldsymbol V\)</span> 而言：<span class="math inline">\({\displaystyle df(V)=\langle {\mathrm{grad} }f,V\rangle }\)</span></p>
<h3 id="旋度">旋度</h3>
<p>对于一个 1-形式，<span class="math inline">\({\displaystyle \omega =\sum _{i}f_{i}\,dx_{i}}\)</span> 在 <span class="math inline">\(R^3\)</span> 上，有：</p>
<p><span class="math display">\[
{\displaystyle \omega =\sum _{i}f_{i}\,dx_{i}}
\]</span></p>
<p>它限制到三维情况 <span class="math inline">\({\displaystyle \omega =u\,dx+v\,dy+w\,dz}\)</span> 就是</p>
<p><span class="math display">\[
{\displaystyle d\omega =\left({\frac {\partial v}{\partial x}}-{\frac {\partial u}{\partial y}}\right)dx\wedge dy+\left({\frac {\partial w}{\partial y}}-{\frac {\partial v}{\partial z}}\right)dy\wedge dz+\left({\frac {\partial u}{\partial z}}-{\frac {\partial w}{\partial x}}\right)dz\wedge dx.}
\]</span></p>
<p>因此，对于向量场 <span class="math inline">\({\displaystyle U}, {\displaystyle V=[u,v,w]}\)</span> 和 <span class="math inline">\({\displaystyle W}\)</span> 我们有 <span class="math inline">\({\displaystyle d\omega (U,W)=\langle {\mathrm{curl}}\,V\times U,W\rangle }\)</span></p>
<p>其中 <span class="math inline">\(\mathrm {curl} V\)</span> 代表<em>V</em>的旋度，<span class="math inline">\(\times\)</span> 是向量积，而 <span class="math inline">\(&lt;,&gt;\)</span> 是标量积。</p>
<h3 id="散度">散度</h3>
<p>对于一个 2-形式 <span class="math inline">\({\displaystyle \omega =\sum _{i,j}h_{i,j}\,dx_{i}\wedge dx_{j},}\)</span></p>
<p>对于三维，若<span class="math inline">\({\displaystyle \omega =p\,dy\wedge dz+q\,dz\wedge dx+r\,dx\wedge dy}\)</span></p>
<p><span class="math inline">\({\displaystyle d\omega} {\displaystyle =\left({\frac {\partial p}{\partial x}}+{\frac {\partial q}{\partial y}}+{\frac {\partial r}{\partial z}}\right)dx\wedge dy\wedge dz}{\displaystyle ={\mathrm{div}}V\,dx\wedge dy\wedge dz,}\)</span></p>
<p>其中 <span class="math inline">\(V\)</span> 是一个向量场定义为 <strong><span class="math inline">\({\displaystyle V=[p,q,r].}\)</span></strong></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>外微分形式</tag>
        <tag>向量空间</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶级数</title>
    <url>/2020/06/07/study/Math/Advanced-Mathematics/FourierSeries/</url>
    <content><![CDATA[<p>傅里叶级数，真的就看上去简单。</p>
<span id="more"></span>
<h2 id="三角函数系及其正交性">三角函数系及其正交性</h2>
<p>在这里就直接给出这个单位正交系：</p>
<p><span class="math inline">\(1,\frac{1}{\sqrt{2\pi}}\cos x,\frac{1}{\sqrt{2\pi}}\sin x,\frac{1}{\sqrt{2\pi}}\cos 2x,\frac{1}{\sqrt{2\pi}}\sin 2x,\dots\)</span></p>
<p>但是我们用的更多的是：</p>
<p><span class="math inline">\(1,\cos x,\sin x,\cos 2x,\sin 2x,\dots\)</span></p>
<blockquote>
<p>这里正交指的是<strong>积分</strong>：<span class="math inline">\(\displaystyle&lt;f,g&gt;=\int_a^b f\cdot g\)</span></p>
</blockquote>
<h2 id="周期为-2pi-的函数的傅里叶级数及其收敛性">周期为 2pi 的函数的傅里叶级数及其收敛性</h2>
<h3 id="周期函数的傅氏系数和傅氏级数">周期函数的傅氏系数和傅氏级数</h3>
<ul>
<li><strong>Def</strong>：（傅里叶系数、傅里叶级数）将</li>
</ul>
<p><span class="math display">\[
a_n=\frac 1 \pi\int_{-\pi}^{\pi}f(x)\cos nx\mathrm dx(n=0,1,2,\dots)\\
b_n=\frac 1 \pi\int_{-\pi}^{\pi}f(x)\sin nx\mathrm dx(n=1,2,3,\dots)
\]</span></p>
<p>称为函数<span class="math inline">\(f\)</span> 的<strong>傅里叶系数</strong>，而</p>
<p><span class="math display">\[
\frac {a_0} 2+\sum\limits_{n=1}^\infty(a_n\cos nx+b_n\sin nx)
\]</span></p>
<p>称为<strong>傅里叶级数</strong></p>
<blockquote>
<p>问题在于，这个级数的和函数不一定和原函数相等，因而，我们用<span class="math inline">\(\displaystyle f\sim \frac {a_0} 2+\sum\limits_{n=1}^\infty(a_n\cos nx+b_n\sin nx)\)</span> 来表示。</p>
</blockquote>
<h3 id="傅氏级数的收敛性定理和傅氏展开式">傅氏级数的收敛性定理和傅氏展开式</h3>
<blockquote>
<p>吐槽一下工科数分，人家高等数学讲的炒鸡清楚！</p>
</blockquote>
<ul>
<li><p><strong>Def</strong>：（分段连续）<span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上除了<strong>有限个</strong>第一类间断点外处处连续。</p></li>
<li><p><strong>Def</strong>：（分段单调）<span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上有<strong>有限个</strong>单调区间。</p></li>
<li><p><strong>Def</strong>：（<code>Dirichlet</code> 条件）<span class="math inline">\(f(x)\)</span> 分段连续且分段单调</p></li>
<li><p><strong>Thm</strong>：（傅里叶级数的收敛性定理）如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\([-\pi,\pi]\)</span> 满足 <code>Dirichlet</code> 条件，则其傅氏级数在<span class="math inline">\([-\pi,\pi]\)</span>任意一点都收敛，且和函数为</p></li>
</ul>
<p><span class="math display">\[
\displaystyle S(x) =\begin{cases}f(x),&amp;连续点\\
\frac{f(x+0)+f(x-0)}{2},&amp;间断点
\end{cases}
\]</span></p>
<ul>
<li><strong>Thm</strong>：（傅里叶级数的收敛性原理2）若 <span class="math inline">\(f(x)\)</span> 以 <span class="math inline">\(2\pi\)</span> 为周期，且在区间 <span class="math inline">\([-\pi,\pi]\)</span> 上分段可微，则该傅里叶级数在任一点处收敛到和函数 <span class="math inline">\(\displaystyle S(x) =\frac 1 2(f(x+0)+f(x-0)),-\infty&lt;x&lt;\infty\)</span></li>
</ul>
<blockquote>
<p>这个时候，我们才能用 <span class="math inline">\(=\)</span> 替换 <span class="math inline">\(\sim\)</span></p>
</blockquote>
<div class="note"><p>success</p></div>
<p>有了这个定理之后，就可以求出一系列看似无法求出的和</p>
<!-- TODO: endnote-->
<h3 id="奇偶周期函数的傅氏级数">奇偶周期函数的傅氏级数</h3>
<ul>
<li><p>偶函数：<span class="math inline">\(b_n=0,~f(x)=\frac {a_0}{2}+\sum\limits_{n=1}^{\infty} a_n\cos nx\)</span> 称为<strong>傅氏余弦函数</strong></p></li>
<li><p>奇函数：<span class="math inline">\(a_n=0,~f(x) \sim \sum\limits_{n=1}^\infty b_n\sin nx\)</span> 称为<strong>傅氏正弦函数</strong></p></li>
</ul>
<blockquote>
<p>这个结论是显然的，只是给个定义</p>
</blockquote>
<h3 id="任意周期函数的傅氏级数">任意周期函数的傅氏级数</h3>
<p>我们替换<span class="math inline">\(a_n,b_n\)</span> 中的系数做一些替换即可，若定义在<span class="math inline">\([-l,l]\)</span>，周期为<span class="math inline">\(2l\)</span> <span class="math display">\[
a_n=\frac 1 l\int_{-l}^{l}f(x)\cos nx\mathrm dx(n=0,1,2,\dots)\\
b_n=\frac 1 l\int_{-l}^{l}f(x)\sin nx\mathrm dx(n=1,2,3,\dots)
\]</span> 但是重点在于，傅氏级数不仅仅可以用于讨论周期函数，也可以拿来讨论任意一个函数。</p>
<p><strong>周期延拓函数</strong> <span class="math inline">\(F(x)\)</span>：<span class="math inline">\(F(x)=f(x-2kl)\)</span></p>
<p>又如在 <span class="math inline">\([0,l]\)</span> 上的函数：</p>
<ul>
<li><p><strong>奇延拓</strong>： <span class="math display">\[
F_1(x)=\begin{cases}
f(x),&amp;0&lt;x\le l\\
0,&amp;x=0\\
-f(-x),&amp;-l\le x&lt;0
\end{cases}
\]</span></p></li>
<li><p><strong>偶延拓</strong>： <span class="math display">\[
F_2(x)=\begin{cases}
f(x),&amp;0\le x\le l\\
f(-x),&amp;-l\le x&lt;0
\end{cases}
\]</span></p></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>级数</tag>
        <tag>傅里叶</tag>
      </tags>
  </entry>
  <entry>
    <title>函数项级数</title>
    <url>/2020/06/01/study/Math/Advanced-Mathematics/FuncTermSeries/</url>
    <content><![CDATA[<p>函数项级数</p>
<span id="more"></span>
<p><strong>Def</strong>：将无穷多项的一列函数依次用加号得到的表达式称为函数项级数<span class="math inline">\(\displaystyle\sum\limits_{n=1}^{\infty}u_n(x_0)\)</span></p>
<h2 id="函数项级数的处处收敛性">函数项级数的处处收敛性</h2>
<p><strong>Def</strong>：（函数项级数的处处收敛性和和函数）若级数 <span class="math inline">\(\displaystyle\sum\limits_{n=1}^{\infty}u_n(x_0)\)</span> 收敛，则称 <span class="math inline">\(x_0\)</span> 为<strong>收敛点</strong>，收敛点全体构成的集合称为<strong>收敛域</strong>，相对应的定义<strong>发散点</strong>，<strong>发散域</strong>。如果 <span class="math inline">\(\forall x\in D\)</span> 级数收敛则称为在 <span class="math inline">\(D\)</span> 上处处收敛。称收敛处的极限值为<strong>和函数</strong> <span class="math inline">\(S(x)\)</span></p>
<p>与常数项级数相似，<strong>余项</strong> <span class="math inline">\(R_n(x) = S(x) -S_n(x) \rightarrow 0 (n\rightarrow \infty)\)</span></p>
<div class="note"><p>primary</p></div>
<p><strong>Tips</strong></p>
<p>需要注意的是，有限个可导函数的和为可导函数，可积函数的和为可积函数，但是在无穷多个时此结论不一定成立</p>
<!-- TODO: endnote-->
<h2 id="函数项级数的一致收敛性与判别法">函数项级数的一致收敛性与判别法</h2>
<p><strong>Def</strong>：（一致收敛性）<span class="math inline">\(\forall \varepsilon &gt;0,\exists N(\varepsilon)\in \mathrm N_+,\forall n&gt;N(\varepsilon)\forall x\in D,|S_n(x)-S(x)|&lt;\varepsilon\)</span></p>
<p><strong>Thm</strong>：（Cauchy 一致收敛原理）函数项级数一致收敛的充要条件是 <span class="math inline">\(\forall \varepsilon&gt;0,\exists N(\varepsilon)i\in \mathrm N,\forall n,p\in\mathrm N_+,n&gt;N时\forall x\in D,|S_{n+p}-S_n|&lt;\varepsilon\)</span></p>
<blockquote>
<p>这个结论是显然的，我们需要更多的准敛法则</p>
</blockquote>
<p><strong>Thm</strong>：（M 判别法、Weierstrass 准则）如果存在一个收敛的正项级数，恒大于一个函数项级数的绝对值，则该函数项级数收敛。</p>
<blockquote>
<p>这个结论也是显然的，用三角不等式和柯西判别法判断即可。</p>
</blockquote>
<h2 id="一致收敛级数的性质">一致收敛级数的性质</h2>
<p><strong>Thm</strong>：（和函数的连续性）原函数连续且一致收敛则和函数连续</p>
<p><strong>Thm</strong>：（和函数的可积性）原函数可积且一致收敛则和函数可积</p>
<p><strong>Thm</strong>：（和函数的可导性）原函数导函数且连续一致收敛则和函数可导</p>
<blockquote>
<p>在幂级数和傅里叶级数中，这三个定理有极大的作用</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>级数</tag>
      </tags>
  </entry>
  <entry>
    <title>幂级数</title>
    <url>/2020/06/01/study/Math/Advanced-Mathematics/PowerSeries/</url>
    <content><![CDATA[<p>幂级数</p>
<span id="more"></span>
<h2 id="幂级数的收敛半径与收敛区间">幂级数的收敛半径与收敛区间</h2>
<p><strong>Thm</strong>：（幂级数的收敛情况）幂级数的收敛情况有且仅有以下三种：</p>
<ol type="1">
<li>收敛范围是整个实轴</li>
<li>收敛范围是一个对称区间</li>
<li>仅在 <span class="math inline">\(x=0\)</span> 收敛</li>
</ol>
<p><strong>Thm</strong>：（幂级数的收敛半径）对于幂级数的系数 <span class="math inline">\(a_n\)</span>，若 <span class="math inline">\(\rho =\overline{\lim\limits_{n\rightarrow \infty}}\sqrt[n]{|a_n|}\)</span> 则</p>
<ol type="1">
<li>当 <span class="math inline">\(0\le \rho&lt;+\infty,|x|&lt;\frac 1 \rho\)</span> 幂级数绝对收敛</li>
<li>当 <span class="math inline">\(0&lt;\rho&lt;\infty, |x|&gt;\frac 1 \rho\)</span> 幂级数发散</li>
</ol>
<p>其中 <span class="math inline">\(R=\frac 1 \rho\)</span> 称作<strong>收敛半径</strong>，称 <span class="math inline">\((-R,R)\)</span> 为<strong>收敛区间</strong></p>
<div class="note"><p>primary</p></div>
<p><strong>Tips</strong></p>
<p>收敛区间和收敛域是不同的，区别在于端点处可能条件收敛</p>
<!-- TODO: endnote-->
<p><strong>Thm</strong>：幂级数在 <span class="math inline">\(x =x_1\)</span> 处收敛，则在 <span class="math inline">\((-|x_1|,|x_1|)\)</span> 上绝对收敛。若 <span class="math inline">\(x=x_2\)</span> 发散，则它在 <span class="math inline">\(|x|&gt;|x_2|\)</span> 处也发散</p>
<blockquote>
<p>这个定理很好证明，用 M 判别法即可</p>
</blockquote>
<p><strong>Thm</strong>：对于幂级数的系数 <span class="math inline">\(a_n\)</span> 满足 <span class="math inline">\(\lim\limits_{n\rightarrow\infty}|\frac{a_{n+1}}{a_n}|=l\)</span> 则 <span class="math inline">\(R=\frac 1 l\)</span>（包含 0 和无穷的情况）</p>
<h2 id="幂级数的性质">幂级数的性质</h2>
<p><strong>Thm</strong>：（内闭一致收敛）设一个幂级数的收敛半径为 <span class="math inline">\(R&gt;0\)</span>，在收敛区间内，幂级数内闭一致收敛</p>
<blockquote>
<p>如果在 R 处也收敛，则可以补全一致收敛到 R 处，也就是说 <span class="math inline">\(在R处收敛\rightarrow 在[0,R]一致收敛\)</span></p>
</blockquote>
<p><strong>Thm</strong>：幂级数的和函数是在收敛区间内是一个连续函数</p>
<p><strong>Thm</strong>：幂级数的和函数是在收敛区间内的可微函数，且可以逐项求微，收敛区间不变</p>
<p><strong>Thm</strong>：幂级数在积分后，收敛区间不变</p>
<p><strong>Thm</strong>：在可导的情况下，幂级数可以逐项求导任意多次。</p>
<p><strong>Thm</strong>：在 <span class="math inline">\(x=R\)</span> 处收敛，则和函数在 <span class="math inline">\([0,R]\)</span> 连续</p>
<blockquote>
<p>通过函数项级数的判定即可得到这些定理</p>
</blockquote>
<h2 id="斯特林公式">斯特林公式</h2>
<p>公式：<span class="math inline">\(\displaystyle n!=\sqrt{2\pi n} (\frac n e)^ne^{\frac{\theta}{12n}}\approx\sqrt{2\pi n} (\frac n e)^n,\theta\in(0,1)\)</span></p>
<p>沃利斯公式：<span class="math inline">\(\displaystyle \frac \pi 2=\lim\limits_{n \to \infty}\frac{[(2n)!!]^2}{[(2n-1)!!]^2(2n+1)}\)</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>级数</tag>
      </tags>
  </entry>
  <entry>
    <title>多元数量值函数微分学及其应用</title>
    <url>/2020/06/04/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry-Derivative/</url>
    <content><![CDATA[<p>到这里，这个学期的内容就大致整理完整了。</p>
<span id="more"></span>
<h2 id="n-维-euclid-空间-rn-中点集知识">n 维 Euclid 空间 R^n 中点集知识</h2>
<h3 id="n-维-euclid-空间-rn">n 维 Euclid 空间 R^n</h3>
<ul>
<li><strong>Def</strong>：n 维实向量</li>
<li><strong>Def</strong>：n 维实向量空间（n 维实线性空间）</li>
</ul>
<p>对加法和数乘满足：(For any a, b in V)</p>
<div class="note"><p>primary</p></div>
<ol type="1">
<li>交换律</li>
<li>结合律</li>
<li>存在零元（加法）</li>
<li>对任意的 a，存在-a</li>
<li>存在单位元 1 1a=a</li>
<li>对数乘的结合律</li>
<li>对数乘的分配律</li>
<li>对 a, b 的结合律</li>
</ol>
<!-- TODO: endnote-->
<ul>
<li><strong>Def</strong>：长度（范数）</li>
<li><strong>Def</strong>：距离</li>
<li><strong>Def</strong>：R^n 中的单位正交基</li>
</ul>
<h3 id="rn-中点列的极限">R^n 中点列的极限</h3>
<ul>
<li><p><strong>Def</strong>：点列的极限 <span class="math inline">\(\boldsymbol x_i\rightarrow\boldsymbol a\)</span></p></li>
<li><p><strong>Thm</strong>：点列的极限 iff 点的分量（列）的极限</p></li>
<li><p><strong>Thm</strong>：点列极限的性质</p></li>
<li><p>唯一性</p></li>
<li><p>有界性</p></li>
<li><p>任一子点列收敛</p></li>
<li><p><span class="math inline">\(\lim k\times x=ka\)</span> <span class="math inline">\(\lim x+y=a+b\)</span> <span class="math inline">\(\lim(x,y)=(a,b)\)</span></p></li>
<li><p><strong>Thm</strong>：（Bolzano-Weierstrass 定理）有界点列必有收敛子列</p></li>
<li><p><strong>Thm</strong>：（Cauchy 收敛原理）<span class="math inline">\(x_k\)</span>收敛<span class="math inline">\(\iff x_k\)</span>为基本列</p></li>
</ul>
<h3 id="欧式空间中的点集">欧式空间中的点集</h3>
<ul>
<li><p><strong>Def</strong>：聚点、导集、闭包、孤立点、闭集</p>
<ul>
<li><strong>聚点</strong>：存在<span class="math inline">\(A\)</span>中不同于<span class="math inline">\(x\)</span>的点列，使得以 <span class="math inline">\(x\)</span> 为点列极限</li>
<li><strong>导集</strong>：<span class="math inline">\(A\)</span> 中所有聚点构成的集合 <span class="math inline">\(A&#39;\)</span></li>
<li><strong>闭包</strong>：<span class="math inline">\(\overline A= A\cup A&#39;\)</span></li>
<li><strong>孤立点</strong>：<span class="math inline">\(a\in A-A&#39;\)</span></li>
<li><strong>闭集</strong>：<span class="math inline">\(A&#39;\subseteq A\)</span></li>
</ul></li>
<li><p><strong>Thm</strong>：闭集的充要条件</p>
<ul>
<li><span class="math inline">\(A=\bar A\)</span></li>
<li><span class="math inline">\(\forall \{x_n\} \in A, \lim x_n = x\rightarrow x \in E\)</span></li>
<li>$ x A,U(x)E=$</li>
</ul></li>
<li><p><strong>Thm</strong>：（聚点原理）有界的无限点集至少有一个聚点</p></li>
<li><p><strong>Def</strong>：邻域、去心邻域</p>
<ul>
<li><strong>Thm</strong>：a 是 A 的聚点<span class="math inline">\(\iff \forall U(a), U(a)\cup A\neq \emptyset\)</span></li>
</ul></li>
<li><p><strong>Def</strong>：内点、内部（int A）外点、外部（ext A）边界点、边界（A）</p></li>
<li><p><strong>Def</strong>：开集</p>
<ul>
<li><strong>Thm</strong>：<span class="math inline">\(A\)</span> 为开集<span class="math inline">\(\iff A^c\)</span>为闭集</li>
</ul></li>
<li><p><strong>Thm</strong>：开集（闭集）的性质</p>
<ul>
<li>有限个开集（闭集）的交集（并集）是开集（闭集）</li>
<li>任意个开集（闭集）的并集（交集）是开集（闭集）</li>
</ul></li>
<li><p>区域</p>
<ul>
<li>（折线连通）连通开集（开区域）</li>
<li>开区域的闭包=&gt;闭区域</li>
</ul></li>
<li><p>紧集</p>
<ul>
<li><strong>Def</strong>：覆盖（A 的一个覆盖）</li>
<li><strong>Def</strong>：（紧集）A 的任意一个开覆盖必定有一个有限的子覆盖</li>
<li><strong>Thm</strong>：紧集<span class="math inline">\(\iff\)</span>有界闭集</li>
</ul></li>
</ul>
<h2 id="多元函数的极限和连续性">多元函数的极限和连续性</h2>
<h3 id="映射">映射</h3>
<ul>
<li><strong>Def</strong>：映射</li>
<li><strong>Def</strong>：单叶映射</li>
<li><strong>Def</strong>：逆映射</li>
</ul>
<h3 id="def向量函数数值函数">Def：向量函数、数值函数</h3>
<h3 id="多元数值函数的极限">多元数值函数的极限</h3>
<ul>
<li><strong>Def</strong>：多元函数的极限</li>
<li><strong>Thm</strong>：<span class="math inline">\(\lim f=A\iff \forall S \in U 以a为聚点，都有\lim f= A\)</span></li>
<li><strong>Thm</strong>：<span class="math inline">\(\lim x_n=a\)</span> 的点列<span class="math inline">\(x_n-&gt;a\)</span></li>
<li><strong>Thm</strong>：四则运算法则</li>
<li><strong>Thm</strong>：（柯西列扩展）</li>
</ul>
<blockquote>
<p><strong>多元函数的重极限</strong>：</p>
<p>用极坐标变换法求解（需要注意也是对于<span class="math inline">\(\rho\rightarrow0,\theta \in [0,2\pi)\)</span>一致成立）</p>
</blockquote>
<h3 id="def累次极限">Def：累次极限</h3>
<ul>
<li>n 重极限<span class="math inline">\(\Rightarrow\)</span>累次极限</li>
</ul>
<blockquote>
<p>在这里，翟神某翟给出了一些相关的题目，总结一下：</p>
<ol type="1">
<li>累次极限和重极限的关系上，都存在时，几个极限值都必须相等</li>
<li>在这里主要是证明重积分不存在。</li>
</ol>
</blockquote>
<h3 id="多元连续函数">多元连续函数</h3>
<ul>
<li><strong>Def</strong>：二元连续函数
<ul>
<li><span class="math inline">\(x_0\)</span>是孤立点</li>
<li><span class="math inline">\(x_0\)</span>是聚点，则连续指<span class="math inline">\(\lim f(x)=f(x_0)\)</span></li>
<li><strong>Thm</strong>：四则运算的连续性</li>
<li><strong>Thm</strong>：复合函数的连续性</li>
</ul></li>
</ul>
<blockquote>
<p>二元连续函数的条件</p>
<ol type="1">
<li><span class="math inline">\(f(x, y)\)</span> 在 <span class="math inline">\(I\)</span> 上对 <span class="math inline">\(x\)</span> 的连续性对 <span class="math inline">\(y\)</span> 是一致的.</li>
<li><span class="math inline">\(f(x, y)\)</span> 在 <span class="math inline">\(I\)</span> 内任意一点<span class="math inline">\((x_0, y_0)\)</span> 附近对 <span class="math inline">\(x\)</span> 满足对 <span class="math inline">\(y\)</span> 一致的 Lipschitz 条件.</li>
<li><span class="math inline">\(f(x, y)\)</span> 对于变元 <span class="math inline">\(x\)</span> 是单调的.</li>
</ol>
</blockquote>
<ul>
<li><p>连续函数的性质</p>
<ul>
<li><p>有界性</p></li>
<li><p>最大值最小值定理</p>
<blockquote>
<p>紧集上的连续函数有界，并且存在着最大值与最小值.</p>
</blockquote></li>
<li><p><strong>Thm</strong>：介值定理</p></li>
<li><p><strong>Thm</strong>：一致连续性</p>
<blockquote>
<p>Cantor 定理： 紧集上的连续函数是一致连续的.</p>
</blockquote></li>
<li><p><strong>Def</strong>：道路连通、复合函数的道路连通性</p></li>
</ul></li>
<li><p><strong>Thm</strong>：压缩映射原理</p></li>
</ul>
<h2 id="偏导数和全微分">偏导数和全微分</h2>
<h3 id="def偏导数">Def：偏导数</h3>
<ul>
<li>几何意义</li>
<li>可偏导</li>
</ul>
<h3 id="thm微分中值定理">Thm：微分中值定理</h3>
<h3 id="def全微分">Def：全微分</h3>
<ul>
<li><p>矩阵定义</p></li>
<li><p><strong>Thm</strong>：可微的必要条件</p>
<ul>
<li><ol type="1">
<li>偏导数都存在</li>
</ol></li>
<li><ol start="2" type="1">
<li><span class="math inline">\(L_i(x_0)=\)</span>偏导数</li>
</ol></li>
</ul></li>
<li><p><strong>Thm</strong>：可微的充分条件</p>
<ul>
<li>偏导数存在且连续</li>
</ul></li>
<li><p>全微分的四则运算法则</p></li>
<li><p>全微分的几何意义</p></li>
</ul>
<blockquote>
<p>（翟神某翟的加餐）由上面的叙述，证明函数 f 在点(x0, y0) 处不可微的常用方法有:</p>
<ol type="1">
<li>函数 <span class="math inline">\(f\)</span> 在点 <span class="math inline">\((x_0, y_0)\)</span> 处至少有一个偏导数不存在</li>
<li>函数 <span class="math inline">\(f\)</span> 在点 <span class="math inline">\((x_0, y_0)\)</span> 处不连续</li>
<li><span class="math inline">\(\Delta f − f_x(x_0, y_0)\Delta x − f_y(x_0, y_0)\Delta y \neq o(r)\)</span></li>
</ol>
<p>例如：<span class="math inline">\(f=\sqrt{|xy|}\)</span>在<span class="math inline">\((0,0)\)</span>连续，且偏导都存在，但是不可微。</p>
</blockquote>
<h3 id="复合函数链式求导法则">复合函数链式求导法则</h3>
<ul>
<li>链式法则矩阵形式 <span class="math inline">\(\mathrm D(\boldsymbol f\circ \boldsymbol g) = \mathrm D\boldsymbol f (\boldsymbol g(\boldsymbol t)) \mathrm D \boldsymbol g(\boldsymbol t)\)</span></li>
<li><strong>Thm</strong>：复合函数可微性</li>
<li><strong>Thm</strong>：一阶全微分形式不变性</li>
</ul>
<h3 id="方向导数梯度">方向导数、梯度</h3>
<ul>
<li><p><strong>Def</strong>：方向导数</p>
<ul>
<li><strong>Thm</strong>：可微=&gt;任意方向导数存在</li>
<li>方向导数的几何意义</li>
<li><strong>Thm</strong>：用偏导数，求方向导数</li>
</ul></li>
<li><p><strong>Def</strong>：梯度向量、梯度算子（nabla 算子）</p>
<ul>
<li><strong>Thm</strong>：若 grad=0，则任何方向导数=0</li>
<li><strong>Thm</strong>：梯度方向，方向导数最大</li>
<li><strong>Thm</strong>：梯度四则运算法则</li>
</ul></li>
</ul>
<h3 id="高阶偏导数和高阶全微分">高阶偏导数和高阶全微分</h3>
<ul>
<li><p><strong>Def</strong>：高阶偏导数</p></li>
<li><p><strong>Def</strong>：混合偏导数</p>
<ul>
<li><strong>Thm</strong>：混合偏导数和求导顺序无关</li>
</ul></li>
<li><p><strong>Def</strong>：高阶全微分</p></li>
<li><p>复合函数的高阶偏导数</p></li>
<li><p>一阶全微分形式的不变性</p></li>
<li><p><strong>Thm</strong>：全微分的有理运算法则</p></li>
</ul>
<h3 id="隐函数微分法">隐函数微分法</h3>
<ul>
<li><strong>Thm</strong>：隐函数存在唯一性定理</li>
<li><strong>Thm</strong>：隐函数可微性定理</li>
</ul>
<h2 id="多元函数的-taylor-公式和极值问题">多元函数的 Taylor 公式和极值问题</h2>
<p><strong>Thm</strong>：多元函数（带拉格朗日余项的）泰勒公式（全微分形式）</p>
<ul>
<li>Hessian 矩阵</li>
</ul>
<p><strong>Thm</strong>：多元函数（带 Peano 余项的）泰勒公式</p>
<h2 id="多元函数几何应用极值问题">多元函数几何应用，极值问题</h2>
<h3 id="曲线表示法">曲线表示法</h3>
<ul>
<li><p>空间曲线</p>
<ul>
<li>参数方程</li>
<li>切线</li>
</ul></li>
<li><p>平面曲线</p>
<ul>
<li>表示法</li>
<li>切线</li>
</ul></li>
</ul>
<h3 id="空间曲面表示法">空间曲面表示法</h3>
<ul>
<li>切平面方程</li>
</ul>
<h3 id="简单极值问题">简单极值问题</h3>
<ul>
<li><strong>Def</strong>：（无约束）极值
<ul>
<li>必要条件：梯度=0</li>
</ul></li>
<li><strong>Def</strong>：稳定点（梯度 = 0）</li>
<li><strong>Thm</strong>：f 在 x_0 取极小值（极大值），则 Hessian 矩阵是正定或半正定的（负定或半负定的）</li>
</ul>
<h3 id="有约束的极值">有约束的极值</h3>
<ul>
<li><strong>Def</strong>：约束极值
<ul>
<li>Lagrange 乘数法</li>
</ul></li>
</ul>
<h2 id="几何应用">几何应用</h2>
<h3 id="曲线的切线和法平面">曲线的切线和法平面</h3>
<ul>
<li>曲线的参数方程</li>
<li>简单曲线和有向曲线</li>
<li>曲线的切线和法平面</li>
</ul>
<blockquote>
<p>切线的求法：</p>
<p>如果给出了 <span class="math inline">\(\boldsymbol x=\boldsymbol{x}(t)\rightarrow \boldsymbol{x}=\dot{\boldsymbol{x}}t+\boldsymbol{x}(t_0)\)</span></p>
<p>如果给出了：<span class="math inline">\(F=G=0\)</span></p>
<p>则切向量 <span class="math inline">\(\eta=(\frac{\partial (F,G)}{\partial (y,z)},\frac{\partial (F,G)}{\partial (z,x)},\frac{\partial (F,G)}{\partial (x,y)}) =\nabla F\times \nabla G\)</span></p>
<p>法平面随之求出</p>
</blockquote>
<h3 id="弧长">弧长</h3>
<ul>
<li><strong>Def</strong>：弧长</li>
<li><strong>Thm</strong>：弧长的计算公式（参考第一型曲线积分）</li>
<li>弧微分和自然参数</li>
</ul>
<h3 id="曲线的切平面和法线">曲线的切平面和法线</h3>
<ul>
<li>曲面的参数方程</li>
<li>曲面上曲线的表示</li>
<li>曲线的切平面和法线
<ul>
<li>切平面</li>
<li>法线、法向量</li>
<li>光滑曲面</li>
</ul></li>
</ul>
<blockquote>
<p>实际上都是求法向量</p>
<ol type="1">
<li>显式给出曲面方程 假设曲面方程 <span class="math inline">\(z=f(x,y)\)</span> 则在 <span class="math inline">\(P\)</span> 处，<span class="math inline">\(f_x\mathrm dx+f_y\mathrm dy-dz=0\)</span> 则法向量为 <span class="math inline">\(\eta =(f_x,f_y,-1)\)</span></li>
<li>由参数方程给出曲面方程 <span class="math inline">\(\boldsymbol{r}=\boldsymbol{r}(u,v)=\boldsymbol{r}(x,y,z)\)</span> 则法向量 <span class="math inline">\(\eta=\boldsymbol r_u\times \boldsymbol{r}_v=(\frac{\partial (y,z)}{\partial(u,v)},\frac{\partial (z,x)}{\partial(u,v)},\frac{\partial (x,y)}{\partial(u,v)})\)</span></li>
<li><span class="math inline">\(F(x,y,z)=0\rightarrow \eta = (F_x,F_y,F_z)\)</span></li>
</ol>
</blockquote>
<h3 id="空间曲线的曲率和挠率">空间曲线的曲率和挠率</h3>
<ul>
<li><p>Frenet 标架</p>
<ul>
<li><span class="math inline">\(T=\boldsymbol{r}&#39;\)</span> 切线、法平面 <span class="math inline">\((\rho-\boldsymbol{r}(s_0))\cdot r&#39;(s_0)=0\)</span></li>
<li><span class="math inline">\(\displaystyle B=\frac{\boldsymbol{r}&#39;\times\boldsymbol{r}&#39;&#39; }{||\boldsymbol{r}&#39;&#39;||}\)</span> 次（负）法线、密切平面 <span class="math inline">\(B\cdot(\rho -\boldsymbol{r}(s_0))=0\)</span></li>
<li><span class="math inline">\(\displaystyle N=\boldsymbol{r}&#39;&#39;=\frac{\boldsymbol{r}&#39;&#39;}{||\boldsymbol{r}&#39;&#39;||}\)</span> 主法线，从切平面</li>
</ul></li>
<li><p>曲率</p>
<ul>
<li><strong>Def</strong>：曲率<span class="math inline">\(\kappa = \lim \limits_{\Delta t \rightarrow 0} |{\frac { \Delta \theta}{\Delta s}}|\)</span></li>
<li><strong>Def</strong>：<span class="math inline">\(\kappa (s) = ||r&#39;&#39;(s)||\)</span></li>
</ul></li>
<li><p>曲率半径、曲率圆</p></li>
<li><p>挠率：<span class="math inline">\(\displaystyle\tau=-B&#39;\cdot N =\frac{[r&#39;~r&#39;&#39;~r&#39;&#39;&#39;]}{||r&#39;&#39;||^2}\)</span></p></li>
</ul>
<blockquote>
<p><span class="math inline">\(t\)</span> 坐标下的 Frenet 标架</p>
<ol type="1">
<li><span class="math inline">\(\displaystyle T=\frac{\dot r}{|\dot r|}\)</span></li>
<li><span class="math inline">\(\displaystyle B =\frac{\dot r\times \ddot r}{|\dot r\times \ddot r|}\)</span></li>
<li><span class="math inline">\(\displaystyle N = B\times T\)</span></li>
<li><span class="math inline">\(\displaystyle \kappa(s)=\kappa(t) =\frac{||\dot r\times\ddot r||}{||\dot r||^3}=\frac{||\dot x\ddot y-\dot y\ddot x||}{||\dot x^2+\dot y^2||^{3/2}}\)</span> 平面曲线：<span class="math inline">\(\displaystyle\kappa =\frac{|y&#39;&#39;|}{(1+y&#39;^2)^{3/2}}\)</span></li>
<li><span class="math inline">\(\tau(t)=\frac{[r&#39;(t)~ r&#39;&#39;(t)~r&#39;&#39;&#39;(t)]}{||r&#39;(t)\times r&#39;&#39;(t)||^2}\)</span></li>
</ol>
</blockquote>
<p>最后给出 Frenet 公式的矩阵形式：</p>
<p><span class="math display">\[
\left(\begin{matrix}
T&#39;\\N&#39;\\B&#39;
\end{matrix}\right)=\left(\begin{matrix}
  0&amp;\kappa&amp;0\\
  -\kappa&amp;0&amp;\tau\\
  0&amp;-\tau&amp;0\\
\end{matrix}\right)
\left(\begin{matrix}
    T\\N\\B
\end{matrix}
\right)
\]</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>多元函数</tag>
        <tag>微分</tag>
      </tags>
  </entry>
  <entry>
    <title>多元函数积分学及其应用</title>
    <url>/2020/05/23/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry-Integration/</url>
    <content><![CDATA[<p>多元函数积分学复习提纲。些些在 5.20 被强行塞了一大把狗粮之后，才知道下个星期就要考试，现在才开始预习...</p>
<span id="more"></span>
<h2 id="多元数量值函数积分的概念和性质">多元数量值函数积分的概念和性质</h2>
<h3 id="质量的计算">质量的计算</h3>
<h3 id="多元数量值函数积分的概念">多元数量值函数积分的概念</h3>
<ul>
<li><strong>Def</strong>：多元数量值函数积分</li>
</ul>
<h3 id="积分存在的条件和性质">积分存在的条件和性质</h3>
<ol type="1">
<li>线性性质</li>
<li>对积分域的可加性</li>
<li>积分不等式</li>
<li>中值定理</li>
</ol>
<h2 id="二重积分的计算">二重积分的计算</h2>
<ol type="1">
<li>二重积分的几何意义</li>
<li>直角坐标系下二重积分的计算法</li>
<li>极坐标系下二重积分的计算法</li>
<li>曲线坐标下二重积分的计算法</li>
</ol>
<h2 id="三重积分的计算">三重积分的计算</h2>
<ol type="1">
<li>化三重积分为单积分与二重积分的累次积分</li>
<li>柱面、球面坐标下的三重积分计算法
<ol type="1">
<li>曲线坐标下的三重积分</li>
<li>柱面坐标及柱面坐标下的三重积分计算法</li>
<li>球面坐标和球面坐标下的三重积分计算法</li>
</ol></li>
</ol>
<h2 id="含参变量的积分和反常重积分">含参变量的积分和反常重积分</h2>
<h3 id="含参变量的积分">含参变量的积分</h3>
<ul>
<li><p><strong>Def</strong>：含参变量<span class="math inline">\(y\)</span>的积分</p></li>
<li><p><strong>Thm</strong>：（连续性）<span class="math inline">\(f\in C(D) \rightarrow F(y) = \int^b_af(x,y)\mathrm d x 在[c,d]上连续\)</span></p></li>
<li><p><strong>Inf</strong>：（连续性的极限形式表达）<span class="math inline">\(\displaystyle\lim \limits_{y\rightarrow y_0} \int_a^bf(x,y)\mathrm d x = \int_a^b f(x,y_0)\mathrm d x = \int_a^b[\lim\limits_{y\rightarrow y_0} f(x,y)]\mathrm dx\)</span></p></li>
<li><p><strong>Thm</strong>：（可导性）<span class="math inline">\(f,f_y\in C(C)\)</span>，则 $F(y) = f(x,y) dx $有连续导数，且积分和求导运算可交换</p></li>
<li><p><strong>Thm</strong>：（积分顺序交换性）<span class="math inline">\(f \in C, F(y) = \int f\mathrm dx ,G(x) = \int f\mathrm dy\rightarrow \int F(y) \mathrm d y = \int G(x) \mathrm dx\)</span></p></li>
<li><p><strong>Thm</strong>：设 <span class="math inline">\(f(x,y)\in C(D), x_i (y) \in C[c,d]\)</span> 则，<span class="math inline">\(F(y) = \int_{x_1(y)}^ {x_2(y)}f(x,y)\mathrm dx\)</span> 在<span class="math inline">\([c,d]\)</span>上连续</p></li>
<li><p><strong>Thm</strong>：<span class="math inline">\(F&#39;(y) = \int _{x_1(y)}^ {x_2(y)}f_y(x,y)\mathrm dx+ f(x_2, y]x_2&#39; - f(x_1,y) x_1&#39;\)</span></p></li>
</ul>
<h3 id="反常重积分">反常重积分</h3>
<ul>
<li>无界区域的二重积分
<ul>
<li><strong>Thm</strong>：（收敛判别法）<span class="math inline">\(f(x,y)\)</span> 在无界区域上连续，若存在<span class="math inline">\(\rho_0&gt;0\)</span>，使当<span class="math inline">\(\rho \ge \rho_0\)</span> 有<span class="math inline">\(|f|\le \frac {M}{\rho^\alpha}\)</span>，且 <span class="math inline">\(M,\alpha\)</span>为常数，则当<span class="math inline">\(\alpha &gt;2\)</span>时反常二重积分<span class="math inline">\(\int\int f \mathrm d \sigma\)</span>收敛</li>
</ul></li>
<li>无界函数的二重积分
<ul>
<li><strong>Def</strong>：无界函数的二重积分<span class="math inline">\(\lim\limits_{d\rightarrow 0} \int\int f\mathrm d \sigma\)</span></li>
<li><strong>Thm</strong>：（收敛判别法）设 <span class="math inline">\(f(x,y)\)</span> 在有界区域上除了<span class="math inline">\(P_0\)</span>外处处连续，若 <span class="math inline">\(|f|\le \frac {M}{\rho ^\alpha}\)</span>在除 <span class="math inline">\(P_0\)</span> 外的区域上处处成立，则当 <span class="math inline">\(\alpha &lt;2\)</span>时，反常二重积分收敛</li>
</ul></li>
</ul>
<h2 id="第一型线积分与面积分">第一型线积分与面积分</h2>
<h3 id="第一型线积分">第一型线积分</h3>
<ul>
<li>第一型线积分的计算公式 <span class="math inline">\(r = r(t)\rightarrow \int_{(C)}f ds = \int_{(C)}f \sqrt{\dot x^2+\dot y^2+\dot z^2}\mathrm d t\)</span></li>
</ul>
<h3 id="第一型面积分">第一型面积分</h3>
<ul>
<li><p>曲面的面积</p>
<ul>
<li><strong>Thm</strong>：（用 <span class="math inline">\(u,v\)</span> 变量表示曲面）<span class="math inline">\(S = \int\int\limits_{(\sigma)}||\boldsymbol r_u \times \boldsymbol r_v|| \mathrm d u \mathrm d v\)</span></li>
<li><strong>Thm</strong>：（用 <span class="math inline">\(z = f(x,y)\)</span> 表示曲面）<span class="math inline">\(S = \iint \limits_{(\sigma)} ||\boldsymbol r_x \times \boldsymbol r_y || \mathrm dx\mathrm dy = \iint\limits_{(S)} \sqrt{1+f_x^2+f_y^2}\mathrm dx \mathrm dy\)</span></li>
</ul></li>
<li><p>第一型曲面积分的计算</p>
<ul>
<li><strong>Thm</strong>：（用 <span class="math inline">\(u,v\)</span> 变量表示曲面）<span class="math inline">\(I = \iint\limits_{(S)} f(x,y,z)\mathrm dS = \iint\limits_{(\sigma)}f||\boldsymbol r_u \times \boldsymbol r_v|| \mathrm d u \mathrm d v\)</span></li>
<li><strong>Thm</strong>：（用 <span class="math inline">\(z = f(x,y)\)</span> 表示曲面）<span class="math inline">\(I = \iint\limits_{(S)} f \sqrt{1+f_x^2+f_y^2}\mathrm dx \mathrm dy\)</span></li>
</ul></li>
</ul>
<h2 id="第二型线积分和面积分">第二型线积分和面积分</h2>
<h3 id="场的概念">场的概念</h3>
<ul>
<li><strong>Def</strong>：数量场、向量场、场函数</li>
<li>场的几何描述</li>
</ul>
<h3 id="第二型线积分">第二型线积分</h3>
<ul>
<li><p><strong>Def</strong>：第二型线积分<span class="math inline">\(\int_{(C)} \boldsymbol A(M)\cdot \boldsymbol{\mathrm d s} = \lim\limits_{d\rightarrow 0} \sum\limits_{k=1}^n \boldsymbol{A}(\overline {M_k})\cdot \overrightarrow{M_{k-1}M_k}\)</span></p></li>
<li><p>第二型线积分的性质</p>
<ul>
<li>积分结果与方向有关</li>
<li>可加性</li>
</ul></li>
<li><p>第二型线积分的计算 <span class="math inline">\(\int_{(C)}\boldsymbol A(M)\cdot \boldsymbol{\mathrm ds} = \int_{(C)}P\mathrm dx +Q\mathrm dy +R\mathrm dz =\int P\dot x+Q\dot y+R\dot z \mathrm dt\)</span></p></li>
<li><p>两类线积分的联系 <span class="math inline">\(\int_{(C)}\boldsymbol A(M) \cdot \boldsymbol{\mathrm ds} = \int \boldsymbol A(M)\cdot \boldsymbol e_r \mathrm ds\)</span></p></li>
</ul>
<h3 id="第二型面积分">第二型面积分</h3>
<ul>
<li><p><strong>Def</strong>：第二型面积分 <span class="math inline">\(\iint\limits_{(S)} \boldsymbol A(M)\cdot \boldsymbol {\mathrm dS} = \lim\limits_{d\rightarrow 0}\sum\limits_{k=1}^n \boldsymbol A(M_k)\cdot \boldsymbol e_n(M_k) \Delta S_k\)</span></p></li>
<li><p><strong>Thm</strong>：（用外微分形式表示）<span class="math inline">\(\iint A(M)\cdot \boldsymbol{\mathrm dS} = \iint\limits_{(S)}P\mathrm dy \wedge \mathrm dz +Q\mathrm dz \wedge dx + R\mathrm dx\wedge \mathrm dy\)</span></p></li>
<li><p>两种面积分的联系 <span class="math inline">\(\iint_{(S)} \boldsymbol A(M)\cdot \mathrm d \boldsymbol S = \iint (P\cos\alpha + Q\cos\beta + R\cos\gamma)\mathrm dS\)</span></p></li>
<li><p>第二型面积分的计算 <span class="math inline">\(\iint_{(S)} R(x,y,z) \mathrm dx\wedge \mathrm dy = \pm \iint\limits_{(\sigma_{xy})} R(x,y,z(x,y))\mathrm dx\mathrm dy\)</span> 其余式同理。其中当曲面法向量与 <span class="math inline">\(z+\)</span> 同向时取 <span class="math inline">\(+\)</span> 号，反之取 <span class="math inline">\(-\)</span> 号</p></li>
</ul>
<h2 id="各种积分的联系及其在场论中的应用">各种积分的联系及其在场论中的应用</h2>
<h3 id="green-公式">Green 公式</h3>
<ul>
<li><p><strong>Def</strong>：单连通域，复连通域</p></li>
<li><p><strong>Thm</strong>：Green 公式 <span class="math inline">\(\iint_{(\sigma)}(\frac{\delta Q}{\delta x} - \frac{\delta P}{\delta y} \mathrm d \sigma = \oint_{(\pm C)} P\mathrm dx + Q\mathrm dy\)</span></p></li>
<li><p><strong>Inf</strong>：任何一条分段光滑的闭曲线所围成的平面区域的面积为 <span class="math inline">\(A = \frac 1 2 \oint_{(+C)} x\mathrm dy - y\mathrm dx= \oint_{(+C)} x\mathrm dy = -\oint_{(+C)} y\mathrm dx\)</span></p></li>
</ul>
<h3 id="平面线积分与路径无关的条件">平面线积分与路径无关的条件</h3>
<ul>
<li><p><strong>Thm</strong>：TFAE</p>
<ol type="1">
<li>沿区域内任何一条分段光滑的简单闭曲线的线积分 <span class="math inline">\(\oint P\mathrm dx+Q\mathrm dy = 0\)</span></li>
<li>线积分 <span class="math inline">\(\int P\mathrm dx +Q\mathrm dy\)</span> 的值在区域内与积分路径无关</li>
<li>被积表达式<span class="math inline">\(P\mathrm dx +Q\mathrm dy\)</span> 是某个二元函数的全微分</li>
</ol></li>
<li><p><strong>Def</strong>：（环流量、环量）称眼闭曲线 <span class="math inline">\(C\)</span> 的第二型线积分为向量场 <span class="math inline">\(A\)</span> 沿闭曲线 <span class="math inline">\(C\)</span> 的环量。</p></li>
<li><p><strong>Def</strong>：（势函数、位函数、有势场）</p></li>
<li><p>该结论表明，对于一个连续向量场而言，无旋、保守、有势是等价的。</p></li>
<li><p>势函数的求法</p>
<ul>
<li>用线积分求解</li>
<li>用偏积分求解</li>
<li>用凑全微分法求解</li>
</ul></li>
</ul>
<h3 id="gauss-公式和散度">Gauss 公式和散度</h3>
<ul>
<li><p>Gauss 公式</p>
<ul>
<li><strong>Thm</strong>：（Gauss 公式）<span class="math inline">\(\iiint_{(V)} (\frac{\partial P}{\partial x} +\frac{\partial Q}{\partial y} +\frac{\partial R}{\partial z})\mathrm dV = \iint P \mathrm dy\wedge \mathrm dz +Q\mathrm dz\wedge \mathrm dx+R\mathrm dx\wedge \mathrm dy\)</span></li>
<li><strong>Thm</strong>：（Gauss 公式）<span class="math inline">\(\iiint_{(V)}\nabla \cdot \boldsymbol A \mathrm dV = \iint_{(S)} \boldsymbol A\cdot \mathrm d \boldsymbol S\)</span></li>
</ul></li>
<li><p>通量和通量密度</p>
<ul>
<li><strong>Def</strong>：（通量）<span class="math inline">\(\boldsymbol A(M)\)</span> 对曲面 <span class="math inline">\((S)\)</span> 的第二型面积分 <span class="math inline">\(\iint\limits_{(S)} \boldsymbol A \cdot \mathrm d \boldsymbol S\)</span></li>
</ul></li>
<li><p>散度的定义及其计算</p>
<ul>
<li><strong>Def</strong>：（散度）<span class="math inline">\(\mathrm{div} \boldsymbol A(M) = \lim\limits_{(\Delta V)\rightarrow M}\frac{1}{\Delta V} \iint \boldsymbol A(M)\cdot \mathrm d\boldsymbol S\)</span></li>
<li><strong>Thm</strong>：（散度的计算公式）<span class="math inline">\(\mathrm{div} A = \nabla \cdot \boldsymbol A = \frac{\partial P}{\partial x} +\frac{\partial Q}{\partial y} +\frac{\partial R} {\partial z}\)</span></li>
<li><strong>Inf</strong>：（用散度表示 Gauss 公式）<span class="math inline">\(\iiint\limits_{(V)} \mathrm{div} \mathrm A \mathrm d V = \iint\boldsymbol A\cdot \mathrm d \boldsymbol S\)</span></li>
</ul></li>
<li><p>散度的运算法则和公式</p>
<ul>
<li><span class="math inline">\(\mathrm{div}(C\boldsymbol A) = C\mathrm{div} \boldsymbol A\)</span></li>
<li><span class="math inline">\(\mathrm{div}(\boldsymbol A\pm\boldsymbol B) = \mathrm{div}(\boldsymbol A) \pm \mathrm{div}(\boldsymbol B)\)</span></li>
<li><span class="math inline">\(\mathrm{div}(u\boldsymbol A) = u\mathrm{div} \boldsymbol A + \nabla u \cdot \boldsymbol A\)</span></li>
</ul></li>
</ul>
<h3 id="stokes-公式和旋度">Stokes 公式和旋度</h3>
<ul>
<li><p>Stokes 公式</p>
<ul>
<li><strong>Thm</strong>：（Stokes 公式）<span class="math inline">\(\oint_{(C)} P\mathrm dx + Q\mathrm dy +R\mathrm dz = \iint\limits_{(S)}(\frac{\partial R}{\partial y} -\frac{\partial Q}{\partial z})\mathrm dy\wedge \mathrm dz +(\frac{\partial p}{\partial z}-\frac{\partial R}{\partial x}) \mathrm dz\wedge \mathrm dx + (\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})\mathrm dx\wedge \mathrm dy\)</span></li>
<li><strong>Inf</strong>：（利用 nabla 算子表示的 Stokes 公式）<span class="math inline">\(\oint_{(C)} \boldsymbol A\cdot \mathrm d \boldsymbol s = \iint_{(S)} (\nabla \times \boldsymbol A)\cdot \mathrm d \boldsymbol S = \iint_{(S)} (\nabla \times \boldsymbol A)\cdot \boldsymbol e_n \mathrm dS\)</span></li>
</ul></li>
<li><p>环量和环量密度</p>
<ul>
<li>环量密度 <span class="math inline">\(\lim\limits_{(\Delta )\rightarrow M } \frac {1} {\Delta S}\oint_{(\Delta C)}\boldsymbol A\cdot \mathrm d \boldsymbol s\)</span></li>
</ul></li>
<li><p>旋度的定义及其计算公式</p>
<ul>
<li><strong>Def</strong>：（旋度）<span class="math inline">\(\mathrm{rot} \boldsymbol A\)</span> 用行列式表示</li>
<li><strong>Thm</strong>：（旋度的计算公式）<span class="math inline">\(\oint_{(C)}\boldsymbol A\cdot \mathrm d \boldsymbol s=\iint\limits_{(S)} \mathrm{rot}\boldsymbol A \cdot \mathrm d \boldsymbol S\)</span></li>
</ul></li>
<li><p>旋度的运算法则</p>
<ul>
<li><span class="math inline">\(\mathrm{rot} (C\boldsymbol A) = C\mathrm{rot} \boldsymbol A\)</span></li>
<li>$ (AB) =A B $</li>
<li><span class="math inline">\(\mathrm {rot}(u\boldsymbol A) = u\mathrm{rot} \boldsymbol A +(\nabla u)\times \boldsymbol A\)</span></li>
</ul></li>
</ul>
<h3 id="场的其他计算公式">场的其他计算公式</h3>
<ul>
<li><p><span class="math inline">\(\mathrm{div}(\boldsymbol A\times \boldsymbol B) =\boldsymbol B\cdot \mathrm{rot}\boldsymbol A\)</span></p></li>
<li><p><span class="math inline">\(\mathrm{div}(\mathrm{rot} \boldsymbol A) = 0\)</span></p></li>
<li><p><span class="math inline">\(\mathrm{rot} (\nabla u) = 0\)</span></p></li>
<li><p><span class="math inline">\(\mathrm{div}(\nabla u)=\Delta u\)</span> 其中 $= + + $</p></li>
<li><p><span class="math inline">\(\mathrm{rot}(\mathrm{rot} \boldsymbol A) =\mathbf{grad}(\mathrm{div} A)-\Delta \boldsymbol A\)</span></p></li>
</ul>
<h3 id="几种重要的特殊向量场">几种重要的特殊向量场</h3>
<ul>
<li><p><strong>Def</strong>：一维单连域、二维单连域</p></li>
<li><p>无旋场</p>
<ul>
<li><strong>Def</strong>：（保守场）积分与路径无关</li>
<li><strong>Def</strong>：（无旋场）<span class="math inline">\(\nabla \times \boldsymbol A = \boldsymbol 0\)</span></li>
<li><strong>Def</strong>：（有势场，势函数）<span class="math inline">\(\boldsymbol A = \nabla u\)</span></li>
<li><strong>Thm</strong>：在一维单连域上，<span class="math inline">\(A = (P,Q,R) \in C^{(1)}\)</span>，TFAE
<ul>
<li>无旋场</li>
<li>闭曲线上的环量恒为 0</li>
<li>保守场</li>
<li>有势场</li>
</ul></li>
</ul></li>
<li><p>无源场</p>
<ul>
<li><strong>Def</strong>：（无源场）<span class="math inline">\(\nabla \cdot \boldsymbol A = 0\)</span></li>
<li><strong>Def</strong>：向量管</li>
<li><strong>Thm</strong>：在二维单连域上，<span class="math inline">\(A\in C^{(1)}\)</span>，TFAE
<ul>
<li>无源场</li>
<li><span class="math inline">\(A\)</span> 沿任何一个不子交的闭曲面的通量为零</li>
<li>存在一个向量函数 <span class="math inline">\(\boldsymbol B\)</span> 使得 <span class="math inline">\(\boldsymbol A = \nabla \times \boldsymbol B\)</span></li>
</ul></li>
</ul></li>
<li><p>调和场</p>
<ul>
<li><strong>Def</strong>：（调和场）既无源、也无旋的场</li>
<li>满足 Laplace 方程</li>
<li>满足 Posisson 方程</li>
</ul></li>
</ul>
<!--TODO: 添加外微分形式！！！ -->
<h2 id="补录">补录</h2>
<h3 id="重积分">重积分</h3>
<ul>
<li><p><strong>Def</strong>：（大和，小和）<span class="math inline">\(M_i = \sup\limits_{x\in\Omega_i}\{f(\boldsymbol{x})\},\quad m_i =\inf\limits_{x\in\Omega_i }\{f(\boldsymbol{ x})\}\)</span> <span class="math inline">\(S^+= \sum M_iV_i,S^-=\sum m_iV_i\)</span></p></li>
<li><p><strong>Thm</strong>：TFAE</p>
<ul>
<li>可积</li>
<li>大和与小和差的极限为 0 （ <span class="math inline">\(||\Delta||\rightarrow 0\)</span> ）</li>
<li>振幅充分小</li>
<li>（积分）大和 = （积分）小和</li>
</ul></li>
</ul>
<h3 id="重积分变换">重积分变换</h3>
<ul>
<li><p><strong>Def</strong>：（正则变换）如果一个变换满足</p>
<ol type="1">
<li><span class="math inline">\(T\in C^{(1)}(G)\)</span></li>
<li>单射</li>
<li><span class="math inline">\(\det DT(\boldsymbol u)\neq 0\)</span> 对任一 <span class="math inline">\(\boldsymbol u\)</span>成立</li>
</ol></li>
<li><p><strong>Def</strong>：（重积分的变换公式）若 <span class="math inline">\(G,T\)</span> 满足以下条件之一：</p>
<ol type="1">
<li><span class="math inline">\(G\)</span> 是 <span class="math inline">\(R^m\)</span> 中的开集，<span class="math inline">\(T\)</span> 是正则变换， <span class="math inline">\(\Omega\)</span> 是 <span class="math inline">\(G\)</span> 内的闭可测图形，<span class="math inline">\(f\in C(T(\Omega))\)</span></li>
<li><span class="math inline">\(G\)</span> 同上，<span class="math inline">\(T\in C^1(G)\)</span>，<span class="math inline">\(\Omega \in G\)</span> 是闭可测区域，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的正则变换，<span class="math inline">\(f\in C(T(\Omega))\)</span></li>
</ol>
<p>则：<span class="math inline">\(\int_{T(\varOmega)}f\mathrm dV = \int_\varOmega f\circ T|\det DT|\mathrm dV\)</span></p></li>
</ul>
<h3 id="外微分形式">外微分形式</h3>
<h3 id="场论总结">场论总结</h3>
<ul>
<li><p><strong>Def</strong>：（梯度） <span class="math inline">\(\mathrm{grad} u = \nabla u\)</span>，其中 <span class="math inline">\(\nabla\)</span> 算子为 <span class="math inline">\((\frac{\partial}{\partial x},\frac{\partial}{\partial y},\frac{\partial}{\partial z})\)</span></p></li>
<li><p><strong>Def</strong>：向量线</p></li>
<li><p><strong>Def</strong>：（通量、散度）给定向量场 <span class="math inline">\(F\)</span> 和双侧曲面 <span class="math inline">\(S\)</span></p>
<ul>
<li>通量：<span class="math inline">\(\iint_S \boldsymbol{F}\cdot \mathrm d \boldsymbol{s}\)</span></li>
<li>散度：<span class="math inline">\(\mathrm{div} \boldsymbol{F} = \lim\limits_{S\rightarrow M}\frac{\iint_S \boldsymbol{F}\cdot \mathrm d \boldsymbol{s}}{V} = \nabla \cdot \boldsymbol{F}\)</span></li>
</ul></li>
<li><p><strong>Def</strong>：（环量、旋度）给定向量场和定向曲线</p>
<ul>
<li>环量：<span class="math inline">\(\oint \boldsymbol{F}\cdot \mathrm d \boldsymbol{s}\)</span></li>
<li>方向旋量：<span class="math inline">\(h_n = \mathrm{rot} \boldsymbol{F}\cdot \boldsymbol{n}\)</span></li>
<li>旋度：<span class="math inline">\((\frac{\partial R}{\partial y} -\frac{\partial Q}{\partial z})\boldsymbol{i} +(\frac{\partial p}{\partial z}-\frac{\partial R}{\partial x}) \boldsymbol{j} + (\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})\boldsymbol k\)</span></li>
</ul></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>向量空间</tag>
        <tag>多元函数</tag>
      </tags>
  </entry>
  <entry>
    <title>向量空间与解析几何</title>
    <url>/2020/05/22/study/Math/Advanced-Mathematics/Vectors-and-Analytic-Geometry/</url>
    <content><![CDATA[<p>临近期末，来一波概念回顾。</p>
<span id="more"></span>
<h2 id="向量及其运算">向量及其运算</h2>
<h3 id="向量的概念">向量的概念</h3>
<ul>
<li><strong>Def</strong>：（向量）一个既有大小又有方向的量</li>
<li><strong>Def</strong>：向量的模（或长度），范数 <span class="math inline">\(|a|\)</span>，零向量 <span class="math inline">\(\mathbf 0\)</span>，单位向量</li>
</ul>
<h3 id="向量的线性运算">向量的线性运算</h3>
<ul>
<li>向量的加法和减法
<ul>
<li>交换律</li>
<li>结合律</li>
<li>存在幺元 <span class="math inline">\(\mathbf 0\)</span></li>
<li>存在逆元 <span class="math inline">\(- a\)</span></li>
<li>（模的）三角不等式</li>
</ul></li>
<li>向量的数乘</li>
</ul>
<h3 id="向量的数量积和数量积">向量的数量积和数量积</h3>
<ul>
<li>向量在轴上的投影
<ul>
<li><strong>Def</strong>：向量夹角</li>
<li><strong>Def</strong>：（向量在轴上的投影） <span class="math inline">\((\vec{AB})_l = |\vec{AB}| \cos (\vec {AB}, l)\)</span></li>
</ul></li>
<li>向量的数量积
<ul>
<li><strong>Def</strong>：数量积</li>
<li><strong>Thm</strong>：数量积的性质
<ul>
<li>$ a a = | a|^2$</li>
<li><span class="math inline">\(\cos ( a, b) =\frac{ a \cdot b}{| a|| b|}\)</span></li>
<li>$ a b a b = 0$</li>
<li>交换律、数乘的结合律、分配律</li>
</ul></li>
</ul></li>
<li>向量的向量积
<ul>
<li><strong>Def</strong>：向量积</li>
<li><strong>Thm</strong>：向量积的性质
<ul>
<li>$ a b = 0a b$</li>
<li>反交换律</li>
<li>分配律</li>
<li>数乘的结合律</li>
</ul></li>
</ul></li>
<li>向量的混合积
<ul>
<li><strong>Def</strong>：（混合积）<span class="math inline">\([{abc}] = a \cdot ( b \times c)\)</span></li>
<li>几何意义：是以 <span class="math inline">\({a,b,c}\)</span> 为相邻棱构成的平行六面体的体积</li>
<li><strong>Thm</strong>：混合积的性质
<ul>
<li>$ a, b, c 共面 $</li>
</ul></li>
</ul></li>
</ul>
<h2 id="空间直角坐标系及向量运算的坐标表示">空间直角坐标系及向量运算的坐标表示</h2>
<h3 id="空间直角坐标系">空间直角坐标系</h3>
<ul>
<li>空间直角坐标系的建立：
<ul>
<li><strong>Def</strong>：<strong>坐标轴</strong>、<strong>坐标原点</strong>、<strong>坐标平面</strong>、<strong>卦限</strong></li>
</ul></li>
<li>点的坐标：
<ul>
<li><strong>Def</strong>：<strong>横坐标</strong>、<strong>纵坐标</strong>、<strong>竖坐标</strong></li>
</ul></li>
<li>坐标轴的平移</li>
</ul>
<h3 id="向量的坐标表示">向量的坐标表示</h3>
<ul>
<li>向量的坐标
<ul>
<li><strong>Def</strong>：基向量</li>
<li><strong>Def</strong>：坐标表示式</li>
</ul></li>
<li>向量的模和方向余弦
<ul>
<li><strong>Def</strong>：<span class="math inline">\(a\)</span> 的方向角</li>
<li><strong>Def</strong>：（<span class="math inline">\(a\)</span> 的方向余弦）<span class="math inline">\(\cos \alpha = \frac x {| a|},\cos \beta = \frac y {| a|},\cos \gamma = \frac z {| a|}\)</span></li>
</ul></li>
</ul>
<h3 id="向量运算的坐标表示">向量运算的坐标表示</h3>
<ul>
<li>向量加减法和数乘的坐标表示</li>
<li>数量积的坐标表示</li>
<li>向量积的坐标表示（行列式）</li>
<li>混合积的坐标表示</li>
</ul>
<h2 id="平面与直线">平面与直线</h2>
<h3 id="平面方程">平面方程</h3>
<ol type="1">
<li>点法式方程</li>
<li>一般方程</li>
<li>截距式方程</li>
<li>三点式方程</li>
</ol>
<h3 id="直线方程">直线方程</h3>
<ol type="1">
<li>一般方程（两平面的交）</li>
<li>标准方程</li>
<li>两点式方程</li>
<li>参数方程</li>
<li>向量式方程</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<div class="note"><p>primary</p></div>
<p><strong>夹角</strong></p>
<ol type="1">
<li>直线与直线</li>
<li>直线与平面</li>
<li>平面与平面</li>
</ol>
<!-- TODO: endnote-->
<div class="note"><p>secondary</p></div>
<p><strong>距离</strong></p>
<ol type="1">
<li>点到平面</li>
<li>点到直线 <span class="math inline">\(\displaystyle d = \frac{|\vec{M_0M_1}\times a|}{|a|}\)</span></li>
<li>异面直线的距离 <span class="math inline">\(\displaystyle d = \frac{|[\vec{M_0M_1}a_1a_2]|}{|a_1\times a_2|}\)</span></li>
</ol>
<!-- TODO: endnote-->
<p><strong>直线与平面的交点 %}</strong></p>
<p><strong>过直线的平面束 %}</strong></p>
<h2 id="空间曲面和空间曲线">空间曲面和空间曲线</h2>
<h3 id="球面和柱面">球面和柱面</h3>
<ol type="1">
<li>球面方程</li>
<li>柱面方程</li>
</ol>
<h3 id="空间曲线">空间曲线</h3>
<ol type="1">
<li>一般方程（两个平面的交线）</li>
<li>参数方程</li>
<li><strong>空间曲线在坐标面上的投影</strong></li>
</ol>
<h3 id="锥面">锥面</h3>
<ol type="1">
<li>母线、准线、顶点</li>
<li>如何通过母线、准线、顶点构造</li>
</ol>
<h3 id="旋转曲面">旋转曲面</h3>
<p>如何构造？</p>
<h3 id="几种常见的二次曲面">几种常见的二次曲面</h3>
<div class="note"><p>info</p></div>
<figure>
<img src="https://pic3.zhimg.com/80/v2-2f9167b3a6014ae1db97a646450038e7_720w.jpg" class="lazyload" data-srcset="https://pic3.zhimg.com/80/v2-2f9167b3a6014ae1db97a646450038e7_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="椭圆锥面"><figcaption aria-hidden="true">椭圆锥面</figcaption>
</figure>
<figure>
<img src="https://picb.zhimg.com/80/v2-7fdb424b614f185fd9f5d94d8108297d_720w.jpg" class="lazyload" data-srcset="https://picb.zhimg.com/80/v2-7fdb424b614f185fd9f5d94d8108297d_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="椭球面"><figcaption aria-hidden="true">椭球面</figcaption>
</figure>
<figure>
<img src="https://pic2.zhimg.com/80/v2-1b4cebaa0cf266408ed391542339f705_720w.jpg" class="lazyload" data-srcset="https://pic2.zhimg.com/80/v2-1b4cebaa0cf266408ed391542339f705_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="单叶双曲面"><figcaption aria-hidden="true">单叶双曲面</figcaption>
</figure>
<figure>
<img src="https://pic3.zhimg.com/80/v2-61bc076dab1f7eed8316381a5c65c721_720w.jpg" class="lazyload" data-srcset="https://pic3.zhimg.com/80/v2-61bc076dab1f7eed8316381a5c65c721_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="双叶双曲面"><figcaption aria-hidden="true">双叶双曲面</figcaption>
</figure>
<figure>
<img src="https://pic2.zhimg.com/80/v2-70b021de8960867ee4b4e9c06dcac6cb_720w.jpg" class="lazyload" data-srcset="https://pic2.zhimg.com/80/v2-70b021de8960867ee4b4e9c06dcac6cb_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="椭圆抛物面"><figcaption aria-hidden="true">椭圆抛物面</figcaption>
</figure>
<figure>
<img src="https://pic4.zhimg.com/80/v2-b7c91cce5f10d1ac258a45ae8a204c8e_720w.jpg" class="lazyload" data-srcset="https://pic4.zhimg.com/80/v2-b7c91cce5f10d1ac258a45ae8a204c8e_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="双曲抛物面"><figcaption aria-hidden="true">双曲抛物面</figcaption>
</figure>
<figure>
<img src="https://pic1.zhimg.com/80/v2-b84d818035a2a3654f9937a4d664080d_720w.jpg" class="lazyload" data-srcset="https://pic1.zhimg.com/80/v2-b84d818035a2a3654f9937a4d664080d_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="椭圆柱面"><figcaption aria-hidden="true">椭圆柱面</figcaption>
</figure>
<figure>
<img src="https://pic4.zhimg.com/80/v2-cd0e151a5ccf836a6e9f1edb683b40d5_720w.jpg" class="lazyload" data-srcset="https://pic4.zhimg.com/80/v2-cd0e151a5ccf836a6e9f1edb683b40d5_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="双曲柱面"><figcaption aria-hidden="true">双曲柱面</figcaption>
</figure>
<figure>
<img src="https://pic1.zhimg.com/80/v2-8f6a7089275ec0d89c28fa6a611a2175_720w.jpg" class="lazyload" data-srcset="https://pic1.zhimg.com/80/v2-8f6a7089275ec0d89c28fa6a611a2175_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="抛物柱面"><figcaption aria-hidden="true">抛物柱面</figcaption>
</figure>
<!-- TODO: endnote-->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>向量空间</tag>
        <tag>解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title>最（凸）优化方法 [Overview and Intro]</title>
    <url>/2020/09/26/study/Math/ConvexOptimization/index/</url>
    <content><![CDATA[<p>2020-2021-1 最优化方法</p>
<span id="more"></span>
<h2 id="引言">引言</h2>
<h3 id="数学优化">数学优化</h3>
<p>数学优化问题：（数学规划）</p>
<div class="note"><p>primary</p></div>
<p>从一个<strong>可行解集合</strong>中,<strong>寻找</strong>出<strong>最优</strong>元素。 <!-- TODO: endnote--></p>
<p>数学形式：</p>
<p><span class="math display">\[
\begin{aligned}
    &amp;\min . &amp;f_0(x)\\
    &amp;~\mathrm{s.t.} &amp; f_i(x) \leq b_i, i = 1,\dots,m
\end{aligned}
\]</span></p>
<p>其中：</p>
<ul>
<li>优化变量：<span class="math inline">\(x\)</span></li>
<li>目标函数：<span class="math inline">\(f_0:\mathrm{R}^n\rightarrow\mathrm{R}\)</span></li>
<li>约束函数：<span class="math inline">\(f_i:\mathrm{R}^n\rightarrow\mathrm{R}\)</span></li>
<li>最优解：在<strong>所有满足约束的向量</strong>中，向量 <span class="math inline">\(x^*\)</span> 对应的目标函数值<strong>最小</strong></li>
</ul>
<h3 id="应用">应用</h3>
<ul>
<li>投资组合优化
<ul>
<li>优化变量：各资产分配的资本数</li>
<li>约束：总预算、每⼀份资产的资本范围、最⼩收益</li>
<li>⽬标：总风险或回报</li>
</ul></li>
<li>电⼦设计中的器件尺⼨
<ul>
<li>优化变量：器件的长和宽</li>
<li>约束：⼯程约束、时间要求、最⼤⾯积</li>
<li>⽬标：总功耗</li>
</ul></li>
<li>数据拟合
<ul>
<li>优化变量：模型参数</li>
<li>约束：先验信息、参数限制</li>
<li>⽬标：预测误差</li>
</ul></li>
</ul>
<h3 id="求解优化问题">求解优化问题</h3>
<ul>
<li>一般形式的优化问题
<ul>
<li>难以求解</li>
<li>折中：长时间的计算代价、找不到解</li>
</ul></li>
<li>特定问题
<ul>
<li>最小二乘</li>
<li>线性规划</li>
<li>凸优化问题</li>
</ul></li>
</ul>
<h3 id="最小二乘">最小二乘</h3>
<p>形式：<span class="math inline">\(\displaystyle\min.||Ax-b||_2^2\)</span></p>
<ul>
<li>有解析解 <span class="math inline">\(x* = (A^TA)^{-1}A^Tb\)</span></li>
<li>有可靠的求解算法和软件 <!-- TODO --></li>
<li>计算时间：正比于 <span class="math inline">\(n^2k(A\in \mathrm{R}^{k\times n})\)</span></li>
<li>技术成熟</li>
<li>最⼩⼆乘的使⽤
<ul>
<li>判别⼗分简单</li>
<li>使⽤标准⽅法增强灵活性（加权、正则化）</li>
</ul></li>
</ul>
<h3 id="线性规划问题">线性规划问题</h3>
<p><span class="math display">\[
\begin{aligned}
    &amp;\min. &amp;c^Tx\\
    &amp;\mathrm{~s.t.} &amp;a_i^Tx\le b_i
\end{aligned}
\]</span></p>
<ul>
<li>没有解析解</li>
<li>具有可靠且有效的求解算法和软件</li>
<li>计算时间：正⽐于<span class="math inline">\(n^2m~(if~m \ge n)\)</span>，若具有特殊结构，求解更快。</li>
<li>成熟技术</li>
<li>判别难于最⼩⼆乘</li>
<li>⼀些标准的技巧可⽤于将某些问题转化为线性规划（分段线性⽅程、包含范数的问题）</li>
</ul>
<!-- TODO: ppt p48 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>「凸优化」 引言</title>
    <url>/2021/01/13/study/Math/ConvexOptimization/notes1/</url>
    <content><![CDATA[<p>2020-2021-1 最优化方法</p>
<span id="more"></span>
<h2 id="引言">引言</h2>
<h3 id="数学优化">数学优化</h3>
<p>数学优化问题：（数学规划）</p>
<blockquote>
<p>从一个<strong>可行解集合</strong>中,<strong>寻找</strong>出<strong>最优</strong>元素。</p>
</blockquote>
<p>数学形式：</p>
<p><span class="math display">\[
\begin{aligned}
    &amp;\min . &amp;f_0(x)\\
    &amp;~\mathrm{s.t.} &amp; f_i(x) \leq b_i, i = 1,\dots,m
\end{aligned}
\]</span></p>
<p>其中：</p>
<ul>
<li>优化变量：<span class="math inline">\(x\)</span></li>
<li>目标函数：<span class="math inline">\(f_0:\mathrm{R}^n\rightarrow\mathrm{R}\)</span></li>
<li>约束函数：<span class="math inline">\(f_i:\mathrm{R}^n\rightarrow\mathrm{R}\)</span></li>
<li>最优解：在<strong>所有满足约束的向量</strong>中，向量 <span class="math inline">\(x^*\)</span> 对应的目标函数值<strong>最小</strong></li>
</ul>
<h5 id="应用">应用</h5>
<ul>
<li>投资组合优化
<ul>
<li>优化变量：各资产分配的资本数</li>
<li>约束：总预算、每⼀份资产的资本范围、最⼩收益</li>
<li>⽬标：总风险或回报</li>
</ul></li>
<li>电⼦设计中的器件尺⼨
<ul>
<li>优化变量：器件的长和宽</li>
<li>约束：⼯程约束、时间要求、最⼤⾯积</li>
<li>⽬标：总功耗</li>
</ul></li>
<li>数据拟合
<ul>
<li>优化变量：模型参数</li>
<li>约束：先验信息、参数限制</li>
<li>⽬标：预测误差</li>
</ul></li>
</ul>
<h5 id="求解优化问题">求解优化问题</h5>
<ul>
<li>一般形式的优化问题
<ul>
<li>难以求解</li>
<li>折中：长时间的计算代价、找不到解</li>
</ul></li>
<li>特定问题
<ul>
<li>最小二乘</li>
<li>线性规划</li>
<li>凸优化问题</li>
</ul></li>
</ul>
<h5 id="最小二乘">最小二乘</h5>
<p>形式：<span class="math inline">\(\displaystyle\min.||Ax-b||_2^2\)</span></p>
<ul>
<li>有解析解 <span class="math inline">\(x* = (A^TA)^{-1}A^Tb\)</span></li>
<li>有可靠的求解算法和软件 <!-- TODO --></li>
<li>计算时间：正比于 <span class="math inline">\(n^2k(A\in \mathrm{R}^{k\times n})\)</span></li>
<li>技术成熟</li>
<li>最⼩⼆乘的使⽤
<ul>
<li>判别⼗分简单</li>
<li>使⽤标准⽅法增强灵活性（加权、正则化）</li>
</ul></li>
</ul>
<h5 id="线性规划问题">线性规划问题</h5>
<p><span class="math display">\[
\begin{aligned}
    &amp;\min. &amp;c^Tx\\
    &amp;\mathrm{~s.t.} &amp;a_i^Tx\le b_i
\end{aligned}
\]</span></p>
<ul>
<li>没有解析解</li>
<li>具有可靠且有效的求解算法和软件</li>
<li>计算时间：正⽐于<span class="math inline">\(n^2m~(if~m \ge n)\)</span>，若具有特殊结构，求解更快。</li>
<li>成熟技术</li>
<li>判别难于最⼩⼆乘</li>
<li>⼀些标准的技巧可⽤于将某些问题转化为线性规划（分段线性⽅程、包含范数的问题）</li>
</ul>
<h3 id="凸优化问题">凸优化问题</h3>
<p>$$</p>
<span class="math display">\[\begin{aligned}
    &amp;\mathrm{minimize.}&amp;f_0(x)\\
    &amp;\mathrm{s.t.}     &amp;f_i(x)\le b_i,\quad i = 1,\dots,m
\end{aligned}\]</span>
<p>$$</p>
<ul>
<li>其中：目标函数和约束函数均为凸函数</li>
<li>最⼩⼆乘和线性规划均为特殊的凸优化问题</li>
</ul>
<h5 id="求解">求解</h5>
<ul>
<li>没有解析解</li>
<li>有可靠、有效的算法</li>
<li>计算时间：<span class="math inline">\(O(\max\{n^3, n^2m,F\}\)</span>，<span class="math inline">\(F\)</span>是求函数值、一阶导数、二阶导数的代价</li>
<li>几乎成熟</li>
</ul>
<h5 id="凸优化的使用">凸优化的使用</h5>
<ul>
<li>通常很难判别</li>
<li>具有很多技巧可以将其他问题转化为凸优化形式</li>
<li>很多问题可以通过凸优化进⾏求解</li>
</ul>
<h5 id="example">Example</h5>
<p>在有约束的灯光下获取理想的照明强度</p>
<p><span class="math display">\[
\begin{aligned}
    &amp;\mathrm{minimize.}&amp;\max|\log I_k-\log I_{des}|\\
    &amp;\mathrm{s.t.}     &amp;0\le p_j\le p_{max}\quad i = 1,\dots,m
\end{aligned}
\]</span></p>
<p>通过合理转化：</p>
<ul>
<li>最小二乘</li>
<li>带权重的最小二乘</li>
<li>线性规划</li>
</ul>
<p>都是<strong>近似</strong>解法</p>
<h6 id="用凸优化求解">用凸优化求解</h6>
<p><span class="math display">\[
\begin{aligned}
    &amp;\mathrm{minimize.}&amp;\max h(I_k/I_{des})\\
    &amp;\mathrm{s.t.}     &amp;0\le p_j\le p_{max}\quad i = 1,\dots,m\\
    &amp;h(x)= \max\{u,1/u\}
\end{aligned}
\]</span></p>
<h5 id="非线性规划">非线性规划</h5>
<p>⾮凸的优化问题求解思路 - 局部优化 - 在可⾏解中寻找近似最⼩的点 - 速度快 - 需要初始解 - 不能提供和全局最优解的差距信息 - 全局优化 - 计算时间和问题规模呈指数增长关系 - 上述⽅法⼤多基于求解凸的⼦问题</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>「凸优化」 凸集</title>
    <url>/2021/01/13/study/Math/ConvexOptimization/notes2/</url>
    <content><![CDATA[<p>凸集合</p>
<span id="more"></span>
<h2 id="凸集">凸集</h2>
<ul>
<li>仿射集合</li>
<li>凸集</li>
<li>重要案例</li>
<li>保凸运算</li>
<li>⼴义不等式</li>
<li>分离与⽀撑超平⾯</li>
<li>对偶锥与⼴义不等式</li>
</ul>
<h3 id="仿射集合">仿射集合</h3>
<h4 id="直线方程">直线方程</h4>
<p><strong>Def</strong>（直线方程）<span class="math inline">\(x = \theta x_1 + (1-\theta)x_2\quad(\theta\in \R)\)</span>, equivelant to: <span class="math inline">\(x = x_2+\theta(x_1-x_2)\)</span></p>
<p>线段：<span class="math inline">\(\theta \in [0,1]\)</span></p>
<h4 id="仿射集合的定义">仿射集合的定义</h4>
<p><strong>Def</strong>（仿射集合）<strong>任意</strong>两个点的<strong>直线</strong>仍然在该集合中。即：经过 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的直线所有点：<span class="math inline">\(x=\theta x_1 + (1-\theta)x_2,~\theta \in \R\)</span></p>
<p>如果通过集合 <span class="math inline">\(C\)</span> 中的任意两个不同点的直线仍在集合 <span class="math inline">\(C\)</span> 中，那么称 <span class="math inline">\(C\)</span> 是<strong>仿射</strong>的。</p>
<h5 id="仿射组合">仿射组合</h5>
<p><strong>Def</strong>：（仿射组合）<em>特殊的线性组合</em><span class="math inline">\(\theta_1+\dots+\theta_k=1,~\theta_1x1+\dots+\theta_kx_k\)</span></p>
<ul>
<li><strong>仿射集合</strong>的扩展定义：
<ul>
<li>包含集合中任意点的仿射组合的集合</li>
</ul></li>
</ul>
<h5 id="子空间">子空间</h5>
<p>仿射集合 C 内： <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 则 <span class="math inline">\(\theta x_1 + (1-\theta)x_2\in C\)</span> <strong>Def</strong>（子空间）<span class="math inline">\(V=C-x_0=\{x-x_0|x\in C\}\)</span>：与C相关的子空间</p>
<ul>
<li>子空间对于<span class="math inline">\(\alpha x_1 +\beta x_2\)</span> 中的<span class="math inline">\(\alpha\)</span>，<span class="math inline">\(\beta\)</span>没有约束</li>
<li>经过 <span class="math inline">\(0\)</span></li>
<li>线性代数中子空间的定义 设W为数域F上的n维线性空间V的子集合（即W∈V），若W中的元素满足
<ol type="1">
<li>对加法是封闭</li>
<li>对数乘也是封闭</li>
<li>包含 0</li>
</ol></li>
<li>构造方法： <span class="math inline">\(\alpha(v_1+x_0) + \beta(v_2+x_0) + (1-\alpha - \beta) x_0\in C\)</span></li>
<li>任何仿射集合都可以表示为一个线性方程组的解集</li>
</ul>
<h6 id="线性方程组与仿射集合">线性方程组与仿射集合</h6>
<p>Review: <span class="math inline">\(C=\{x|Ax=b\}\)</span></p>
<ul>
<li><p>线性方程组的解集是仿射集合</p></li>
<li><p>仿射集合可以表示为一个线性方程组的解集</p>
<blockquote>
<p>利用定义证明</p>
</blockquote></li>
<li><p>当然，它的子空间就是：<span class="math inline">\(V = \{x|Ax = 0\}\)</span></p></li>
</ul>
<h5 id="仿射包">仿射包</h5>
<ul>
<li>任意集合<span class="math inline">\(C\)</span>，构造尽可能小的仿射集</li>
<li>仿射包：<span class="math inline">\(\mathrm{aff}~C=\{\theta_1x_1+\dots+\theta_kx_k|x_1, ...,x_k\in C\}\)</span></li>
</ul>
<h5 id="仿射维度与相对内部">仿射维度与相对内部</h5>
<ul>
<li>相对内部：<span class="math inline">\(\mathrm{relint}~C=\{x\in C|B(x,r)\cap \mathrm{aff} C\subseteq C,~for~some~r&gt;0\}\)</span></li>
</ul>
<h3 id="凸集-1">凸集</h3>
<ul>
<li>连接 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的线段上所有的点 <span class="math inline">\(x = \theta x_1 + (1-\theta)x_2,\quad 0\le \theta \le 1\)</span> 仍然在集合中</li>
</ul>
<h4 id="凸组合和凸包">凸组合和凸包</h4>
<ul>
<li>点 <span class="math inline">\(x_1,\dots,x_k\)</span> 的凸组合是满足以下形式的点：
<ul>
<li><span class="math inline">\(x = \sum\theta_i x_i,~\sum \theta_i=1\)</span></li>
</ul></li>
</ul>
<p><strong>Def</strong>（凸包） <span class="math inline">\(\mathrm{conv}~S\)</span> S中所有点的凸组合的集合</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112193144228.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112193144228.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112193144228"><figcaption aria-hidden="true">image-20210112193144228</figcaption>
</figure>
<h4 id="锥">锥</h4>
<ul>
<li>定义：<span class="math inline">\(\forall x \in C\wedge \theta\ge 0, \theta x \in C\)</span></li>
<li>锥组合（非负线性组合）：<span class="math inline">\(x = \theta_1 x_1+\theta_2 x_2\)</span></li>
<li>锥包：集合中所有元素的锥组合的集合
<ul>
<li><span class="math inline">\(\{\theta_1x_1+\cdots+\theta_kx_k|x_i\in C, \theta_i\ge 0, i = 0, 1\dots,k\}\)</span></li>
</ul></li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112193113353.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112193113353.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112193113353"><figcaption aria-hidden="true">image-20210112193113353</figcaption>
</figure>
<h5 id="对比">对比</h5>
<table>
<thead>
<tr class="header">
<th>组合</th>
<th></th>
<th>集合</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>仿射组合</td>
<td><span class="math inline">\(\sum \theta_i = 1\)</span></td>
<td>仿射集</td>
<td>直线</td>
</tr>
<tr class="even">
<td>凸组合</td>
<td><span class="math inline">\(\sum \theta_i = 1, \theta_i \ge 0\)</span></td>
<td>凸集</td>
<td>线段</td>
</tr>
<tr class="odd">
<td>锥组合</td>
<td><span class="math inline">\(\theta_k\ge 0\)</span></td>
<td>凸锥集</td>
<td>射线</td>
</tr>
</tbody>
</table>
<ul>
<li>仿射集合是凸的</li>
<li>考虑<strong>单点集</strong>：<span class="math inline">\(C = \{x\}\)</span>
<ul>
<li>仿射、凸</li>
</ul></li>
</ul>
<h4 id="重要的凸集">重要的凸集</h4>
<ul>
<li><span class="math inline">\(R^n\)</span>空间：仿射、凸、锥</li>
<li><span class="math inline">\(R^n\)</span>的子空间：仿射、凸的</li>
<li>直线：仿射 可能凸</li>
<li>线段 可能是</li>
<li>射线 可能是</li>
</ul>
<h5 id="超平面和半空间">超平面和半空间</h5>
<p><strong>Def</strong>（超平面）<span class="math inline">\(\{x|a^Tx=b\}\quad(a\ne 0)\)</span></p>
<ul>
<li>仿射集合、凸集</li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112193344729.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112193344729.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112193344729"><figcaption aria-hidden="true">image-20210112193344729</figcaption>
</figure>
<p><strong>Def</strong>（半空间）<span class="math inline">\(\{x|a^Tx\le b\}\quad(a\ne 0)\)</span></p>
<ul>
<li>凸集</li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112194043195.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112194043195.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112194043195"><figcaption aria-hidden="true">image-20210112194043195</figcaption>
</figure>
<blockquote>
<p>注意证明方法：利用线性方程组</p>
</blockquote>
<h5 id="球和椭球">球和椭球</h5>
<p><strong>Def</strong>（Euclid 球）<span class="math inline">\(B(x_c,r) = \{x|~\|x-x_c\|_2\le r\}\)</span></p>
<ul>
<li>凸集</li>
<li>注意：所有通过距离定义，满足三角不等式，都构成凸集</li>
</ul>
<p><strong>Def</strong>（椭球）<span class="math inline">\(\{x|(x-x_c)^TP^{-1}(x-x_c) \le 1\}\)</span></p>
<ul>
<li>其中 <span class="math inline">\(P\)</span> 为对称正定矩阵</li>
<li>其他表示：<span class="math inline">\(\{x_c+Au|||u||_2\le1\}\)</span> A 非奇异</li>
</ul>
<h5 id="范数球和范数锥">范数球和范数锥</h5>
<p><strong>Def</strong>（范数）</p>
<p>范数满足</p>
<ol type="1">
<li><span class="math inline">\(\|x\|\ge 0;\|x\|=0~iff~x=0\)</span></li>
<li><span class="math inline">\(\|tx\|=|t|\|x\|\forall t\)</span></li>
<li><span class="math inline">\(\|x+y\|\le \|x\|+\|y\|\)</span></li>
</ol>
<ul>
<li>范数球：<span class="math inline">\(\{x|~\|x-x_c\|\le r\}\)</span></li>
<li>范数锥：<span class="math inline">\(\{(x,t)|~\|x\|\le t\}\)</span></li>
</ul>
<blockquote>
<p>例如：</p>
<ol type="1">
<li>一阶范数：<span class="math inline">\(\sum|x_i|\)</span></li>
<li>二阶范数：<span class="math inline">\(\sqrt{\sum x_i^2}\)</span></li>
</ol>
</blockquote>
<p><strong>Def</strong>（范数球）<span class="math inline">\(x_c\)</span> 为球心，<span class="math inline">\(r\)</span> 为半径。</p>
<p><strong>Def</strong>（范数锥）<span class="math inline">\(\{(x,t)|\|x\|\le t\}\)</span></p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112194656365.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112194656365.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112194656365"><figcaption aria-hidden="true">image-20210112194656365</figcaption>
</figure>
<h5 id="多面体">多面体</h5>
<p><strong>Def</strong>（多面体）有限个线性等式和不等式的解集：<span class="math inline">\(Ax\preceq b,\quad Cx = d\)</span></p>
<ul>
<li><p>考虑仅由不等式组成的情况。</p></li>
<li><p>有限个半空间和超平面的交集</p></li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112195218829.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112195218829.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112195218829"><figcaption aria-hidden="true">image-20210112195218829</figcaption>
</figure>
<h5 id="单纯形">单纯形</h5>
<p><strong>Def</strong>（单纯形）<span class="math inline">\(C=\mathrm{conv}\{v_0,\dots,v_k\}=\{\sum \theta_i v_i|0\preceq \theta,~1^T\theta =1\}\)</span></p>
<blockquote>
<p>求解线性规划问题：<strong>单纯形法</strong> <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/7097864.html#_label3">解析</a></p>
</blockquote>
<ul>
<li>常见的单纯形：单位单纯形、概率单纯形</li>
</ul>
<h5 id="半正定锥">半正定锥</h5>
<ul>
<li><span class="math inline">\(\mathbf{S}^n\)</span>：对称矩阵集合</li>
<li><span class="math inline">\(\mathbf{S}^n_+= \{X\in\mathbf{S}^n|X\succeq 0\}\)</span>：半正定<span class="math inline">\(\lambda_i\ge 0\)</span></li>
<li><span class="math inline">\(\mathbf{S}^n_{++}=\{X\in\mathbf{S}^n|X\succ 0\}\)</span>：正定 <span class="math inline">\(\lambda_i &gt; 0\)</span></li>
</ul>
<blockquote>
<p>n = 2 时：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112195408027.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112195408027.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112195408027"><figcaption aria-hidden="true">image-20210112195408027</figcaption>
</figure>
</blockquote>
<h3 id="保凸运算">保凸运算</h3>
<p>如何确定凸集：</p>
<ol type="1">
<li>定义 <span class="math inline">\(\forall x_1,x_2\in C,0\le \theta\le 1\Rightarrow \theta x_1+(1-\theta)x_2\in C\)</span></li>
<li>保凸运算： 交集、仿射函数、透视函数、线性分式</li>
</ol>
<h4 id="交集">交集</h4>
<p><strong>Thm</strong>：任意数目凸集的交集为凸集</p>
<ul>
<li>包括无穷</li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112195840400.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112195840400.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112195840400"><figcaption aria-hidden="true">image-20210112195840400</figcaption>
</figure>
<h4 id="仿射函数">仿射函数</h4>
<ul>
<li><span class="math inline">\(f(x) = Ax+b\)</span> 其中 <span class="math inline">\(A\in \R^{m\times n},b\in \R^m\)</span></li>
<li>凸集在仿射函数下变为凸集</li>
<li>凸集在仿射函数下的原象为凸集</li>
</ul>
<p>例如：</p>
<ol type="1">
<li>缩放、平移、投影</li>
<li>椭球是球的仿射映射</li>
</ol>
<h4 id="透视函数">透视函数</h4>
<p><strong>Def</strong>（透视函数）</p>
<ul>
<li><span class="math inline">\(P:\R^{n+1}\rightarrow \R^n\)</span></li>
<li><span class="math inline">\(P(x,t) = x/t,\quad\mathbf{dom} P = \{(x,t)|t&gt;0\}\)</span></li>
<li>注意输入输出维度变化</li>
<li>凸集在透视函数下的象和原象为凸集</li>
</ul>
<h4 id="线性分式函数投射函数">线性分式函数（投射函数）</h4>
<ul>
<li><span class="math inline">\(\displaystyle{f(x) = \frac{Ax+b}{c^Tx+d},~where~\mathbf{dom}~f=\{x|c^Tx+d&gt;0\}}\)</span></li>
<li>仿射函数和透视函数的复合函数 <span class="math inline">\(f = P\circ g\)</span></li>
</ul>
<p><span class="math display">\[
g(x) = \left[\begin{matrix}A\\c^T
\end{matrix}\right] x +
\left[\begin{matrix}
  b\\d
\end{matrix}\right]
\]</span></p>
<ul>
<li>凸集在线性分式下的象和原象都是凸集。</li>
</ul>
<p>例如：</p>
<ol type="1">
<li>条件概率</li>
</ol>
<p>又如：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112201048077.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112201048077.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112201048077"><figcaption aria-hidden="true">image-20210112201048077</figcaption>
</figure>
<h3 id="广义不等式">广义不等式</h3>
<blockquote>
<p>建立向量的不等关系</p>
</blockquote>
<p><strong>Def</strong>（正常锥）</p>
<ul>
<li><span class="math inline">\(K\)</span>是闭的（包含边界）</li>
<li><span class="math inline">\(K\)</span>是实的（没有空的内部）</li>
<li><span class="math inline">\(K\)</span>是尖的（不包含直线）</li>
</ul>
<p>例如：</p>
<ol type="1">
<li>非负象限<span class="math inline">\(K = R^n=\{x\in \R^n|x_i\ge 0,~i=1,\dots,n\}\)</span></li>
<li>半正定锥</li>
</ol>
<h4 id="广义不等式定义">广义不等式定义</h4>
<ul>
<li><strong>Def</strong>：<span class="math inline">\(x\preceq_Ky\iff y-x\in K\,\)</span></li>
<li><span class="math inline">\(~x\prec_K y\iff y-x\in \mathbf{int}~K\)</span></li>
<li>例如：
<ul>
<li>分量不等式：<span class="math inline">\(x\prec_{\R^n_+} y\iff x_i\le y_i,~i = 1,...,n\)</span></li>
<li>矩阵不等式：<span class="math inline">\(X\preceq_{\mathrm S^n_+}Y\iff Y-X为半正定\)</span></li>
</ul></li>
<li>偏序、但不满足线序</li>
</ul>
<h5 id="最小极小元">最小、极小元</h5>
<ul>
<li>最小元：<span class="math inline">\(y\in S\Rightarrow x\preceq_Ky\)</span></li>
<li>极小元：<span class="math inline">\(y\in S,~y\preceq_K x\Rightarrow y = x\)</span></li>
</ul>
<p>例如：<span class="math inline">\(x_1\)</span> 为 <span class="math inline">\(S_1\)</span> 最小元，<span class="math inline">\(x_2\)</span> 为 <span class="math inline">\(S_2\)</span> 极小元</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112201529670.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112201529670.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112201529670"><figcaption aria-hidden="true">image-20210112201529670</figcaption>
</figure>
<h4 id="超平面分离定理">超平面分离定理</h4>
<p>若C和D时两个不相交的凸集，则存在：</p>
<p><span class="math inline">\(a\ne 0, a^Tx \le b~for~x\in C,~~a^Tx\ge b~for~x\in D\)</span></p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112201743364.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112201743364.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112201743364"><figcaption aria-hidden="true">image-20210112201743364</figcaption>
</figure>
<h3 id="支撑超平面">支撑超平面</h3>
<p><strong>Def</strong>（支撑超平面）<span class="math inline">\(\forall x\in C,a^Tx\le a^Tx_0 \rightarrow \{x|a^Tx=a^Tx_0\}\)</span></p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112201855548.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes2/image-20210112201855548.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112201855548"><figcaption aria-hidden="true">image-20210112201855548</figcaption>
</figure>
<p><strong>Thm</strong>（支撑超平面存在定理）：若集合 <span class="math inline">\(C\)</span> 为凸集，则在集合 <span class="math inline">\(C\)</span> 的每一个边界点处都存在一个支撑超平面。</p>
<h3 id="对偶锥和广义不等式">对偶锥和广义不等式</h3>
<ul>
<li><span class="math inline">\(K\)</span> 的对偶锥：<span class="math inline">\(K^*=\{y|y^Tx\ge 0,\forall x \in K\}\)</span></li>
<li><span class="math inline">\((K^*)^* = K\)</span></li>
</ul>
<p><strong>Thm</strong>：正常锥的对偶锥为正常锥，可以定义广义不等式： <span class="math display">\[
y\succeq_{K^*}0\iff y^Tx\ge 0\forall x\succeq_{K^*}0
\]</span></p>
<h4 id="对偶不等式的最小和极小元">对偶不等式的最小和极小元</h4>
<p><strong>Def</strong>（最小元）<span class="math inline">\(x\)</span> 为集合 <span class="math inline">\(S\)</span> 的最小元，当且仅当 <span class="math inline">\(\forall \lambda \succ_{K^*}0\)</span>，<span class="math inline">\(x\)</span> 为集合 <span class="math inline">\(S\)</span> 中元素 <span class="math inline">\(z\)</span> 上极小化 <span class="math inline">\(\lambda^T z\)</span> 的唯一最优解</p>
<p><strong>Def</strong>（极小元）对于某些 <span class="math inline">\(\lambda \succ_{K^*}0\)</span>，<span class="math inline">\(x\)</span> 在集合 <span class="math inline">\(S\)</span> 中元素 <span class="math inline">\(z\)</span> 上极小化 <span class="math inline">\(\lambda^Tz\)</span>，则 <span class="math inline">\(x\)</span> 为极小元。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>「凸优化」 凸函数</title>
    <url>/2021/01/13/study/Math/ConvexOptimization/notes3/</url>
    <content><![CDATA[<p>凸函数</p>
<span id="more"></span>
<h2 id="凸函数">凸函数</h2>
<ol type="1">
<li><strong>基本性质和案例</strong></li>
<li><strong>保凸运算</strong></li>
<li><strong>共轭函数</strong></li>
<li><em>拟凸函数</em></li>
<li><em>对数-凹函数和对数-凸函数</em></li>
<li><em>关于广义不等式的凸性</em></li>
</ol>
<h3 id="基本性质和案例">基本性质和案例</h3>
<h4 id="凸函数-1">凸函数</h4>
<ul>
<li><span class="math inline">\(f:\R^n\rightarrow \R\)</span> 为凸函数，则其满足定义域为凸集，且 <span class="math inline">\(f(\theta x+(1-\theta) y)\le \theta f(x) + (1-\theta)f(y), \forall x, y \in \mathrm{dom}~f, 0\le \theta \le 1\)</span></li>
<li>若<span class="math inline">\(f\)</span>为凹函数，则<span class="math inline">\(-f\)</span>为凸函数</li>
<li>仿射函数</li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112203149510.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112203149510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112203149510"><figcaption aria-hidden="true">image-20210112203149510</figcaption>
</figure>
<p><strong>严格凸函数</strong></p>
<ul>
<li><span class="math inline">\(f:\R^n\rightarrow \R\)</span> 为凸函数，则其满足定义域为凸集，且 <span class="math inline">\(f(\theta x+(1-\theta) y) &lt; \theta f(x) + (1-\theta)f(y), \forall x, y \in \mathrm{dom}~f, 0\le \theta \le 1\)</span></li>
</ul>
<h5 id="约束凸函数到直线">约束凸函数到直线</h5>
<p><strong>Thm</strong>：<span class="math inline">\(f:\R^n\rightarrow\R\)</span> 为凸函数<span class="math inline">\(\iff g(t)=f(x+tv)\)</span> 为凸函数，<span class="math inline">\(\forall x\in\mathrm{dom}f,v\in \R^n\)</span></p>
<blockquote>
<p>例如：<span class="math inline">\(f:S^n\rightarrow \R,~where~f(X) = \log\det X,\mathrm{dom} f = S^n_{++}\)</span> 为凹函数</p>
</blockquote>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112203810426.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112203810426.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112203810426"><figcaption aria-hidden="true">image-20210112203810426</figcaption>
</figure>
<h5 id="扩展值延伸">扩展值延伸</h5>
<ul>
<li>用<span class="math inline">\(\tilde f(x) = f(x), x\in \mathrm{dom} , \tilde f(x) = \infty , x\in \mathrm{dom} f\)</span></li>
<li>简化表示<span class="math inline">\(0\le\theta\le 1\Rightarrow \tilde f(\theta x+(1-\theta)y)\le \theta \tilde f(x) + (1-\theta)\tilde sf(y)\)</span></li>
</ul>
<blockquote>
<p>例：凸集的示性函数是凸函数</p>
<ul>
<li><span class="math inline">\(I_c(x)=0~if~x\in C~else~undefined.\)</span></li>
<li><span class="math inline">\(\tilde I_c(x)=0~if~x\in C~else~+\infty.\)</span></li>
</ul>
</blockquote>
<h5 id="一阶条件">一阶条件</h5>
<ul>
<li>函数 <span class="math inline">\(f\)</span> 可微，且满足<span class="math inline">\(f\)</span>的定义域是开集，且梯度：<span class="math inline">\(\nabla f(x)\)</span> 处处存在</li>
</ul>
<p><strong>Thm</strong>（一阶条件）（<strong>定义域为凸集的可微函数</strong>）<span class="math inline">\(f(y) \ge f(x) +\nabla f(x)^T(y-x),~\forall x, y \in \mathrm{dom}~f\)</span> 是 f 为凸函数的充要条件。</p>
<ul>
<li><p>函数 f 的一阶近似表示全局下估计</p></li>
<li><p>一阶条件的证明：<span class="math inline">\(f为凸函数\iff g(t) = f(x+tv)为凸函数\iff g(t)\ge g(\tilde{t})+g(\dot t)(\tilde{t}-t)\iff f(y)\ge f(x) +\nabla f^T(x) (y-x)\)</span></p></li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112204104951.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112204104951.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112204104951"><figcaption aria-hidden="true">image-20210112204104951</figcaption>
</figure>
<h5 id="二阶条件">二阶条件</h5>
<p><strong>Thm</strong>（二阶条件）f 二阶可微，即对于 <span class="math inline">\(\mathrm {dom}~f\)</span> 内的任意一点，Hessian 矩阵存在或 <span class="math inline">\(\nabla^2f\)</span> 存在，且函数定义域是<strong>开集</strong>，则：<span class="math inline">\(f\)</span>是凸函数<span class="math inline">\(\iff\)</span>Hessian矩阵半正定，即 <span class="math inline">\(\forall x \in \mathrm{dom}~f,~\nabla^2f(x)\succeq 0\)</span></p>
<ul>
<li>正定 ==&gt; 严格凸函数（反之不成立）</li>
</ul>
<h5 id="例子">例子</h5>
<p>二次函数：<span class="math inline">\(\displaystyle f(x) = \frac 1 2 x^TPx + q^Tx+r~(with P\in S^n)\)</span> <span class="math display">\[
\begin{aligned}
&amp;\frac{\partial x^TAx}{\partial x} = Ax+A^Tx,\\
&amp;\frac{\partial a^Tx}{\partial x} = a  
\end{aligned}
\]</span></p>
<ul>
<li><p><span class="math inline">\(f(x)=1/x^2\)</span>：注意定义域不是凸集</p></li>
<li><p>仿射函数：<span class="math inline">\(ax+b\)</span></p></li>
<li><p>（指数函数）<span class="math inline">\(e^{ax}\)</span></p></li>
<li><p>（幂函数）<span class="math inline">\(x^a,x\ge 0\)</span></p></li>
<li><p>（绝对值的幂函数）<span class="math inline">\(|x|^p,p\ge1\)</span></p></li>
<li><p>（对数函数「凹函数」）<span class="math inline">\(\log x\)</span>（<span class="math inline">\(\ln x\)</span>）</p></li>
<li><p>（负熵）<span class="math inline">\(x\log x\)</span></p></li>
<li><p>（范数）<span class="math inline">\(R^n\)</span> 中的范数 <span class="math inline">\(P(x)\)</span></p>
<blockquote>
<p>注意：零范数（计算非零元素的数目）——不是范数</p>
</blockquote></li>
<li><p>（极大值函数）<span class="math inline">\(f(x)=\max\{x_1,...,x_n\}\)</span></p></li>
<li><p>（指数和的对数）<span class="math inline">\(f(x)=\log(e^{x_1}+\cdots+e^{x_n})\)</span>（Softmax)</p>
<ul>
<li><span class="math inline">\(\max\{x_1,\dots,x_n\}\le f(x)\le \max\{x_1,\dots,x_n\}\log n\)</span></li>
<li>利用柯西施瓦兹不等式证明：<span class="math inline">\((a^Ta)(b^Tb)\ge (a^Tb)^2\)</span></li>
</ul></li>
<li><p>几何平均函数：<span class="math inline">\(f(x) = (\Pi^{n}_{i=1}x_i)^{(1/n)}\)</span></p></li>
<li><p><span class="math inline">\(f=\log \det X\)</span> 凹函数</p></li>
</ul>
<h3 id="保凸运算">保凸运算</h3>
<h4 id="非负加权求和">非负加权求和</h4>
<p><strong>Def</strong>（非负乘积）<span class="math inline">\(\alpha f\)</span> 不改变凸性</p>
<p><strong>Def</strong>（求和）<span class="math inline">\(+\)</span> 不改变凸性</p>
<p><strong>Def</strong>（非负加权求和）</p>
<ul>
<li><p>可拓展到无限项：<span class="math inline">\(g(x)=\int_A\omega(y)f(x,y)\mathrm dy\)</span></p>
<p>其中，<span class="math inline">\(f(x,y)\)</span> 对集合 A 中的每一个 y，为凸函数</p></li>
</ul>
<h4 id="复合仿射映射">复合仿射映射</h4>
<p><strong>Def</strong>（复合仿射映射）<span class="math inline">\(f\)</span>是凸函数，则<span class="math inline">\(f(Ax+b)\)</span> 是凸函数</p>
<p>例如：</p>
<ol type="1">
<li>线性不等式的对数惩罚函数 <span class="math inline">\(\displaystyle f(x)=-\sum_{i=1}^m\log(b_i-a_i^Tx)\)</span></li>
<li>仿射函数的任意范数</li>
</ol>
<h4 id="逐点最大函数">逐点最大函数</h4>
<p><strong>Def</strong>（逐点最大）<span class="math inline">\(f_i\)</span> 为凸函数，则<span class="math inline">\(f(x) = \max\{ f_1, f_2,...,f_m\}\)</span> 为凸函数</p>
<ul>
<li>分段的线性函数 <span class="math inline">\(f(x)=\max(a_i^Tx+b_i)\)</span>为凸函数</li>
<li>最大 r 个分量之和：<span class="math inline">\(f=\sum_{i=1}^r x_{[i]}\)</span></li>
</ul>
<h4 id="逐点上确界">逐点上确界</h4>
<p><strong>Def</strong>（逐点上确界）若 <span class="math inline">\(f\)</span> 为凸函数，<span class="math inline">\(g(x)=\sup_{y\in A}f(x,y)\)</span> 为凸函数</p>
<p>例如：</p>
<ol type="1">
<li>在集合 C 中距离 <span class="math inline">\(x\)</span> 最远点的距离函数 <span class="math inline">\(f(x)=\sup_{y\in C}\|x-y\|\)</span></li>
<li>对称矩阵的最大特征值 <span class="math inline">\(\lambda_{\max}(X)=\sup_{\|y\|_2=1}y^TXy\)</span></li>
</ol>
<h4 id="函数复合">函数复合</h4>
<p><strong>Thm</strong>：<span class="math inline">\(g:R^n\rightarrow R^k, h:R^k\rightarrow R, f(x) = h(g(x))\)</span></p>
<ul>
<li>h 凸，不减 &amp; g 凸 → f 凸函数</li>
<li>h 凸，不增 &amp; g 凹 → f 凸函数</li>
<li>h 凹，不减（增） &amp; g 凹（凸） → f 凹</li>
</ul>
<p>例如：</p>
<ul>
<li>g 凸函数，则 <span class="math inline">\(\exp g(x)\)</span> 为凸函数</li>
<li>g 为凹函数，且为正，则<span class="math inline">\(\log g(x)\)</span> 为凹函数，<span class="math inline">\(1/g(x)\)</span> 是凸函数</li>
</ul>
<h4 id="最小化">最小化</h4>
<p><strong>Thm</strong>：若 <span class="math inline">\(f(x,y)\)</span> 是关于 <span class="math inline">\((x,y)\)</span> 的凸函数，且集合 <span class="math inline">\(C\)</span> 为凸集。则<span class="math inline">\(g(x)=\inf_{y\in C}f(x,y)\)</span> 是凸函数</p>
<p>例如：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;f(x,y)=x^TAx+2x^TBy+y^TCy\\
&amp;其中\left[\begin{matrix}
A&amp;B\\
B^T&amp;C
\end{matrix}\right]\ge 0,C&gt;0
\end{aligned}
\]</span></p>
<p>则 <span class="math inline">\(g(x)=\inf_{y}f(x,y)=x^T(A-BC^{-1}B^T)x\)</span> 为凸函数</p>
<h4 id="透视函数">透视函数</h4>
<p><strong>Def</strong>（透视函数）函数<span class="math inline">\(f:R^n\rightarrow R\)</span>的透视函数，形如 <span class="math inline">\(g(x,t) = tf(x/t)\)</span> 且 <span class="math inline">\(f\)</span> 为凸函数</p>
<p>例如：</p>
<ol type="1">
<li><p><span class="math inline">\(f(x)=x^Tx,g(x,t)=tf(x/t)\)</span></p></li>
<li><p>相对熵：<span class="math inline">\(\sum u_i\log (u_i/v_i)\)</span></p></li>
<li><p>KL散度：<span class="math inline">\(D_{kl}=\sum(u_i\log(u_i/v_i)-u_i+v_i)\)</span>（比较概率分布差异）</p></li>
</ol>
<h3 id="more">More</h3>
<p>下水平集：</p>
<ul>
<li><span class="math inline">\(f\)</span> 的 <span class="math inline">\(\alpha\)</span>-下水平集 <span class="math inline">\(C_\alpha=\{x\in \mathrm {dom}~f|f(x)\le \alpha\}\)</span></li>
<li>凸函数的所有下水平集都是凸集</li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112212004137.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112212004137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112212004137"><figcaption aria-hidden="true">image-20210112212004137</figcaption>
</figure>
<p>上境图：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112211354752.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112211354752.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112211354752"><figcaption aria-hidden="true">image-20210112211354752</figcaption>
</figure>
<p>共轭函数 <span class="math inline">\(\displaystyle f^*(y)=\sup_{x\in \mathbf{dom}f}*(y^Tx-f(x))\)</span>：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112212840193.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112212840193.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112212840193"><figcaption aria-hidden="true">image-20210112212840193</figcaption>
</figure>
<ul>
<li>可微<span class="math inline">\(f\)</span>的共轭函数<span class="math inline">\(f^*(y)=\sup_{x\in\mathbf{dom}f}(y^Tx-f(x))\)</span> 为凸函数</li>
<li>凸函数<span class="math inline">\(f\)</span>且为闭函数：<span class="math inline">\((f^*)^*=f\)</span></li>
</ul>
<p>例如：</p>
<ol type="1">
<li>负对数 <span class="math inline">\(f(x)=-\log x\)</span></li>
</ol>
<p><span class="math display">\[
\begin{aligned}
f^*(y)&amp;=\sup_{x&gt;0}(xy+\log x)\\
&amp;=\begin{cases}
-1-\log(-y)&amp;y&lt;0\\
\infty&amp;otherwise
\end{cases}
\end{aligned}
\]</span></p>
<h3 id="拟凸函数">拟凸函数</h3>
<p><strong>Def</strong>（拟凸函数）<span class="math inline">\(f\)</span> 为拟凸函数，当其定义域为凸集，且其下水平集对于所有<span class="math inline">\(\alpha\)</span>为凸集。</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213224293.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213224293.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112213224293"><figcaption aria-hidden="true">image-20210112213224293</figcaption>
</figure>
<p>也就是说：<span class="math inline">\(f(\theta x+(1-\theta)y)\le \max\{f(x),f(y)\}\)</span></p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213332290.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213332290.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112213332290"><figcaption aria-hidden="true">image-20210112213332290</figcaption>
</figure>
<p>例如：</p>
<ol type="1">
<li>向量的长度（最后一个⾮零元素的位置）</li>
<li>线性分数函数</li>
</ol>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213408052.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213408052.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112213408052"><figcaption aria-hidden="true">image-20210112213408052</figcaption>
</figure>
<ol start="3" type="1">
<li>向量的零范数（非零元素的个数）</li>
</ol>
<p>拟凸函数的二阶条件：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213609724.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213609724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112213609724"><figcaption aria-hidden="true">image-20210112213609724</figcaption>
</figure>
<h3 id="对数凸函数对数凹函数">对数凸函数、对数凹函数</h3>
<p>例如：</p>
<p>对数凹函数：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213640429.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213640429.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112213640429"><figcaption aria-hidden="true">image-20210112213640429</figcaption>
</figure>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213701936.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes3/image-20210112213701936.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112213701936"><figcaption aria-hidden="true">image-20210112213701936</figcaption>
</figure>
<h3 id="基于广义不等式的凸函数">基于广义不等式的凸函数</h3>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>「凸优化」 凸优化问题</title>
    <url>/2021/01/13/study/Math/ConvexOptimization/notes4/</url>
    <content><![CDATA[<p>凸优化-凸优化问题</p>
<span id="more"></span>
<h2 id="凸优化问题">凸优化问题</h2>
<h3 id="优化问题的标准形式">优化问题的标准形式</h3>
<p><span class="math display">\[
\begin{aligned}
&amp;\min.&amp;f_0(x)\\
&amp;\mathrm{s.t.}&amp;f_i(x)\le 0, i = 1,...,m\\
&amp;&amp;h_i(x) =0
\end{aligned}
\]</span></p>
<p><strong>一些概念</strong>：</p>
<ul>
<li><p><span class="math inline">\(x\in R^n\)</span> 优化变量</p></li>
<li><p><span class="math inline">\(f_0\)</span> 目标函数（代价函数）</p></li>
<li><p><span class="math inline">\(f_i:R^n\rightarrow R\)</span> 不等式约束函数</p></li>
<li><p><span class="math inline">\(h\)</span> 等式约束函数</p></li>
<li><p>优化问题的域：<span class="math inline">\(D=\bigcap \mathbf{dom}~f_i\cap \bigcap \mathbf{dom}h_i\)</span></p></li>
<li><p>可行解集：<span class="math inline">\(x\in D\)</span> 为可行解，且满足所有的不等式约束、等式约束</p></li>
<li><p>最优值：</p>
<ul>
<li><span class="math inline">\(p^*=\inf\{f_0(x)|f_i(x)\le 0, i = 1, ..., m,h_i(x) = 0, i = 1, ... ,p\}\)</span></li>
<li>没有可行解：<span class="math inline">\(p^*=\infin\)</span></li>
<li>若问题没有下界，则：<span class="math inline">\(p^*=\infty\)</span></li>
</ul></li>
<li><p>最优解 <span class="math inline">\(x^*\)</span>：若 <span class="math inline">\(x^*\)</span> 可行，且 <span class="math inline">\(f_0(x^*)=p^*\)</span></p></li>
<li><p>最优解集：<span class="math inline">\(X_{opt}=\{x|f_i(x)\le 0, i = 1,...,m, h_i(x) = 0, i = 1, ..., p, f_0(x)=p^*\}\)</span></p></li>
<li><p><span class="math inline">\(\epsilon-\)</span>次优解集：<span class="math inline">\(\epsilon&gt;0,f_0(x)\le p^*+\epsilon\)</span></p></li>
</ul>
<h4 id="局部最优点"><strong>局部最优点</strong></h4>
<ul>
<li><span class="math inline">\(x\)</span> 为局部最优点，若存在一个正实数 <span class="math inline">\(R\)</span> 使得</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\min.&amp;f_0(z)\\
&amp;\mathrm{s.t.}&amp;f_i(z)\le 0, i = 1,...,m\\
&amp;&amp;h_i(z) =0
&amp;&amp;||z-x||_2\le R
\end{aligned}
\]</span></p>
<p>例如：</p>
<ul>
<li><span class="math inline">\(f(x) = 1/ x, p^* = 0\)</span> 无最优点</li>
<li><span class="math inline">\(f(x) = -\log x, p^*=-\infin\)</span></li>
<li><span class="math inline">\(f(x) = x\log x,p^*=-1/e,x=1/e\)</span></li>
</ul>
<h4 id="不等式约束">不等式约束</h4>
<ul>
<li>活动约束：<span class="math inline">\(f\le 0\)</span></li>
<li>非活动约束：<span class="math inline">\(f&lt;0\)</span></li>
</ul>
<h4 id="等价问题">等价问题</h4>
<p><strong>可行性优化问题的例子</strong>：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214455920.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214455920.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112214455920"><figcaption aria-hidden="true">image-20210112214455920</figcaption>
</figure>
<h5 id="例">例</h5>
<h6 id="盒子约束">盒子约束</h6>
<blockquote>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214557325.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214557325.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112214557325"><figcaption aria-hidden="true">image-20210112214557325</figcaption>
</figure>
<p>转化为</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214603008.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214603008.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112214603008"><figcaption aria-hidden="true">image-20210112214603008</figcaption>
</figure>
</blockquote>
<h6 id="缩放">缩放</h6>
<blockquote>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214818420.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214818420.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112214818420"><figcaption aria-hidden="true">image-20210112214818420</figcaption>
</figure>
<p>转化为</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214824405.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112214824405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112214824405"><figcaption aria-hidden="true">image-20210112214824405</figcaption>
</figure>
</blockquote>
<h5 id="等价问题的解决方法">等价问题的解决方法</h5>
<p>若有： <span class="math display">\[
\begin{aligned}
&amp;\psi_0:R\rightarrow R &amp;单调增\\
&amp;\psi_1,...,\psi_m:R\rightarrow R&amp;\psi_i\le 0\leftrightarrow u\le 0\\
&amp;\psi_{m+1},...,\psi_{m+p}:R\rightarrow R&amp;\psi_{i}(u)=0\leftrightarrow u=0\\
&amp;\tilde f_i(x)=\psi_i(f_i(x)),~\tilde h_i(x)=\psi_{m+i}(h_i(x))
\end{aligned}
\]</span> 则，将：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112220743182.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112220743182.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112220743182"><figcaption aria-hidden="true">image-20210112220743182</figcaption>
</figure>
<p>转化为：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112220750007.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112220750007.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112220750007"><figcaption aria-hidden="true">image-20210112220750007</figcaption>
</figure>
<p>例如：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112220825093.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112220825093.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112220825093"><figcaption aria-hidden="true">image-20210112220825093</figcaption>
</figure>
<p>转化为：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112220834394.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112220834394.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112220834394"><figcaption aria-hidden="true">image-20210112220834394</figcaption>
</figure>
<p>又如：</p>
<ul>
<li><p><span class="math inline">\(\min.||Ax-b||_2\iff\min.||Ax+b||_2^2\)</span></p></li>
<li><p>变量变换：<span class="math inline">\(\tilde{f}_i(z)=f_i(\phi(z)),\tilde{g}_i(z)=h_i(\phi(z))\)</span></p></li>
<li><p>目标函数和约束函数的变换：<span class="math inline">\(\tilde{f}_i(z)=\varPhi_i(f_i(z)),\tilde{g}_i(z)=\varPhi_i(h_i(z))\)</span></p></li>
<li><p>消除线性等式约束：<span class="math inline">\(R(F)=N(A)\)</span></p></li>
</ul>
<h3 id="凸优化问题-1">凸优化问题</h3>
<p><span class="math display">\[
\begin{aligned}
&amp;\min.&amp;f_0(x)\\
&amp;\mathrm{s.t.}&amp;f_i(x)\le 0, i = 1,...,m\\
&amp;&amp;a_i^Tx=b_i
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(f_i\)</span> 为凸函数 <span class="math inline">\((i=1...m)\)</span></li>
</ul>
<h4 id="松弛变量">松弛变量</h4>
<p>例如：</p>
<blockquote>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112221125011.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112221125011.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112221125011"><figcaption aria-hidden="true">image-20210112221125011</figcaption>
</figure>
<p>转化为：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112221134254.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112221134254.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112221134254"><figcaption aria-hidden="true">image-20210112221134254</figcaption>
</figure>
</blockquote>
<h4 id="局部和全局最优解">局部和全局最优解</h4>
<ul>
<li>凸优化问题的任意局部最优解也是全局最优解</li>
</ul>
<p><strong>Thm</strong>（可微函数的最优性准则）<span class="math inline">\(x\)</span>为最优解，iff <span class="math inline">\(x\)</span> 是可行的，且 <span class="math inline">\(\nabla f_0(x)^T(y-x)\ge 0,~\forall y\in D\)</span></p>
<ul>
<li>考虑凸函数的一阶条件</li>
</ul>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112221452875.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112221452875.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112221452875"><figcaption aria-hidden="true">image-20210112221452875</figcaption>
</figure>
<h4 id="线性规划">线性规划</h4>
<h5 id="线性规划问题">线性规划问题</h5>
<p><span class="math display">\[
\begin{aligned}
\min.~c^Tx+d\\
s.t.~Gx\preceq h\\
\qquad Ax=b
\end{aligned}
\]</span></p>
<h5 id="线性分式规划">线性分式规划</h5>
<p><span class="math display">\[
\begin{aligned}
  \min.&amp; f_0(x)&amp;\\
  s.t.&amp; Gx\preceq h\\
  &amp;Ax=b&amp;
\end{aligned}
\]</span></p>
<p>其中 <span class="math display">\[
f_0(x)=\frac{c^Tx+d}{e^Tx+f}
\]</span> 为拟凸优化问题，等价于线性规划</p>
<h5 id="二次规划问题">二次规划问题</h5>
<p><span class="math display">\[
\begin{aligned}
  \min.&amp; \frac{1}{2}x^TPx+q^Tx+r&amp;\\
  s.t.&amp; Gx\preceq h\\
  &amp;Ax=b&amp;
\end{aligned}
\]</span></p>
<h5 id="二次约束二次规划问题">二次约束二次规划问题</h5>
<p><span class="math display">\[
\begin{aligned}
  \min.&amp; \frac{1}{2}x^TPx+q^Tx+r&amp;\\
  s.t.&amp; \frac{1}{2}x^TP_ix+q_i^T+r_i\le 0\\
  &amp;Ax=b&amp;
\end{aligned}
\]</span></p>
<h4 id="广义不等式约束">广义不等式约束</h4>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112225317172.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112225317172.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112225317172"><figcaption aria-hidden="true">image-20210112225317172</figcaption>
</figure>
<p>函数 <span class="math inline">\(f_0:R^n\rightarrow R\)</span> 为凸函数，<span class="math inline">\(f_i:R^n\rightarrow R^{k_i}\)</span> 为 <span class="math inline">\(K_i\)</span> 凸函数。</p>
<p><strong>锥形式问题</strong>：目标函数、约束函数为仿射函数的形式：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233351326.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233351326.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112233351326"><figcaption aria-hidden="true">image-20210112233351326</figcaption>
</figure>
<h5 id="半定规划">半定规划</h5>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233426547.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233426547.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112233426547"><figcaption aria-hidden="true">image-20210112233426547</figcaption>
</figure>
<p>其中不等式约束称为<strong>线性矩阵不等式 (LMI)</strong></p>
<p>带有多个 LMI 约束的问题，等价于单个 LMI</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233546333.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233546333.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112233546333"><figcaption aria-hidden="true">image-20210112233546333</figcaption>
</figure>
<p>例如：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233619761.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233619761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112233619761"><figcaption aria-hidden="true">image-20210112233619761</figcaption>
</figure>
<h5 id="向量优化">向量优化</h5>
<p>通用的向量优化问题：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233724371.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233724371.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112233724371"><figcaption aria-hidden="true">image-20210112233724371</figcaption>
</figure>
<p>目标函数 <span class="math inline">\(f_0\)</span> 指在正常锥下最小化</p>
<p>凸向量优化问题：</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233823612.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112233823612.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112233823612"><figcaption aria-hidden="true">image-20210112233823612</figcaption>
</figure>
<p>其中，<span class="math inline">\(f_0\)</span> 为 K-凸函数，其余为凸函数</p>
<h4 id="最优解和pareto最优解">最优解和Pareto最优解</h4>
<p><strong>Def</strong>（可达目标值集合）<span class="math inline">\(\mathcal O=\{f_0(x)|x~\mathrm{feasible}\}\)</span></p>
<p><strong>Def</strong>（最优解）<span class="math inline">\(x\)</span> 若 <span class="math inline">\(f_0(x)\)</span> 为 <span class="math inline">\(\mathcal O\)</span> 的最小元</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234101894.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234101894.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112234101894"><figcaption aria-hidden="true">image-20210112234101894</figcaption>
</figure>
<p><strong>Def</strong>（Pareto 最优解） <span class="math inline">\(x\)</span> 若 <span class="math inline">\(f_0(x)\)</span> 为 <span class="math inline">\(\mathcal O\)</span> 的极小元</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234110993.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234110993.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112234110993"><figcaption aria-hidden="true">image-20210112234110993</figcaption>
</figure>
<p><strong>Def</strong>（标量化）为了求得 Pareto 最优解，选择 <span class="math inline">\(\lambda \succ_{K^*}0\)</span> 来求解标量问题</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234219344.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234219344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112234219344"><figcaption aria-hidden="true">image-20210112234219344</figcaption>
</figure>
<p>通过变化 <span class="math inline">\(\lambda\succ_{K^*}0\)</span> 来找到所有的Pareto 最优点</p>
<figure>
<img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234255872.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234255872.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112234255872"><figcaption aria-hidden="true">image-20210112234255872</figcaption>
</figure>
<p>例如：正则化最小二乘问题 <span class="math display">\[
\min (w.r.t~R^2_+)\quad(\|Ax-b\|^2_2,\|x\|^2_2)
\]</span> <img src="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234359284.png" class="lazyload" data-srcset="/2021/01/13/study/Math/ConvexOptimization/notes4/image-20210112234359284.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112234359284"></p>
<p>粗线表示 Pareto 最优点</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>「凸优化」 对偶</title>
    <url>/2020/12/26/study/Math/ConvexOptimization/notes5/</url>
    <content><![CDATA[<p>凸优化-对偶</p>
<span id="more"></span>
<h2 id="对偶">对偶</h2>
<h3 id="lagrange-对偶问题">Lagrange 对偶问题</h3>
<h4 id="lagrange-函数">Lagrange 函数</h4>
<p>考虑标准形式的优化问题，拉格朗日函数定义为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;L:R^n\times R^m\times R^p\rightarrow R\\
&amp;L(x, \lambda, \nu)=f_0(x)+\sum_{i=1}^m \lambda_if_i(x)+\sum_{i=1}^p \nu_ih_i(x)\\
\end{aligned}
\]</span></p>
<ul>
<li>定义域为：<span class="math inline">\(D\times R^m\times R^p\)</span></li>
<li>目标函数和约束函数的加权和</li>
<li><span class="math inline">\(\lambda_i\)</span> 为第 i 个不等式约束的<em>拉格朗日乘子</em></li>
<li><span class="math inline">\(\nu_i\)</span> 为第 i 个不等式约束的<em>拉格朗日乘子</em></li>
</ul>
<h4 id="lagrange-对偶函数">Lagrange 对偶函数</h4>
<p><span class="math display">\[
\begin{aligned}
    &amp;g:R^m\times R^p\rightarrow R\\
    &amp;g=\inf_{x\in D} L(x,\lambda, \nu)
\end{aligned}
\]</span></p>
<ul>
<li>函数 <span class="math inline">\(g\)</span> 为凹函数（任何优化问题的 Lagrange 对偶函数为凹函数）
<ul>
<li><span class="math inline">\(\sup L(x,\lambda, \nu)\)</span> 为凸函数</li>
</ul></li>
<li>最优值下界：若 <span class="math inline">\(\lambda \ge 0\)</span>，则 <span class="math inline">\(g(\lambda, \nu)\le p^ *\)</span>（<span class="math inline">\(p^ *\)</span> 为原优化问题最优值）</li>
</ul>
<p><strong>例：线性方程组的最小二乘解</strong> <span class="math display">\[
\begin{aligned}
\min~~&amp;x^Tx\\
s.t.~~&amp;Ax=b
\end{aligned}
\]</span> 下界性质：<span class="math inline">\(p^*\ge -\frac 1 4 \nu^TAA^T\nu-b^T\nu,\quad \forall \nu\)</span></p>
<p><strong>例：标准形式的线性规划</strong></p>
<p>下界性质：<span class="math inline">\(p^*\ge-b^T\nu,\quad if~A^T\nu +c\succeq 0\)</span></p>
<p><strong>例：双向划分问题</strong> <span class="math display">\[
\begin{aligned}
\min~~&amp;x^TWx\\
s.t.~~&amp;x_i^2=1,\quad i = 1,...,n
\end{aligned}
\]</span> 下界性质：<span class="math inline">\(p^*\ge -\mathbf 1^T\nu, \quad if~W+\mathbf{diag}(\nu)\succeq 0\)</span></p>
<h4 id="lagrange-对偶函数与共轭函数">Lagrange 对偶函数与共轭函数</h4>
<p>共轭函数 <span class="math inline">\(f^*=\sup_{x\in D}(y^Tx-f(x))\)</span></p>
<p>而对偶函数满足：</p>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210112235145873.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210112235145873.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112235145873"><figcaption aria-hidden="true">image-20210112235145873</figcaption>
</figure>
<p>若已知共轭函数，可以简化对偶函数的表达</p>
<p>例如：熵的最大化</p>
<h3 id="对偶问题">对偶问题</h3>
<p><span class="math display">\[
\begin{aligned}
    \max~~&amp;g(\lambda,\nu)\\
    s.t.~~&amp;\lambda\succeq 0
\end{aligned}
\]</span></p>
<ul>
<li>凸优化问题的最优值表示为 <span class="math inline">\(d^*\)</span></li>
<li>通过 Lagrange 对偶函数获取 <span class="math inline">\(p^*\)</span> 的最佳下界</li>
<li>凸优化问题：<span class="math inline">\(d^*\le p^*\)</span></li>
</ul>
<p><strong>例：线性规划</strong> <span class="math display">\[
\begin{aligned}
\min.&amp;c^Tx\\
s.t.&amp;Ax=b\\&amp;x\succeq 0
\end{aligned}
\]</span></p>
<p>对偶问题为：</p>
<p><span class="math display">\[
\begin{aligned}
  \max.&amp;-b^Tv\\
  s.t.&amp;A^Tv+c\succeq0
\end{aligned}
\]</span></p>
<blockquote>
<p><em>对于一个线性规划问题，其对偶问题也是线性规划问题</em></p>
</blockquote>
<h3 id="弱对偶与强对偶">弱对偶与强对偶</h3>
<p><strong>Thm</strong>（弱对偶）对于凸优化和非凸优化都有：<span class="math inline">\(d^*\le p^*\)</span></p>
<ul>
<li>可以⽤来寻找困难问题的⾮平凡下界</li>
</ul>
<p><strong>Thm</strong>（强对偶）对偶间隙 <span class="math inline">\(p^*-d^* =0\)</span></p>
<ul>
<li>并非总是满足，但在凸优化问题中常常满足</li>
</ul>
<p>凸优化问题中保证强对偶的条件称为<strong>约束准则</strong>。</p>
<h3 id="几何解释">几何解释</h3>
<p>考虑只有一个约束 <span class="math inline">\(f_1(0)\le 0\)</span> 的问题</p>
<p>定义集合：<span class="math inline">\(G=\{(f_0(x),f_1(x)|x\in D\}\)</span></p>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210112235935306.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210112235935306.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210112235935306"><figcaption aria-hidden="true">image-20210112235935306</figcaption>
</figure>
<p>如果是凸的：</p>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113000037678.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113000037678.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210113000037678"><figcaption aria-hidden="true">image-20210113000037678</figcaption>
</figure>
<h3 id="最优性条件">最优性条件</h3>
<p><strong>Def</strong>（相对内部）<span class="math inline">\(\mathrm{Rel~int}~D=\{x\in D|B(x,r)\cap\mathrm{aff~}D\sub D,\exist r&gt;0\}\)</span></p>
<h4 id="slater-约束准则">Slater 约束准则</h4>
<p><strong>Thm</strong>：若某个凸优化问题中，存在一点 <span class="math inline">\(x\in \mathrm{relint}~D=\{x\in D|B(x,r)\cap \mathrm{aff}D\subset D\}\)</span> 使得该问题是<strong>严格可行</strong>的（<span class="math inline">\(x\in relint~D,f_i(x)&lt;0,Ax=b\)</span>）则为强对偶问题。</p>
<p>弱化后：若不等式约束时仿射的，只要可行域非空，则必有<span class="math inline">\(d^*=p^*\)</span></p>
<h4 id="kkt-最优性条件">KKT 最优性条件</h4>
<h5 id="kkt-条件">KKT 条件</h5>
<p>一般可微优化问题，对偶间隙为 0 需要满足 KKT 条件，包含以下四个部分：</p>
<ol type="1">
<li>（互补松弛性）<span class="math inline">\(\lambda^*_if_i(x^*)=0\)</span></li>
<li>（原始可行性）<span class="math inline">\(f_i(x)\le 0, h_i(x)=0\)</span></li>
<li>（对偶可行性）<span class="math inline">\(\lambda_i\ge 0\)</span></li>
<li>（稳定性条件）<span class="math inline">\(\displaystyle\frac{\partial}{\partial x}L(x,\lambda,\nu)=0\)</span></li>
</ol>
<p><strong>例：注水</strong></p>
<h5 id="互补松弛性">互补松弛性</h5>
<p>若对偶问题满足 <span class="math inline">\(p^*=d^*\)</span> 且所有函数可微，则最优解满足： <span class="math display">\[
\lambda_i^*f_i(x^*)=0
\]</span></p>
<h5 id="稳定性">稳定性</h5>
<p><span class="math display">\[
\inf L=L(x^*,\lambda^*,\nu^*)
\]</span></p>
<p>则： <span class="math display">\[
\frac{\partial L(x,\lambda^*,\nu^*)}{\partial x}|_{x=x^*}=0
\]</span></p>
<h5 id="对偶问题重形式化">对偶、问题重形式化</h5>
<p>常用方法：</p>
<ol type="1">
<li>引入新的变量和对应的约束</li>
<li>将显示约束转换为隐式表达（反之亦然）</li>
<li>变换目标或约束函数变换</li>
</ol>
<h6 id="引入新的变量和对应的约束">引入新的变量和对应的约束</h6>
<p>例如：<span class="math inline">\(\min~~f_0(Ax+b)\)</span></p>
<p>对偶问题：<span class="math inline">\(g=\inf_xf_0(Ax+b)=p^*\)</span></p>
<p>重形式化后： <span class="math display">\[
\begin{aligned}
\min~~&amp;f_0(y)&amp;\\
s.t.~~&amp;Ax+b-y=0&amp;\\
\rightarrow~~ &amp;g(\nu)=
\begin{cases}
-f_0^*(\nu)+b^T\nu &amp;A^T\nu = 0\\
-\infty&amp;otherwise
\end{cases}
\end{aligned}
\]</span> 例：范数逼近问题 <span class="math display">\[
\begin{aligned}
\min~~&amp;\|Ax-b\|\\
\rightarrow\min~~&amp;\|y\|\\
s.t.~~&amp;y=Ax-b
\end{aligned}
\]</span></p>
<h6 id="隐式约束">隐式约束</h6>
<p>例如：带框的线性规划</p>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113091100433.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113091100433.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210113091100433"><figcaption aria-hidden="true">image-20210113091100433</figcaption>
</figure>
<h3 id="扰动灵敏度分析">扰动、灵敏度分析</h3>
<p>优化问题及其对偶问题的形式为：</p>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113091241349.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113091241349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210113091241349"><figcaption aria-hidden="true">image-20210113091241349</figcaption>
</figure>
<p>则其扰动问题及其对偶</p>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113091257572.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113091257572.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210113091257572"><figcaption aria-hidden="true">image-20210113091257572</figcaption>
</figure>
<p>其中，<span class="math inline">\(x\)</span> 为原问题的优化变量，<span class="math inline">\(u,~v\)</span> 为参数</p>
<p>得到的 <span class="math inline">\(p^*(u,v)\)</span> 为最优值，是 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 的函数</p>
<h4 id="扰动问题的性质">扰动问题的性质</h4>
<p><strong>Thm</strong>：若原问题是凸的，则 <span class="math inline">\(p^*(u,v)\)</span> 是凸函数</p>
<p><strong>Thm</strong>：若原问题为凸，且对偶间隙为 0，<span class="math inline">\(\lambda^*,w^*\)</span> 为原问题的最优解，则：<span class="math inline">\(p^*(u,v)\ge p^*(0,0)-\lambda^{*T}u-w^{*T}v\)</span></p>
<h4 id="灵敏度分析">灵敏度分析</h4>
<p><span class="math inline">\(p^*(u,v)\ge p^*(0,0)-\lambda^{*T}u-w^{*T}v\)</span></p>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113091841863.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113091841863.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210113091841863"><figcaption aria-hidden="true">image-20210113091841863</figcaption>
</figure>
<h5 id="局部灵敏度分析">局部灵敏度分析</h5>
<p><strong>Thm</strong>：若原问题是凸的，且强对偶性成立， <span class="math inline">\(p^*(u,v)\)</span> 在 <span class="math inline">\((0,0)\)</span> 可微，则有 <span class="math display">\[
\lambda_i^*=-\frac{\partial p^*(0,0)}{\partial u_i},\quad \nu_i^*=-\frac{\partial p^*(0,0)}{\partial v_i}
\]</span> <img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113092052504.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113092052504.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210113092052504"></p>
<h3 id="广义不等式">广义不等式</h3>
<blockquote>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113092110526.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113092110526.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210113092110526"><figcaption aria-hidden="true">image-20210113092110526</figcaption>
</figure>
</blockquote>
<ul>
<li>不等式约束的 Lagrange 乘子为向量 <span class="math inline">\(\lambda_i\in R^{k_i}\)</span></li>
<li>拉格朗日函数为：<span class="math inline">\(L=f_0(x)+\sum_{i=1}^m\lambda_i^Tf_i(x)+\sum_{i=1}^p\nu_ih_i(x)\)</span></li>
</ul>
<p><strong>Thm</strong>（下界性质）若 <span class="math inline">\(\lambda_i\succeq_{K_i^*}0\)</span> 则 <span class="math inline">\(g\le p^*\)</span></p>
<p><strong>例：半定规划</strong></p>
<blockquote>
<figure>
<img src="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113092457953.png" class="lazyload" data-srcset="/2020/12/26/study/Math/ConvexOptimization/notes5/image-20210113092457953.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210113092457953"><figcaption aria-hidden="true">image-20210113092457953</figcaption>
</figure>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉图和哈密顿图</title>
    <url>/2020/06/25/study/Math/DiscreteMath/EulerHarmiltonGraph/</url>
    <content><![CDATA[<!-- TODO: -->
<span id="more"></span>
<h2 id="欧拉图">欧拉图</h2>
<p><strong>Def</strong>：</p>
<ul>
<li>（欧拉通路）经过图中所有边一次且仅一次的通路</li>
<li>（欧拉回路）经过图中所有边一次且仅一次的回路</li>
<li>（欧拉图）有欧拉回路</li>
<li>（半欧拉图）有欧拉通路</li>
</ul>
<p><strong>Thm</strong>：无向图 G 是欧拉图，当且仅当其<strong>连通</strong>且<strong>没有奇度顶点</strong>。</p>
<p><strong>Thm</strong>：无向图 G 是半欧拉图，当且仅当其<strong>连通</strong>且<strong>恰有两个奇度顶点</strong>。</p>
<p><strong>Thm</strong>：有向图 D 是欧拉图，当且仅当其是<strong>强连通</strong>的且每个顶点的<strong>出度等于入度</strong>。</p>
<p><strong>Thm</strong>：有向图 D 是半欧拉图，当且仅当其是<strong>单向连通</strong>的且有两个奇度顶点，一个入度比出度大 1，一个入度比出度小 1，其余每个顶点的<strong>出度等于入度</strong>。</p>
<p><strong>Thm</strong>：G 是非平凡的欧拉图，当且仅当 G 是连通的且为几个不重合的圈的并</p>
<div class="note"><p>primary</p></div>
<p><strong>Fleury Alg （求欧拉回路）</strong></p>
<ol type="1">
<li>任取 <span class="math inline">\(v_0\in V(G)\)</span>，令 <span class="math inline">\(P_0=v_0\)</span></li>
<li>设 <span class="math inline">\(P_i = v_0e_1\dots e_i v_i\)</span>，若 <span class="math inline">\(E(G) - \{e_1,e_2,\dots,e_i\}\)</span>中没有与 <span class="math inline">\(v_i\)</span> 关联的边，则停止，否则按以下条件选下一条边：
<ol type="1">
<li><span class="math inline">\(e_{i+1}\)</span> 与 <span class="math inline">\(v_i\)</span> 关联</li>
<li>优先选：<span class="math inline">\(e_{i+1}\)</span> 不是 <span class="math inline">\(G-\{e_1,\dots,e_i\}\)</span> 中的桥</li>
</ol></li>
</ol>
<!-- TODO: endnote-->
<h2 id="哈密顿图">哈密顿图</h2>
<p><strong>Def</strong>：</p>
<ul>
<li>（哈密顿通路）经过图中所有点一次且仅一次的通路</li>
<li>（哈密顿回路）经过图中所有点一次且仅一次的回路</li>
<li>（哈密顿图）有哈密顿回路</li>
<li>（半哈密顿图）有哈密顿通路</li>
</ul>
<p><strong>Thm</strong>：G 是哈密顿图，则<span class="math inline">\(\forall (V_1 \in V\wedge v_1\neq\emptyset)\quad p(G-V_1) \le |V_1|\)</span></p>
<p><strong>Thm</strong>：G 是半哈密顿图，则<span class="math inline">\(\forall (V_1 \in V\wedge v_1\neq\emptyset)\quad p(G-V_1) \le |V_1|+1\)</span></p>
<p><strong>Thm</strong>：<span class="math inline">\(\forall v_i,v_j\)</span> 不相邻，则 <span class="math inline">\(d(v_i)+d(v_j)\ge n-1\)</span>，则有哈密顿通路</p>
<p><strong>Thm</strong>：<span class="math inline">\(\forall v_i,v_j\)</span> 不相邻，则 <span class="math inline">\(d(v_i)+d(v_j)\ge n\)</span>，则有哈密顿回路</p>
<p><strong>Thm</strong>：若 <span class="math inline">\(u,v\)</span> 是 n 阶无向简单图的两个不相邻的顶点，且 <span class="math inline">\(d(u)+d(v)\ge n\)</span> 则 <span class="math inline">\(G\)</span> 是哈密顿图当且仅当 <span class="math inline">\(G\cup (u,v)\)</span> 时哈密顿图。</p>
<p><strong>Thm</strong>：若 <span class="math inline">\(D\)</span> 是竞赛图，则其中有哈密顿通路</p>
<h2 id="最短路问题">最短路问题</h2>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>图的基本概念</title>
    <url>/2020/05/28/study/Math/DiscreteMath/GraphTheory/</url>
    <content><![CDATA[<p>图论的基本概念和定理，真的炒鸡多呀。</p>
<p>（没错，组合数学部分咕了！<sub>超小声</sub>）</p>
<span id="more"></span>
<h2 id="图的基本概念">图的基本概念</h2>
<p><strong>Def</strong>：（无向图）一个<strong>无向图</strong> <span class="math inline">\(G\)</span> 是一个有序的二元组 <span class="math inline">\(&lt; V,E &gt;\)</span> 其中：</p>
<ol type="1">
<li><span class="math inline">\(V\)</span> 是一个非空的有穷集，称作顶点集。其元素称作<strong>顶点</strong>或<strong>结点</strong></li>
<li><span class="math inline">\(E\)</span> 是无序积 <span class="math inline">\(V\&amp;V\)</span>的有穷多重子集，称作<strong>边集</strong>，其中的元素称为<strong>无向边</strong>，简称为<strong>边</strong></li>
</ol>
<p><strong>Def</strong>：（有向图）一个<strong>有向图</strong> <span class="math inline">\(G\)</span> 是一个有序的二元组 <span class="math inline">\(&lt; V,E &gt;\)</span> 其中：</p>
<ol type="1">
<li><span class="math inline">\(V\)</span> 是一个非空的有穷集，称作顶点集。其元素称作<strong>顶点</strong>或<strong>结点</strong></li>
<li><span class="math inline">\(E\)</span> 是无序积 <span class="math inline">\(V\times V\)</span>的有穷多重子集，称作<strong>边集</strong>，其中的元素称为<strong>有向边</strong>，简称为<strong>边</strong></li>
</ol>
<div class="note"><p>primary</p></div>
<p><strong>基本概念</strong></p>
<ul>
<li><strong>无向图</strong>和<strong>有向图</strong>统称为<strong>图</strong>，通常用 <span class="math inline">\(G\)</span> 表示无向图，用 <span class="math inline">\(D\)</span> 表示有向图</li>
<li>图的顶点数称为这个图的<strong>阶</strong>，因而也有 <strong>n 阶图</strong></li>
<li>一条边也没有的图称为<strong>零图</strong>，n 阶的零图记作 <span class="math inline">\(N_n\)</span>，1 阶的零图称作平凡图 <em>注：零图不是没有顶点的图</em></li>
<li>图的定义中规定顶点集 <span class="math inline">\(V\)</span> 为非空集合，但是我们也定义<strong>空图</strong>为一个没有顶点的图，记作 <span class="math inline">\(\emptyset\)</span>，方便我们的计算</li>
<li>在用图形表示图时，如果给每一个顶点和每一条边都指定一个特定的符号（字母或数字）则称这样的图为<strong>标定图</strong>，否则称作<strong>非标定图</strong></li>
<li>将有向图中的所有边，改为无向边之后得到的无向图称作这个有向图的<strong>基图</strong></li>
<li>在无向图中，若有 <span class="math inline">\(e_k=(v_i,v_j)\in E\)</span> 则称 <span class="math inline">\(v_i,v_j\)</span> 为 <span class="math inline">\(e_k\)</span>的<strong>端点</strong>，<span class="math inline">\(e_k\)</span> 与 <span class="math inline">\(v_i,v_j\)</span> <strong>关联</strong>，并且称 <span class="math inline">\(e_k\)</span> 与 <span class="math inline">\(v_i,v_j\)</span> 的<strong>关联次数</strong>为 1，若 <span class="math inline">\(i = j\)</span> 则称<span class="math inline">\(e_k\)</span> 与这个顶点的关联次数为 2，并称 <span class="math inline">\(e_k\)</span> 为<strong>环</strong>，如果顶点 <span class="math inline">\(v\)</span> 不与 <span class="math inline">\(e_k\)</span> 关联，则称 <span class="math inline">\(e_k\)</span> 与 <span class="math inline">\(v\)</span> 的关联次数为 0。 与此同时，若两个顶点之间有一条边连接，则称这两个顶点<strong>相邻</strong>，若两条边至少有一个公共端点，则称这两条边<strong>相邻</strong></li>
<li>在有向图中，若有 <span class="math inline">\(e_k=&lt; v_i,v_j &gt;\in E\)</span> 称 <span class="math inline">\(v_i\)</span> 为<strong>始点</strong>，<span class="math inline">\(v_j\)</span> 为<strong>终点</strong>，都是<strong>端点</strong>，并称 <span class="math inline">\(e_k\)</span> 与 <span class="math inline">\(v_i,v_j\)</span> <strong>关联</strong>。其中若 <span class="math inline">\(i=j\)</span> 则称 <span class="math inline">\(e_k\)</span> 是<strong>环</strong>。 同时：两个顶点之间为一条有向边，则称这两个顶点<strong>相邻</strong>，若两条边中的一条边的终点是另一条边的始点，则称两条边<strong>相邻</strong></li>
<li>图中没有边相关联的顶点称为<strong>孤立点</strong></li>
<li>在无向图中我们称：
<ul>
<li><span class="math inline">\(N_G(v)=\{u|u\in V\wedge (u,v)\in E\wedge u\neq v\}\)</span> 为 <span class="math inline">\(v\)</span> 的<strong>邻域</strong></li>
<li><span class="math inline">\(\overline N_G(v) = N_G(v)\cup\{v\}\)</span> 称为 <span class="math inline">\(v\)</span> 的<strong>闭邻域</strong></li>
<li><span class="math inline">\(I_G(v) = \{e|e\in E\wedge e与v关联\}\)</span> 称为 <span class="math inline">\(v\)</span> 的<strong>关联集</strong></li>
</ul></li>
<li>在有向图中我们称：
<ul>
<li><span class="math inline">\(\Gamma^+_D(v) =\{u|u\in V\wedge &lt; v,u &gt;\in E\wedge u \neq v\}\)</span> 为 <span class="math inline">\(v\)</span> 的<strong>后继元集</strong></li>
<li><span class="math inline">\(\Gamma^-_D(v) = \{u| u\in V \wedge &lt; u,v &gt; \in E\wedge u\neq v\}\)</span> 为 <span class="math inline">\(v\)</span> 的<strong>先驱元集</strong></li>
<li><span class="math inline">\(N_D(v) = \Gamma^+\cup\Gamma^-\)</span> 为 <span class="math inline">\(v\)</span> 的<strong>邻域</strong></li>
<li><span class="math inline">\(\overline N_D=N_D\cup\{v\}\)</span> 为 <span class="math inline">\(v\)</span> 的<strong>闭邻域</strong></li>
</ul></li>
</ul>
<!-- TODO: endnote-->
<p><strong>Def</strong>：（平行边）在无向图中，如果关联一对顶点的无向边多于一条，则称为<strong>平行边</strong>，平行边的条数称为<strong>重数</strong>，在邮箱图中，如果关联一对顶点的有向边多于 1 条，并且这些边的终点始点相同，则称为<strong>平行边</strong>，含有平行边的图称作<strong>多重图</strong>，不含平行边、也不含自环的图称为<strong>简单图</strong></p>
<p><strong>Def</strong>：（出度、入度、度数）设 <span class="math inline">\(G=&lt; V,E &gt;\)</span> 为无向图，<span class="math inline">\(\forall v\in V\)</span> 称 <span class="math inline">\(v\)</span> 为边的端点的次数为 <span class="math inline">\(v\)</span> 的次数为 <span class="math inline">\(v\)</span> 的<strong>度数</strong>，相同的定义有向图上的<strong>入度</strong>，<strong>出度</strong>，<strong>度数</strong></p>
<div class="note"><p>primary</p></div>
<p>一些定义</p>
<p>无向图中：</p>
<ul>
<li>最大度 <span class="math inline">\(\Delta(G) = \max\{d(v)|v\in V(G)\}\)</span></li>
<li>最小度 <span class="math inline">\(\delta(G) = \min\{d(v)|v\in V(G)\}\)</span></li>
</ul>
<p>类似的定义，在有向图中：</p>
<ul>
<li>最大度 <span class="math inline">\(\Delta(G) = \max\{d(v)|v\in V(G)\}\)</span></li>
<li>最小度 <span class="math inline">\(\delta(G) = \min\{d(v)|v\in V(G)\}\)</span></li>
<li>最大出度 <span class="math inline">\(\Delta^+(G)\)</span></li>
<li>最小出度 <span class="math inline">\(\delta^+(G)\)</span></li>
<li>最大入度 <span class="math inline">\(\Delta^-(G)\)</span></li>
<li>最小入度 <span class="math inline">\(\delta^-(G)\)</span></li>
</ul>
<p>此外，我们将<strong>度数</strong>为 1 的顶点称为<strong>悬挂顶点</strong>，相关联的边称为<strong>悬挂边</strong>。</p>
<p>当然，有<strong>奇度节点</strong>，<strong>偶度节点</strong></p>
<!-- TODO: endnote-->
<h3 id="握手定理">握手定理</h3>
<p><strong>Thm</strong>：（握手定理）</p>
<ol type="1">
<li>在任何无向图中，所有顶点的度数之和等于边数两倍</li>
<li>在任何有向图中，所有顶点的度数之和等于变数的两倍，所有顶点的入度之和等于所有顶点的出度之和，等于边数</li>
</ol>
<p><strong>Inf</strong>：在任何图中，奇度顶点的个数是偶数</p>
<h3 id="度数列图化">度数列、图化</h3>
<p><strong>Def</strong>：（有向图和无向图的）度数列，（有向图）入度列，出度列</p>
<p><strong>Def</strong>：可图化的（可简单图化的）度数列</p>
<p><strong>Thm</strong>：非负整数列 <span class="math inline">\(d = (d_1,d_2,\dots,d_n)\)</span> 是可图化的当且仅当 <span class="math inline">\(\sum d_i\)</span> 为偶数</p>
<blockquote>
<p>Proof：用握手定理证明其必要性，用构造法证明其充分性</p>
</blockquote>
<p><strong>Thm</strong>：设 <span class="math inline">\(G\)</span> 是任意 <span class="math inline">\(n\)</span> 阶无向简单图，则 <span class="math inline">\(\Delta (G) \le n-1\)</span></p>
<h3 id="同构">同构</h3>
<p><strong>Def</strong>：（同构）若存在双射函数 <span class="math inline">\(f:V_1\rightarrow V_2\)</span> 使得 <span class="math inline">\(\forall v_i,v_j\in V_1,(v_i,v_j)\in E_1\iff (f(v_i),f(v_j))\in E_2\)</span> 且对应边的重数相同，则称 <span class="math inline">\(G_1\)</span> 与 <span class="math inline">\(G_2\)</span> 同构，记作 <span class="math inline">\(\approxeq\)</span></p>
<div class="note"><p>primary</p></div>
<p><strong>彼得松图</strong></p>
<p><strong>Def</strong>：彼得松图</p>
<img src="/2020/05/28/study/Math/DiscreteMath/GraphTheory/Peterson.png" class="lazyload" data-srcset="/2020/05/28/study/Math/DiscreteMath/GraphTheory/Peterson.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" class title="彼得松图">
<!-- TODO: endnote-->
<h3 id="完全图">完全图</h3>
<p><strong>Def</strong>：（完全图）若无向图 <span class="math inline">\(G\)</span> 中的每一个顶点都和其余顶点相邻，则称 <span class="math inline">\(G\)</span> 为<strong>无向完全图</strong></p>
<p><strong>Def</strong>：（正则图）若无向图 <span class="math inline">\(G\)</span> 中的每一个顶点 <span class="math inline">\(d(v) = k\)</span> 则称该图为<strong>k-正则图</strong></p>
<h3 id="子图母图补图">子图、母图、补图</h3>
<p><strong>Def</strong>：（母图）若 <span class="math inline">\(V&#39;\subseteq V,E&#39;\subseteq E\)</span> 则称 <span class="math inline">\(G\)</span> 是 <span class="math inline">\(G&#39;\)</span> 的母图</p>
<p><strong>Def</strong>：（导出的子图 <span class="math inline">\(G[V&#39;],G[E&#39;]\)</span>）设 <span class="math inline">\(V&#39; \subseteq V,V&#39;\neq \emptyset\)</span>，选择 <span class="math inline">\(G\)</span> 中两个顶点都在 <span class="math inline">\(V&#39;\)</span> 中的顶点构成的边组成的边集 <span class="math inline">\(E&#39;\)</span> 作为边集，构成的图；相似定义用边集构造的导出的子图</p>
<p><strong>Def</strong>：（补图）若<span class="math inline">\(\overline E=\{(u,v)|u,v\in V, u\neq v,(u,v)\notin E\}\)</span> 构成的图 <span class="math inline">\(\overline G\)</span></p>
<p><strong>自补图</strong>：与自身的补图同构</p>
<h3 id="对于图的运算">对于图的运算</h3>
<p><strong>Def</strong>：删除边、删除一个边集</p>
<p><strong>Def</strong>：删除点、删除一个顶点集（去掉关联的一切边）</p>
<p><strong>Def</strong>：添加新边</p>
<p><strong>Def</strong>：（收缩）将 <span class="math inline">\(e\)</span> 的两个端点用新的点表示，并将原先与两个顶点相邻的边与之相连</p>
<h2 id="通路与回路">通路与回路</h2>
<p><strong>Def</strong>：（通路、始点、终点、长度）一个交替序列：<span class="math inline">\(\varGamma = v_{i0}e_{j1}\dots e_{jl}v_{il}\)</span></p>
<p><strong>Def</strong>：（回路）一个 <span class="math inline">\(v_{i0} =v_{il}\)</span> 的通路</p>
<p><strong>Def</strong>：（简单通路、简单回路）边各异的通路、回路</p>
<p><strong>Def</strong>：（初级通路、初级回路）（除了始点和终点外）点各异的简单通路、简单回路</p>
<blockquote>
<p><strong>初级回路</strong>也称为<strong>圈</strong></p>
<p>与<strong>简单通路</strong>、<strong>简单回路</strong>相对应的定义<strong>复杂通路</strong>、<strong>复杂回路</strong></p>
</blockquote>
<p><strong>Thm</strong>：在 n 阶图中，若从顶点 u 到 v 存在通路，则从 u 到 v 必定存在一条长度小于等于 n-1 的通路</p>
<p><strong>Inf</strong>：这条通路可以是初级通路</p>
<p><strong>Thm</strong>：在 n 阶图中，若从顶点 u 存在回路，则从 u 到 v 必定存在一条长度小于等于 n 的回路</p>
<p><strong>Inf</strong>：这条通路可以是圈。</p>
<h2 id="图的连通性">图的连通性</h2>
<h3 id="无向图的连通性">无向图的连通性</h3>
<p><strong>Def</strong>：（两个点之间的连通）<span class="math inline">\(u\sim v\)</span></p>
<p><strong>Def</strong>：（无向图的连通性）如果无向图 <span class="math inline">\(G\)</span> 是平凡的或者任何两个顶点都是连通的</p>
<p><strong>Def</strong>：连通分支、连通分支数 <span class="math inline">\(p(G)\)</span></p>
<p><strong>Def</strong>：（短程线、距离）<span class="math inline">\(u\sim v\)</span> 时，称 <span class="math inline">\(u,v\)</span> 之间的长度最短的通路为 <span class="math inline">\(u,v\)</span> 之间的<strong>短程线</strong>，长度称为<strong>距离</strong></p>
<p><strong>Def</strong>：（割点、点割集）若 <span class="math inline">\(\forall V&#39;&#39;\subset V&#39;\)</span> 都有<span class="math inline">\(p(G-V&#39;&#39;)=p(G)\)</span> 但 <span class="math inline">\(p(G-V&#39;) &gt;p(G)\)</span> 则称为点割集，若 <span class="math inline">\(V&#39;\)</span> 中只含有一个点，则称 <span class="math inline">\(v\)</span> 为割点。</p>
<p><strong>Def</strong>：（边割集、割边、桥）</p>
<p><strong>Def</strong>：（点连通度、k-连通图）若 <span class="math inline">\(G\)</span> 为无向连通图且不是完全图，则称 <span class="math inline">\(\kappa (G) = \min\{|V&#39;||V&#39;为G的点割集\}\)</span> 为<strong>点连通度</strong>，简称<strong>连通度</strong>。规定完全图的连通度为 n-1。若 <span class="math inline">\(\kappa \ge k\)</span> 则称 <span class="math inline">\(G\)</span> 为 k-连通图。</p>
<p><strong>Def</strong>：（边连通度 <span class="math inline">\(\lambda(G)\)</span>、r 边-连通图）</p>
<p><strong>Thm</strong>：<span class="math inline">\(\kappa(G)\le\lambda (G)\le\delta(G)\)</span></p>
<blockquote>
<p>一个直观的理解：</p>
<p>删除一个最小的点割集，至少也要删除相应的<span class="math inline">\(\kappa(G)\)</span> 个边</p>
<p>将一个最小度顶点相关联的边全部删除，即可增加连通分支数目</p>
</blockquote>
<h3 id="有向图的连通性">有向图的连通性</h3>
<p><strong>Def</strong>：（可达的、相互可达的）</p>
<p><strong>Def</strong>：（短程线、距离）</p>
<p><strong>Def</strong>：（弱连通图、连通图、单向连通图、强连通图）</p>
<ol type="1">
<li>有向图 <span class="math inline">\(D\)</span> 的基图是连通图，则称 <span class="math inline">\(D\)</span> 为弱连通图，简称连通图</li>
<li>若 <span class="math inline">\(v_i\rightarrow v_j\)</span> 和 <span class="math inline">\(v_j\rightarrow v_i\)</span> 成立至少一个，则称为单向连通图</li>
<li>若两个都成立，则成为强连通图</li>
</ol>
<p><strong>Thm</strong>：（强连通图的充要条件）有向图是强连通的 <span class="math inline">\(\iff\)</span> <span class="math inline">\(D\)</span> 中存在经过每个顶点至少一次的回路</p>
<p><strong>Thm</strong>：（单向连通图的充要条件）有向图是单向连通的 <span class="math inline">\(\iff\)</span> <span class="math inline">\(D\)</span> 中存在经过每个顶点至少一次的通路</p>
<blockquote>
<p>用<strong>扩大路径法</strong>进行构造性证明</p>
<p>取 <span class="math inline">\(\varGamma\)</span> 是一条路径，若始点和终点都不与 <span class="math inline">\(\varGamma\)</span> 外的路径相邻，则称其为<strong>极大路径</strong>，反之则继续延伸。</p>
</blockquote>
<p><strong>Def</strong>：（二部图、完全二部图）若能将 <span class="math inline">\(V\)</span> 划分为 <span class="math inline">\(V_1,V_2\)</span> 使得 <span class="math inline">\(G\)</span> 中的每条边的两个端点分属不同的点集，则称为二部图，若 <span class="math inline">\(V_1\)</span> 中的每一个顶点都与 <span class="math inline">\(V_2\)</span> 中的所有顶点相邻，则称 <span class="math inline">\(G\)</span> 为完全二部图。</p>
<p><strong>Thm</strong>：（二部图的充要条件）n 阶无向图是二部图 iff 其中无奇圈</p>
<h2 id="图的矩阵表示">图的矩阵表示</h2>
<h3 id="关联矩阵">关联矩阵</h3>
<p><strong>Def</strong>：（无向图的 关联矩阵<span class="math inline">\(\boldsymbol{M}(G)\)</span>）<span class="math inline">\(m_{ij}\)</span> 表示顶点与边 <span class="math inline">\(e_j\)</span> 的<strong>关联次数</strong></p>
<div class="note"><p>primary</p></div>
<p><strong>性质</strong></p>
<p>不难看出，该矩阵：</p>
<ol type="1">
<li>每列元素之和为 2</li>
<li>每行元素之和为 <span class="math inline">\(v_i\)</span> 的度数</li>
<li>两列相同，当且仅当这两列对应了平行边</li>
<li>某一行和为 0 当且仅当对应了孤立点</li>
</ol>
<!-- TODO: endnote-->
<p><strong>Def</strong>：（有向图的 关联矩阵 <span class="math inline">\(\boldsymbol{M}(D)\)</span>）有向图无环，则令：</p>
<p><span class="math display">\[
m_{ij} = \begin{cases}
  1 &amp;v_i 是e_j的始点\\
  0 &amp;v_i 与e_j不关联\\
  -1 &amp;v_i 是e_j的终点
\end{cases}
\]</span></p>
<div class="note"><p>primary</p></div>
<p><strong>性质</strong></p>
<p>不难看出，该矩阵：</p>
<ol type="1">
<li>每列元素之和为 0 恰好有一个 -1 一个 1</li>
<li>每行 -1 个数为 <span class="math inline">\(v_i\)</span> 的入度，1 的个数为出度</li>
<li>两列相同，当且仅当这两列对应了平行边</li>
</ol>
<!-- TODO: endnote-->
<h3 id="邻接矩阵">邻接矩阵</h3>
<p><strong>Def</strong>：（有向图的邻接矩阵）<span class="math inline">\(a_{ij}\)</span> 为 <span class="math inline">\(v_i\)</span> 邻接到顶点 <span class="math inline">\(v_j\)</span> 边的条数记为 <span class="math inline">\(A(D)\)</span>。</p>
<p><strong>Thm</strong>：<span class="math inline">\(A\)</span> 的 <span class="math inline">\(l\)</span> 次幂中 <span class="math inline">\(a_{ij}\)</span> 表示 D 中长度为 <span class="math inline">\(l\)</span> 的通路数目，<span class="math inline">\(a_{ii}\)</span> 位回路数。矩阵元素和为总数。</p>
<h3 id="可达矩阵">可达矩阵</h3>
<p><strong>Def</strong>：在有向图中，令</p>
<p><span class="math display">\[
p_{ij}=
\begin{cases}
  1,&amp;v_i可达v_j\\
  0,&amp;otherwise
\end{cases}
\]</span></p>
<p>则称 <span class="math inline">\(P(D)\)</span> 为可达矩阵</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>群与环</title>
    <url>/2020/05/27/study/Math/DiscreteMath/GroupTheory/</url>
    <content><![CDATA[<p>期末复习了 qwwww</p>
<span id="more"></span>
<h2 id="群的定义和性质">群的定义和性质</h2>
<p><strong>Def</strong>：群</p>
<ol type="1">
<li>设 <span class="math inline">\(V = &lt;S,\circ&gt;\)</span> 是代数系统，<span class="math inline">\(\circ\)</span> 是二元运算，且是可结合的，则称 <span class="math inline">\(V\)</span> 是半群</li>
<li>设 <span class="math inline">\(V\)</span> 是一个半群，存在关于 <span class="math inline">\(\circ\)</span> 运算的单位元，则称 <span class="math inline">\(V\)</span> 是幺半群，也称为独异点</li>
<li>若 <span class="math inline">\(V\)</span> 是一个独异点，<span class="math inline">\(e\in S\)</span> 是其单位元，若 <span class="math inline">\(\forall a \in S,a^{-1}\in S\)</span> 则称 <span class="math inline">\(V\)</span> 为群，通常用 <span class="math inline">\(G\)</span> 代表</li>
</ol>
<blockquote>
<p>常见的群有：整数加群、有理数加群、实数加群、复数加群</p>
<p>Klein 四元群：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>e</th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>e</td>
<td>e</td>
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
<tr class="even">
<td>a</td>
<td>a</td>
<td>e</td>
<td>c</td>
<td>b</td>
</tr>
<tr class="odd">
<td>b</td>
<td>b</td>
<td>c</td>
<td>e</td>
<td>a</td>
</tr>
<tr class="even">
<td>c</td>
<td>c</td>
<td>b</td>
<td>a</td>
<td>e</td>
</tr>
</tbody>
</table>
</blockquote>
<p><strong>Def</strong>：平凡群、有限群、无限群、交换群</p>
<ol type="1">
<li>若群 <span class="math inline">\(G\)</span> 是有穷集，则称 <span class="math inline">\(G\)</span> 为有限群，反之称为无限群。其中 <span class="math inline">\(G\)</span> 的基数称为群 <span class="math inline">\(G\)</span> 的阶</li>
<li>若 <span class="math inline">\(G\)</span> 中只含有单位元，称之为平凡群</li>
<li>若二元运算 <span class="math inline">\(\circ\)</span> 是可交换的，则称 <span class="math inline">\(G\)</span> 为交换群或是 Abel 群。</li>
</ol>
<p><strong>Def</strong>：幂运算</p>
<p><span class="math display">\[
a^n=
\begin{cases}
e,\qquad &amp;n = 0\\
a^{n-1}a,&amp; n &gt;0\\
(a^{-1})^m,&amp; n&gt;0,n = -m
\end{cases}
\]</span></p>
<p><strong>Def</strong>：（元素的阶）将使得 <span class="math inline">\(a^k = e\)</span> 成立的最小正整数 <span class="math inline">\(k\)</span> 称为 <span class="math inline">\(a\)</span> 的阶。有 <span class="math inline">\(k\)</span> 阶元，也有无限阶元。</p>
<p><strong>Thm</strong>：幂运算满足</p>
<ol type="1">
<li><span class="math inline">\((a^{-1})^{-1} = a\)</span></li>
<li><span class="math inline">\((ab)^{-1} = b^{-1}a^{-1}\)</span></li>
<li><span class="math inline">\(a^na^m = a^{m+n}\)</span></li>
<li><span class="math inline">\((a^n)^m = a^{mn}\)</span></li>
<li>交换群中，<span class="math inline">\((ab)^n = a^nb^n\)</span></li>
</ol>
<p><strong>Thm</strong>：群中满足消去律</p>
<p><strong>Thm</strong>：设群 <span class="math inline">\(G\)</span> 中有元素 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(|a|\)</span> 为 <span class="math inline">\(r\)</span> 则：</p>
<ol type="1">
<li><span class="math inline">\(a^k = e\iff r|k\)</span></li>
<li><span class="math inline">\(|a^{-1}|=|a|\)</span></li>
</ol>
<h2 id="子群和群的陪集分解">子群和群的陪集分解</h2>
<p><strong>Def</strong>：子群、真子群</p>
<p><strong>Def</strong>：（判定定理 1）设 <span class="math inline">\(G\)</span> 为群，<span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的非空子集，则 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子群，当且仅当下列条件同时成立</p>
<ol type="1">
<li><span class="math inline">\(\forall a,b\in H,ab\in H\)</span></li>
<li><span class="math inline">\(\forall a\in H, a^{-1}\in H\)</span></li>
</ol>
<p><strong>Thm</strong>：（判定定理 2）设 <span class="math inline">\(G\)</span> 为群，<span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的非空子集，则 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子群，当且仅当 <span class="math inline">\(\forall a,b\in H, ab^{-1}\in H\)</span></p>
<p><strong>Thm</strong>：（判定定理 3）设 <span class="math inline">\(G\)</span> 为群，<span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的非空子集，则 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的有穷子群，当且仅当 <span class="math inline">\(\forall a,b\in H,ab\in H\)</span></p>
<p><strong>Def</strong>：（中心）设 <span class="math inline">\(G\)</span> 是群，令 <span class="math inline">\(C\)</span> 是与 <span class="math inline">\(G\)</span> 中所有元素都可交换的元素构成的集合，<span class="math inline">\(C=\{a|a\in G\wedge \forall x\in G(ax=xa)\}\)</span> 则称 <span class="math inline">\(C\)</span> 为 <span class="math inline">\(G\)</span> 的中心，且是 <span class="math inline">\(G\)</span> 的一个子群。</p>
<p><strong>Def</strong>：（由 <span class="math inline">\(B\)</span> 生成的子群）设 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(G\)</span> 的子集，将所有包含 <span class="math inline">\(B\)</span> 的子群的交记作 <span class="math inline">\(&lt;B&gt;\)</span>。</p>
<div class="note"><p>caution</p></div>
<p><strong>Caution</strong></p>
<p>未知正确性：</p>
<ul>
<li><span class="math inline">\(&lt;B&gt;\)</span> 中只含有 <span class="math inline">\(B\)</span> 中的元素或其逆元。</li>
</ul>
<!-- TODO: endnote-->
<p><strong>Def</strong>：设 <span class="math inline">\(H\)</span> 是群 <span class="math inline">\(G\)</span> 的子群，<span class="math inline">\(a\in G\)</span>，令<span class="math inline">\(Ha =\{ha|h\in H\}\)</span> 称之为子群 <span class="math inline">\(H\)</span> 在 <span class="math inline">\(G\)</span> 中的右陪集，并称 <span class="math inline">\(a\)</span> 为 <span class="math inline">\(Ha\)</span> 的代表元素。</p>
<p><strong>Thm</strong>：设 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子群，则</p>
<ol type="1">
<li><span class="math inline">\(He =H\)</span></li>
<li><span class="math inline">\(\forall a\in G, a\in Ha\)</span></li>
</ol>
<p><strong>Thm</strong>：设 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子群，则 <span class="math inline">\(\forall a,b\in G\)</span> TFAE</p>
<ol type="1">
<li><span class="math inline">\(a\in Hb\)</span></li>
<li><span class="math inline">\(ab^{-1}\in H\)</span></li>
<li><span class="math inline">\(Ha=Hb\)</span></li>
</ol>
<p><strong>Thm</strong>：设 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子群，在 <span class="math inline">\(G\)</span> 上定义二元关系：<span class="math inline">\(\forall a,b\in G &lt;a,b&gt;\in R\iff ab^{-1}\in H\)</span> 则 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(G\)</span> 上的等价关系，且 <span class="math inline">\([a]_R =Ha\)</span></p>
<p><strong>Inf</strong>：设 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子群，则</p>
<ol type="1">
<li><span class="math inline">\(\forall a,b\in G, Ha = Hb 或 Ha\cap Hb =\emptyset\)</span></li>
<li><span class="math inline">\(\cup\{Ha|a\in G\} = G\)</span></li>
</ol>
<div class="note"><p>primary</p></div>
<p><strong>Tips</strong></p>
<p>于此同时，<span class="math inline">\(H\)</span> 的所有右陪集的集合 <span class="math inline">\(\{Ha|a\in G\}\)</span> 恰好构成 G 的一个划分，并且，这个划分的所有划分快都和 <span class="math inline">\(H\)</span> 等势。</p>
<p>用同样的方法可以定义 <span class="math inline">\(H\)</span> 的左陪集。 <!-- TODO: endnote--></p>
<p><strong>Def</strong>：（指数）<span class="math inline">\(H\)</span> 在 <span class="math inline">\(G\)</span> 中的左右陪集数相等，记作 <span class="math inline">\(H\)</span> 在 <span class="math inline">\(G\)</span> 中的指数 <span class="math inline">\([G:H]\)</span></p>
<p><strong>Thm</strong>：（Lagrange 定理）设 <span class="math inline">\(G\)</span> 是一个有限群，<span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的子群，则 <span class="math inline">\(|G| = |H|\cdot [G:H]\)</span></p>
<p><strong>Inf</strong>：设 <span class="math inline">\(G\)</span> 是 <span class="math inline">\(n\)</span> 阶群，则 <span class="math inline">\(\forall a\in G\)</span>，<span class="math inline">\(|a|\)</span> 是 <span class="math inline">\(n\)</span> 的因子，且 <span class="math inline">\(a^n =e\)</span></p>
<p><strong>Inf</strong>：设 <span class="math inline">\(G\)</span> 是素数阶的群，则存在 <span class="math inline">\(a\in G\)</span>，使得<span class="math inline">\(G=&lt;a&gt;\)</span></p>
<h2 id="循环群和置换群">循环群和置换群</h2>
<p><strong>Def</strong>：（循环群）若存在 <span class="math inline">\(a\in G\)</span> 使得 <span class="math inline">\(G = &lt;a&gt;\)</span> 则称 <span class="math inline">\(G\)</span> 为循环群，称 <span class="math inline">\(a\)</span> 为 <span class="math inline">\(G\)</span> 的生成元</p>
<p>其中，若 <span class="math inline">\(a\)</span> 是 <span class="math inline">\(n\)</span> 阶元，则 <span class="math inline">\(|G| = n\)</span> 则称 <span class="math inline">\(G\)</span> 为 <span class="math inline">\(n\)</span> 阶循环群，若 <span class="math inline">\(a\)</span> 是无限阶元，则称 <span class="math inline">\(G\)</span> 是无限循环群</p>
<p><strong>Thm</strong>：设 <span class="math inline">\(G=&lt;a&gt;\)</span> 是循环群，</p>
<ol type="1">
<li><span class="math inline">\(G\)</span> 是无限循环群，则 <span class="math inline">\(G\)</span> 只有两个生成元，即为 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(a^{-1}\)</span></li>
<li><span class="math inline">\(G\)</span> 是 <span class="math inline">\(n\)</span> 阶循环群，则 <span class="math inline">\(G\)</span> 含有 <span class="math inline">\(\phi(n)\)</span> 个生成元，对于任何小于且与 <span class="math inline">\(n\)</span> 互素的自然数 <span class="math inline">\(r\)</span>，<span class="math inline">\(a^r\)</span> 是 <span class="math inline">\(G\)</span> 的生成元</li>
</ol>
<p><strong>Thm</strong>：</p>
<ol type="1">
<li>设 <span class="math inline">\(G\)</span> 是循环群，则 <span class="math inline">\(G\)</span> 的子群是循环群</li>
<li><span class="math inline">\(G\)</span> 是无限循环群，则 <span class="math inline">\(G\)</span> 的子群除了 <span class="math inline">\(\{e\}\)</span> 之外都是无限循环群</li>
<li>若 <span class="math inline">\(G\)</span> 是 <span class="math inline">\(n\)</span> 阶循环群，则对于 <span class="math inline">\(n\)</span> 的每一个正因子 <span class="math inline">\(d\)</span>，<span class="math inline">\(G\)</span> 恰好含有一个 <span class="math inline">\(d\)</span> 阶子群</li>
</ol>
<!-- TODO: to complete -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
        <tag>代数结构</tag>
      </tags>
  </entry>
  <entry>
    <title>格和布尔代数</title>
    <url>/2020/05/28/study/Math/DiscreteMath/LatticeandBoolAlgebra/</url>
    <content><![CDATA[<p>半个上午的时间，回顾一下上章的内容，呼</p>
<p>在现实中的许多的问题都可以抽象为代数问题，还是要好好学吖~</p>
<span id="more"></span>
<h2 id="格的定义和性质">格的定义和性质</h2>
<p><strong>Def</strong>：（格）设<span class="math inline">\(&lt; S,\preccurlyeq &gt;\)</span> 是偏序集，若 <span class="math inline">\(\forall x,y\in S,\{x,y\}\)</span> 都有最小上界和最大下界，则称 <span class="math inline">\(S\)</span> 关于偏序 <span class="math inline">\(\preccurlyeq\)</span> 成一个格</p>
<div class="note"><p>default</p></div>
<p>由于最小上界和最大下界的唯一性，可以把求 <span class="math inline">\(\{x,y\}\)</span> 的最小上界和最大下界看成二元运算，<span class="math inline">\(\wedge\)</span> 为最大下界，<span class="math inline">\(\vee\)</span> 为最小上界 <!-- TODO: endnote--></p>
<p><strong>Thm</strong>：（格的对偶原理）设 <span class="math inline">\(f\)</span> 是含有格中元素以及符号 <span class="math inline">\(=,\preccurlyeq,\succcurlyeq,\vee,\wedge\)</span> 的命题，若 <span class="math inline">\(f\)</span> 对于一切格为真，则 <span class="math inline">\(f\)</span> 的对偶命题 <span class="math inline">\(f&#39;\)</span> 也对一切格为真</p>
<p><strong>Thm</strong>：格中的 <span class="math inline">\(\wedge,\vee\)</span>运算满足交换律，结合律，幂等律，吸收律</p>
<p><strong>Thm</strong>：设 <span class="math inline">\(&lt; S,*,\circ &gt;\)</span>是一个具有两个二元运算的代数系统，且对于两个运算满足交换律，结合律，吸收律，则可以适当的定义 <span class="math inline">\(S\)</span> 中的偏序 <span class="math inline">\(\preccurlyeq\)</span> 使之成为一个格。</p>
<p><strong>Def</strong>：设 <span class="math inline">\(&lt; S,*,\circ &gt;\)</span> 是代数系统，如果 <span class="math inline">\(*\)</span> 和 <span class="math inline">\(\circ\)</span> 满足结合律，交换律，吸收律，则该代数系统构成一个格</p>
<div class="note"><p>primary</p></div>
<p>注意：这里的幂等律在上面三个运算律满足时自然满足</p>
<!-- TODO: endnote-->
<p><strong>Thm</strong>：设 <span class="math inline">\(L\)</span> 是格，则 <span class="math inline">\(\forall a,b\in L\)</span> 有 <span class="math inline">\(a\preccurlyeq b\iff a\wedge b =a\iff a\vee b=b\)</span></p>
<p><strong>Thm</strong>：设 <span class="math inline">\(L\)</span> 是格，<span class="math inline">\(\forall a,b,c,d\in L,(a\preccurlyeq b 且 c\preccurlyeq d)\rightarrow(a\wedge c\preccurlyeq b\wedge d,a\vee c\preccurlyeq b\vee d)\)</span></p>
<p><strong>Def</strong>：子格</p>
<h2 id="分配格有补格布尔代数">分配格、有补格、布尔代数</h2>
<p><strong>Def</strong>：（分配格）设 <span class="math inline">\(&lt; L,\wedge,\vee &gt;\)</span> 是格，若 <span class="math inline">\(\forall a,b,c\in L\)</span> 有</p>
<p><span class="math display">\[
a\wedge(b\vee c) =(a\wedge b)\vee (a\wedge c)\\
a\vee(b\wedge c) = (a\vee b)\wedge (a\vee c)
\]</span></p>
<p>则称 <span class="math inline">\(L\)</span> 为分配格。</p>
<div class="note"><p>default</p></div>
<p>两类特殊的格结构：钻石格和五角格 <img src="/2020/05/28/study/Math/DiscreteMath/LatticeandBoolAlgebra/TwoSpecialLattice.png" class="lazyload" data-srcset="/2020/05/28/study/Math/DiscreteMath/LatticeandBoolAlgebra/TwoSpecialLattice.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" class title="钻石格和五角格"> <!-- TODO: endnote--></p>
<p><strong>Thm</strong>：若 <span class="math inline">\(L\)</span> 是格，则 <span class="math inline">\(L\)</span> 是分配格，iff <span class="math inline">\(L\)</span> 中不含有与钻石格或五角格同构的子格</p>
<p><strong>Inf</strong>：小于 5 元的格都是分配格</p>
<p><strong>Inf</strong>：任何一条链都是分配格</p>
<p><strong>Def</strong>：（全下界，全上界）设 <span class="math inline">\(L\)</span> 是格，若存在 <span class="math inline">\(a\in L\)</span> 使得 <span class="math inline">\(\forall x\in L,a\preccurlyeq x\)</span> 则称为 <span class="math inline">\(L\)</span> 的全下界；对称的定义 <span class="math inline">\(L\)</span> 的全上界</p>
<p><strong>Def</strong>：设 <span class="math inline">\(L\)</span> 是格，若 <span class="math inline">\(L\)</span> 存在全下界和全上界，则称 <span class="math inline">\(L\)</span> 为有界格，记作 <span class="math inline">\(&lt; L,\wedge,\vee,0,1 &gt;\)</span></p>
<p><strong>Def</strong>：（补元）在有界格中，<span class="math inline">\(a\in L\)</span>，若存在 <span class="math inline">\(b\in L\)</span> 使得 <span class="math inline">\(a\wedge b =0\)</span> 且 <span class="math inline">\(a\vee b =1\)</span>，则称 <span class="math inline">\(b\)</span> 为 <span class="math inline">\(a\)</span> 的补元</p>
<p><strong>Thm</strong>：在有界分配格中，若 <span class="math inline">\(a\in L\)</span> 且对于 <span class="math inline">\(a\)</span> 存在补元 <span class="math inline">\(b\)</span> 则 <span class="math inline">\(b\)</span> 是 <span class="math inline">\(a\)</span> 唯一的补元 记作 <span class="math inline">\(b = a&#39;\)</span></p>
<p><strong>Def</strong>：（布尔格、布尔代数）如果一个格是有补分配格，则称之为布尔格或布尔代数</p>
<p><strong>Thm</strong>：在布尔代数中</p>
<ol type="1">
<li><span class="math inline">\(\forall a\in B,(a&#39;)&#39; = a\)</span></li>
<li><span class="math inline">\(\forall a,b\in B,(a\wedge b)&#39; =(a&#39;\vee b&#39;),(a\vee b)&#39; = (a&#39;\wedge b&#39;)\)</span></li>
</ol>
<div class="note"><p>default</p></div>
<p>在这个定理中，第一条称作 <strong>双重否定律</strong>，第二条称作<strong>德摩根律</strong>，在命题代数和集合代数中的双重否定律，实则是该定理的特例 <!-- TODO: endnote--></p>
<p><strong>Def</strong>：设<span class="math inline">\(&lt;B,*,\circ&gt;\)</span>是代数系统，若运算满足：</p>
<ol type="1">
<li>交换律</li>
<li>分配律（<span class="math inline">\(*\)</span> 对 <span class="math inline">\(\circ\)</span> <span class="math inline">\(\circ\)</span> 对 <span class="math inline">\(*\)</span> 都有分配律）</li>
<li>同一律 <span class="math inline">\(a*1=a,a\circ 0=a\)</span></li>
<li>补元律（所有元素的补元存在且唯一）</li>
</ol>
<p>则称之为一个布尔代数</p>
<p><strong>Def</strong>：（原子）在格中，若 <span class="math inline">\(0\prec b\preccurlyeq a\iff b=a\)</span> 则称 <span class="math inline">\(a\)</span> 是 L 中的原子</p>
<p><strong>Thm</strong>：（有限布尔代数的表示定理）设 <span class="math inline">\(B\)</span> 是有限布尔代数，<span class="math inline">\(A\)</span> 是由 <span class="math inline">\(B\)</span> 的全体原子构成的集合，则 <span class="math inline">\(B\)</span> 同构于 <span class="math inline">\(A\)</span> 的幂集代数 <span class="math inline">\(P(A)\)</span></p>
<p><strong>Inf</strong>：任何有限布尔代数的基数为 <span class="math inline">\(2^n\)</span></p>
<p><strong>Inf</strong>：任何等势的有限布尔代数都是同构的</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
        <tag>代数结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑</title>
    <url>/2020/06/06/study/Math/DiscreteMath/PropositionalLogic/</url>
    <content><![CDATA[<p>数理逻辑，可以说是到现在为止，写的最详细的了。</p>
<span id="more"></span>
<h2 id="基本概念">基本概念</h2>
<h3 id="命题和联结词">命题和联结词</h3>
<ul>
<li><p>命题</p>
<blockquote>
<p>命题的特征</p>
<ol type="1">
<li>陈述句</li>
<li>唯一的真值</li>
</ol>
</blockquote></li>
<li><p>简单命题、复合命题</p>
<blockquote>
<p>区别在于是否可以再拆分</p>
</blockquote></li>
<li><p><strong>Def</strong>：合取词<span class="math inline">\(\wedge\)</span></p></li>
<li><p><strong>Def</strong>：否定式<span class="math inline">\(\neg\)</span></p></li>
<li><p><strong>Def</strong>：析取词<span class="math inline">\(\vee\)</span></p></li>
<li><p><strong>Def</strong>：异或 <span class="math inline">\(\oplus\)</span></p></li>
<li><p><strong>Def</strong>：蕴含词<span class="math inline">\(\rightarrow\)</span></p></li>
<li><p><strong>Def</strong>：等值词<span class="math inline">\(\leftrightarrow\)</span></p></li>
</ul>
<blockquote>
<p>注意各种联结词在中文中的文字表述</p>
<p>注意如何将各种联结词符号化</p>
</blockquote>
<h3 id="命题公式及其赋值">命题公式及其赋值</h3>
<ul>
<li><p><strong>Def</strong>：命题常项（命题常元）、命题变项（命题变元）</p></li>
<li><p><strong>Def</strong>：合式公式（命题公式）</p>
<blockquote>
<p>这里定义的是将用符号串表示的命题，变为命题公式的规则的方法。也就是描述命题公式的生成方式。</p>
<p>这里用的定义方式称为<strong>递归定义</strong></p>
</blockquote></li>
<li><p><strong>Def</strong>： 层次</p>
<blockquote>
<p>层次可以用<strong>树状展开</strong>来分析得出（个人感觉很像<strong>表达式树</strong>，层次就是子树高度，令平凡的高为 0 就行）</p>
</blockquote>
<ul>
<li><p>命题变项 = 0</p></li>
<li><p>用一次“词”+1（取最大值）</p>
<blockquote>
<p>这里注意 <span class="math inline">\(\neg\)</span> 也要 +1</p>
</blockquote></li>
</ul></li>
<li><p><strong>Def</strong>：赋值（解释）</p></li>
<li><p><strong>Def</strong>：真值表</p>
<blockquote>
<p>真值表的构造法：</p>
<ol type="1">
<li>找出其中所有命题变项</li>
<li>列出 <span class="math inline">\(2^n\)</span> 个赋值</li>
<li>计算真值</li>
</ol>
</blockquote></li>
<li><p><strong>Def</strong>：重言式、矛盾式、可满足式</p></li>
</ul>
<div class="note"><p>default</p></div>
<p>很明显，我们不能有这么傻的方法求真值。</p>
<!-- TODO: endnote-->
<h2 id="等值演算">等值演算</h2>
<h3 id="等值式">等值式</h3>
<ul>
<li><p><strong>Def</strong>：等值</p>
<blockquote>
<p>A 和 B 的真值永远相等，符号化：<span class="math inline">\(A\leftrightarrow B\)</span> 是重言式 也就是 <span class="math inline">\(A\Leftrightarrow B\)</span></p>
</blockquote></li>
<li><p><strong>Def</strong>：等值式模式</p>
<blockquote>
<p>16 种等值式模式可以简化等值式的求值</p>
<ol type="1">
<li>双重否定律</li>
<li>幂等律</li>
<li>交换律</li>
<li>结合律</li>
<li>分配律</li>
<li>德摩根律</li>
<li>吸收律</li>
<li>零律</li>
<li>同一律</li>
<li>排中律</li>
<li>矛盾律</li>
<li>蕴含等值式</li>
<li>等价等值式</li>
<li>假言易位</li>
<li>等价否定等值式</li>
<li>归谬律</li>
</ol>
</blockquote></li>
<li><p><strong>Def</strong>：置换规则</p>
<blockquote>
<p>等值演算时，使用的规则：<span class="math inline">\(A\Leftrightarrow B\rightarrow \varphi(A)\Leftrightarrow \varphi (B)\)</span></p>
</blockquote></li>
</ul>
<h3 id="析取范式和合取范式">析取范式和合取范式</h3>
<ul>
<li><p><strong>Def</strong>：（文字）命题变元及其否定</p></li>
<li><p><strong>Def</strong>：简单析取式、简单合取式</p></li>
<li><p><strong>Thm</strong>：</p>
<ul>
<li>一个简单析取式是重言式 &lt;=&gt; 它同时包含某个命题变元及其否定</li>
<li>一个简单合取式是矛盾式 &lt;=&gt; 它同时包含某个命题变元及其否定式；</li>
</ul></li>
<li><p><strong>Def</strong>：（析取范式、合取范式）由有限个简单合取式、简单</p></li>
<li><p><strong>Thm</strong>：一个析取范式是矛盾式 &lt;=&gt; 它的每个简单合取式都是矛盾式；一个合取范式是重言式 &lt;=&gt; 每个简单析取式都是重言式</p></li>
<li><p><strong>Thm</strong>：范式存在定理</p>
<blockquote>
<p><em>Method 求范式</em></p>
<ol type="1">
<li><p>消去 <span class="math inline">\(\rightarrow\)</span> 和 <span class="math inline">\(\leftrightarrow\)</span></p></li>
<li><p>消去双重否定</p></li>
<li><p>使用分配律</p>
<p><em>这里的分配律可以让析取词和合取词放在合适的位置，即使可能会让整个式子“看起来”更复杂</em></p></li>
</ol>
</blockquote></li>
<li><p><strong>Thm</strong>：极小项的否定是极大项、极大项的否定是极小项</p></li>
<li><p><strong>Def</strong>：主析取范式、主合取范式</p></li>
<li><p><strong>Thm</strong>：任何命题公式存在与之等值的主析取范式和主合取范式，并且唯一。</p>
<blockquote>
<p><em>Method 求主范式</em></p>
<ol type="1">
<li>先化成范式</li>
<li>在缺少某一项时，用排中律 <span class="math inline">\(A\vee \neg A = 1\)</span> 和结合律<strong>添加</strong>缺少的命题变元</li>
</ol>
</blockquote></li>
</ul>
<blockquote>
<p><em>Method 主范式互化</em></p>
<ol type="1">
<li>取 <span class="math inline">\(\neg A\)</span>，并化为范式</li>
<li>则 <span class="math inline">\(A=\neg\neg A\)</span> 用德摩根律展开</li>
</ol>
</blockquote>
<h3 id="联结词的完备集">联结词的完备集</h3>
<ul>
<li><strong>Def</strong>：n 元真值函数</li>
<li><strong>Def</strong>：联结词完备集</li>
<li><strong>Thm</strong>：<span class="math inline">\(\{\neg,\wedge,\vee\}\)</span> 是联结词完备集
<ul>
<li><strong>Inf</strong>：<span class="math inline">\(\{\neg,\wedge\}\)</span> 也是联结词完备集</li>
</ul></li>
</ul>
<blockquote>
<p>这边可以联系一下 Lambda Calculus 中的各类运算，都可以用 Lambda 定义。也就是说，只需要一些操作，就可以满足全部的需要</p>
<p><span class="math inline">\(\{\uparrow\}\)</span>和<span class="math inline">\(\{\downarrow\}\)</span> 是联结词完备集。其中</p>
<ul>
<li><span class="math inline">\(p\uparrow q\Leftrightarrow \neg(p\wedge q)\)</span></li>
<li><span class="math inline">\(p\downarrow q\Leftrightarrow \neg(p\vee q)\)</span></li>
</ul>
</blockquote>
<h3 id="可满足性问题和消解法">可满足性问题和消解法</h3>
<blockquote>
<p>这里主要讨论的是命题公式是否<strong>可满足</strong>的问题</p>
</blockquote>
<ul>
<li><p><strong>Def</strong>：消解式、消解规则</p>
<blockquote>
<p>文字 <span class="math inline">\(I\)</span> 的补 <span class="math inline">\(I^c\)</span>：<span class="math inline">\(I=p\rightarrow I^c=\neg p,I=\neg p\rightarrow I^c=p\)</span></p>
</blockquote>
<blockquote>
<p><em>Method 消解规则</em></p>
<p><span class="math inline">\(C_1=C_1&#39;\vee I,C_2=C_2&#39;\vee I^c\)</span> 是简单析取式，则称<span class="math inline">\(Res(C_1,C_2)=C1&#39;\vee C2&#39;\)</span> 为消解式 注意这里的 <span class="math inline">\(C_1,C_2\)</span> 中是可以含有 <span class="math inline">\(I\)</span> 的，但是不方便计算，后面在消解序列定义时，也直接用了合取范式这一定义。</p>
</blockquote></li>
<li><p><strong>Thm</strong>：<span class="math inline">\(C_1\wedge C_2 \approx Res(C_1,C_2)\)</span></p></li>
<li><p><strong>Def</strong>：消解序列、否证</p>
<blockquote>
<p>记 <span class="math inline">\(S\)</span> 是一个合取范式，<span class="math inline">\(C_1,C_2,\dots,C_i\)</span> 是一个简单析取式序列，<span class="math inline">\(C_i\)</span> 或是<span class="math inline">\(S\)</span> 中的元素，或是序列中两个简单析取式的消解式 若<span class="math inline">\(C_i = \lambda\)</span> 则称该序列为一个否证。</p>
</blockquote>
<ul>
<li><strong>Inf</strong>：<span class="math inline">\(S\)</span> 有否证，不可满足。</li>
</ul>
<blockquote>
<p>这个定理和下面一个定理构成充要条件</p>
</blockquote></li>
<li><p><strong>Thm</strong>：（消解的完全性）如果 S 不可满足，则 S 有否证 &gt; <em>Method 消解算法</em> &gt; &gt; 1. 求合取范式 &gt; 2. <span class="math inline">\(S_0,S_2\)</span> 为不含任何元素的集合，<span class="math inline">\(S_1\)</span> 为 <span class="math inline">\(S\)</span> 所有简单析取式构成的集合 &gt; 3. 对于 <span class="math inline">\(S_0,S_1\)</span> 中的任意两个可消解的子句，进行消解 &gt; 非空则放入<span class="math inline">\(S_2\)</span>， &gt; 空子句则找到否证，<span class="math inline">\(S\)</span> 不可满足 &gt; 4. <span class="math inline">\(S_2\)</span> 为空时，表明无法继续消解，且<span class="math inline">\(S\)</span>可满足</p></li>
</ul>
<blockquote>
<p>一句吐槽，在罗森的《离散数学及其应用》书中，消解律就那么半页纸，讲的也比较清楚。有需要可以对比看看</p>
</blockquote>
<h2 id="命题逻辑的推理理论">命题逻辑的推理理论</h2>
<h3 id="推理的形式结构">推理的形式结构</h3>
<ul>
<li><p><strong>Def</strong>：推理是有效的</p></li>
<li><p><strong>Thm</strong>：推理正确<span class="math inline">\(\{A_i\}\models B\iff \wedge A_i \rightarrow B\)</span> 为永真式</p>
<blockquote>
<p><span class="math inline">\(p\Rightarrow q\)</span> 表示 <span class="math inline">\(p\rightarrow q\)</span> 为重言式</p>
</blockquote>
<blockquote>
<p><em>Method 判断 <span class="math inline">\(\wedge A_i \rightarrow B\)</span> 是重言式的方法</em></p>
<ol type="1">
<li>真值表法</li>
<li>等值演算法</li>
<li>主析取范式法</li>
</ol>
</blockquote></li>
<li><p>推理定律</p>
<blockquote>
<p>重言蕴含式</p>
<ol type="1">
<li>附加律<span class="math inline">\(A\Rightarrow A\vee B\)</span></li>
<li>化简律<span class="math inline">\(A\wedge B\Rightarrow A\)</span></li>
<li>假言推理<span class="math inline">\((A\rightarrow B)\wedge A\Rightarrow B\)</span></li>
<li>抗拒式 <span class="math inline">\((A \rightarrow B) \wedge \neg B \Rightarrow \neg A\)</span></li>
<li>析取三段论<span class="math inline">\((A \rightarrow B) \wedge \neg B \Rightarrow \neg A\)</span></li>
<li>假言三段论<span class="math inline">\((A \rightarrow B) \wedge(B \rightarrow C) \Rightarrow(A \rightarrow C)\)</span></li>
<li>等价三段论<span class="math inline">\((A \leftrightarrow B) \wedge(B \leftrightarrow C) \Rightarrow(A \leftrightarrow C)\)</span></li>
<li>构造性二难<span class="math inline">\((A \rightarrow B) \wedge(C \rightarrow D) \wedge(A \vee C) \Rightarrow(B \vee D)\)</span></li>
<li>构造性二难（特殊）<span class="math inline">\((A \rightarrow B) \wedge(\neg A \rightarrow B) \Rightarrow B\)</span></li>
<li>破坏性二难<span class="math inline">\((A \rightarrow B) \wedge(C \rightarrow D) \wedge(\neg B \vee \neg D) \Rightarrow \neg A \vee \neg C\)</span></li>
</ol>
</blockquote></li>
</ul>
<h3 id="自然推理系统-p">自然推理系统 P</h3>
<ul>
<li><p><strong>Def</strong>：形式演算系统、形式语言系统</p></li>
<li><p><strong>Def</strong>：证明</p>
<blockquote>
<p>证明是一个公式序列</p>
</blockquote></li>
<li><p>构造证明方法</p>
<ul>
<li>附加前提证明法：<span class="math inline">\(\wedge A_i \rightarrow (A_{i+1} \rightarrow B) \Leftrightarrow \wedge A_i \rightarrow B\)</span></li>
<li>归谬法：<span class="math inline">\(\wedge A_i \wedge B\)</span> 为矛盾式</li>
<li>消解证明法</li>
</ul></li>
</ul>
<blockquote>
<p>常用证明方法：</p>
<ol type="1">
<li>穷举证明法、分情形证明法</li>
<li>存在性证明中：构造性证明、非构造性的存在性证明（不存在则错误）</li>
<li>唯一性证明：需要证明存在且唯一</li>
</ol>
</blockquote>
<h2 id="一阶逻辑的基本概念">一阶逻辑的基本概念</h2>
<h3 id="一阶逻辑命题的符号化">一阶逻辑命题的符号化</h3>
<ul>
<li><p><strong>Def</strong>：个体词（个体变项、个体常项）、论域（全总个体域）</p>
<blockquote>
<p><strong>个体词</strong>：所研究对象中可以独立存在的具体或抽象的客体。</p>
</blockquote></li>
<li><p><strong>Def</strong>：谓词</p>
<blockquote>
<p><strong>谓词</strong>：用来刻画个体词性质及个体词之间关系的词</p>
</blockquote></li>
<li><p><strong>Def</strong>：量词（全称量词、存在量词）</p>
<blockquote>
<p><strong>量词</strong>：表示个体变元在个体域中取值方式的词</p>
</blockquote></li>
</ul>
<h3 id="一阶逻辑公式及其解释">一阶逻辑公式及其解释</h3>
<ul>
<li><p><strong>Def</strong>：一阶语言的字母表</p>
<ul>
<li>非逻辑符号（个体常项、函数、谓词）</li>
<li>逻辑符号（个体变项、量词符号、联结词、括号和都好）</li>
</ul></li>
<li><p><strong>Def</strong>：L 的项</p></li>
<li><p><strong>Def</strong>：原子公式 <span class="math inline">\(R(x_1,\dots,x_n)\)</span></p></li>
<li><p><strong>Def</strong>：合式公式（谓词公式）</p>
<blockquote>
<p>递归定义</p>
</blockquote></li>
<li><p><strong>Def</strong>：指导变元、约束出现、自由出现、辖域</p></li>
<li><p><strong>Def</strong>：封闭、闭式</p></li>
<li><p><strong>Def</strong>：L 的解释 I 的组成</p></li>
<li><p><strong>Thm</strong>：封闭的公式在任何解释下都变成命题</p></li>
<li><p><strong>Def</strong>：（公式的）永真式、矛盾式、可满足式</p></li>
<li><p><strong>Def</strong>：代换实例</p></li>
<li><p><strong>Thm</strong>：重言式的代换实例都是重言式、矛盾式的代换实例都是矛盾式</p></li>
</ul>
<h2 id="一阶逻辑等值演算和推理">一阶逻辑等值演算和推理</h2>
<h3 id="一阶逻辑等值演算和置换规则">一阶逻辑等值演算和置换规则</h3>
<ul>
<li><p><strong>Def</strong>：等值</p></li>
<li><p><strong>Thm</strong>：等值式</p></li>
<li><p>由永真式的代换实例得到的永真式</p>
<ul>
<li><p>消去量词等值式</p></li>
<li><p>量词否定等值式</p></li>
<li><p>量词辖域收缩扩张等值式</p>
<blockquote>
<p>应用这个等值式时要注意，对<span class="math inline">\(A(x)\)</span>扩张时，扩张或收缩的式子中没有<span class="math inline">\(x\)</span>的自由出现</p>
</blockquote></li>
<li><p>量词分配等值式</p></li>
</ul></li>
<li><p>规则</p>
<ul>
<li>置换规则</li>
<li>换名规则</li>
<li>代替规则</li>
</ul></li>
</ul>
<h3 id="一阶逻辑的前束范式">一阶逻辑的前束范式</h3>
<ul>
<li><p><strong>Def</strong>：前束范式</p></li>
<li><p><strong>Thm</strong>：前束范式存在定理</p>
<blockquote>
<p><em>Method 求前束范式</em></p>
<ol type="1">
<li>替换<span class="math inline">\(\leftrightarrow,\rightarrow\)</span> 为 <span class="math inline">\(\wedge,\vee,\neg\)</span></li>
<li>用量词否定等值式，将 <span class="math inline">\(\neg\)</span> 调至原子公式之前</li>
<li>用换名规则</li>
<li>用扩张收缩律，将量词移到全式的最前面</li>
</ol>
</blockquote></li>
</ul>
<h3 id="一阶逻辑的推理理论">一阶逻辑的推理理论</h3>
<ul>
<li><p><strong>Def</strong>：推理定律</p>
<ul>
<li><p>命题逻辑推理定律的代换实例</p></li>
<li><p>基本等值式生成的推理定律</p></li>
<li><p>其他的</p></li>
<li><p>规则</p>
<ul>
<li>全称量词消去规则<span class="math inline">\(\forall -\)</span>（全称实例）</li>
<li>全称量词引入规则<span class="math inline">\(\forall +\)</span>（全称引入）</li>
<li>存在量词消去规则<span class="math inline">\(\exists -\)</span>（存在实例）</li>
<li>存在量词引入规则<span class="math inline">\(\exists +\)</span>（存在引入）</li>
</ul></li>
</ul></li>
<li><p><strong>Def</strong>：自然推理系统</p></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
        <tag>数理逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学 [Overview]</title>
    <url>/2020/09/26/study/Math/DiscreteMath/index/</url>
    <content><![CDATA[<p>2019 - 2020 - 3 <strong>离散数学</strong>目录</p>
<span id="more"></span>
<ol type="1">
<li><a href="/2020/06/06/study/Math/DiscreteMath/PropositionalLogic/">数理逻辑</a></li>
<li><a href="/2020/06/27/study/Math/DiscreteMath/集合论/">集合论</a></li>
<li><a href="/2020/05/27/study/Math/DiscreteMath/GroupTheory/">群&amp;环</a></li>
<li><a href="/2020/05/28/study/Math/DiscreteMath/LatticeandBoolAlgebra/">格&amp;布尔代数</a></li>
<li><a href="/2020/05/28/study/Math/DiscreteMath/GraphTheory/">图的基本概念</a></li>
<li><a href="/2020/06/25/study/Math/DiscreteMath/EulerHarmiltonGraph/">欧拉图&amp;哈密顿图</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>集合论</title>
    <url>/2020/06/27/study/Math/DiscreteMath/%E9%9B%86%E5%90%88%E8%AE%BA/</url>
    <content><![CDATA[<!--  -->
<span id="more"></span>
<h2 id="集合代数">集合代数</h2>
<h3 id="集合的基本概念">集合的基本概念</h3>
<ul>
<li><p>Def：子集、包含</p></li>
<li><p>Def：（集合）相等</p></li>
<li><p>Def：真子集</p></li>
<li><p>Def：空集</p></li>
<li><p>Thm：空集是一切集合的子集</p>
<ul>
<li>Thm：空集是唯一的</li>
</ul></li>
<li><p>Def：幂集</p></li>
<li><p>Def：全集</p></li>
</ul>
<h3 id="集合运算">集合运算</h3>
<ul>
<li>Def：相对补集</li>
<li>Def：对称差集</li>
<li>Def：绝对补集</li>
<li>Def：广义并、广义交</li>
</ul>
<h3 id="有穷集的计数">有穷集的计数</h3>
<ul>
<li>容斥原理</li>
</ul>
<h3 id="集合恒等式">集合恒等式</h3>
<h2 id="二元关系">二元关系</h2>
<h3 id="有序对笛卡尔积">有序对、笛卡尔积</h3>
<ul>
<li>Def：有序对</li>
<li>Def：笛卡尔积</li>
</ul>
<h3 id="二元关系-1">二元关系</h3>
<ul>
<li>Def：二元关系</li>
<li>Def：A上的二元关系</li>
<li>Def：空关系、全域关系、恒等关系</li>
</ul>
<h3 id="关系的运算">关系的运算</h3>
<ul>
<li><p>Def：定义域、值域、域</p></li>
<li><p>Def：逆运算</p></li>
<li><p>Def：右复合</p></li>
<li><p>Def：R在A上的限制、像</p></li>
<li><p>Thm：<span class="math inline">\((F^{-1})^{-1} = F, \quad dom F^{-1} = ran F, ran F^{-1} = dom F\)</span></p></li>
<li><p>Thm：<span class="math inline">\((F \circ G ) \circ H = F \circ (G \circ H),\quad (F\circ G)^{-1} = G^{-1} \circ F^{-1}\)</span></p></li>
<li><p>Thm：$R I_A = I_A R = R $</p></li>
<li><p>Thm：</p>
<ul>
<li><span class="math inline">\(F \circ (G \cup H) = F \circ G \cup F \circ H\)</span> <span class="math inline">\((G \cup H) \circ F = G \circ F \cup H \circ F\)</span></li>
<li><span class="math inline">\(F \circ (G \cap H) \subset F \circ G \cap F \circ H\)</span> <span class="math inline">\((G \cap H) \circ F \subset G \circ F \cap H \circ F\)</span></li>
</ul></li>
<li><p>Thm：</p>
<ul>
<li><span class="math inline">\(F \upharpoonright (A \cup B) = F \upharpoonright A \cup F \upharpoonright B\)</span></li>
<li><span class="math inline">\(R [ A \cup B ] =F[A] \cup F[B]\)</span></li>
<li><span class="math inline">\(F \upharpoonright (A \cap B) = F \upharpoonright A \cap F \upharpoonright B\)</span></li>
<li><span class="math inline">\(F [A \cap B] \subset F[A] \cap F[B]\)</span></li>
</ul></li>
<li><p>Def：R的n次幂</p></li>
<li><p>Thm：存在自然数<span class="math inline">\(s, t\)</span>，使得<span class="math inline">\(R^s = R^t\)</span></p></li>
<li><p>Thm：</p></li>
</ul>
<ol type="1">
<li><span class="math inline">\(R^m \circ R^n = R^{m+n}\)</span></li>
<li><span class="math inline">\((R^m)^n = R^{mn}\)</span></li>
</ol>
<ul>
<li>Thm：</li>
</ul>
<ol type="1">
<li><span class="math inline">\(\forall k \in \mathrm N, R^{s+k} = R^{t+k}\)</span></li>
<li><span class="math inline">\(\forall k, i \in \mathrm N , R^{s+tp+i} =R^{s+i}, where p = t - s\)</span></li>
<li><span class="math inline">\(Let~S = \{R^0, R^1, \dots, R^t-1\}, \forall q \in \mathrm N, R^q \in S\)</span></li>
</ol>
<h3 id="关系的性质">关系的性质</h3>
<ul>
<li><p>Def：自反的、反自反的</p></li>
<li><p>Def：对称、反对称</p></li>
<li><p>Def：传递</p></li>
<li><p>Thm</p>
<ul>
<li>自反 iff <span class="math inline">\(I_A \subseteq R\)</span></li>
<li>反自反 iff <span class="math inline">\(R\cap I_A = \emptyset\)</span></li>
<li>对称 iff <span class="math inline">\(R = R^{-1}\)</span></li>
<li>反对称 iff <span class="math inline">\(R\cap R^{-1} \subseteq I_A\)</span></li>
<li>传递 iff <span class="math inline">\(R\circ R \subseteq R\)</span></li>
</ul></li>
</ul>
<h3 id="关系的闭包">关系的闭包</h3>
<ul>
<li>Def：自反闭包、传递闭包、对称闭包</li>
<li>Warshall算法</li>
<li>Thm：自反/传递/对称 iff <span class="math inline">\(r,t,s(R) =R\)</span></li>
<li>Thm：<span class="math inline">\(R_1 \subseteq R_2\Rightarrow r,s,t(R_1)\subseteq r,s,t(R_2)\)</span></li>
<li>Thm：R是自反的=&gt;s,t(R) 是自反的 R是对称的=&gt;r,t(R)是对称的 R是传递的=&gt;r(R)是传递的</li>
</ul>
<h3 id="等价关系和划分">等价关系和划分</h3>
<ul>
<li><p>Def：等价关系</p></li>
<li><p>Def：等价类</p></li>
<li><p>Thm：</p>
<ul>
<li><span class="math inline">\(\forall A, [x] 是 A 的非空子集\)</span></li>
<li><span class="math inline">\(\forall x, y \in A, (xRy \rightarrow [x] = [y])\)</span></li>
<li><span class="math inline">\(forall x, y \in A, (x \not R y \rightarrow [x]与[y]不交\)</span></li>
<li><span class="math inline">\(\cup{[x]| x\in A} = A\)</span></li>
</ul></li>
<li><p>Def：划分</p></li>
</ul>
<h3 id="偏序关系">偏序关系</h3>
<ul>
<li>Def：偏序关系</li>
<li>Def :（偏序）小于</li>
<li>Def：全序关系</li>
<li>Def：偏序集</li>
<li>Def：覆盖</li>
<li>Def：最小元、最大元、极小元、极大元</li>
<li>Def：上界、下界、上确界、下确界</li>
</ul>
<h2 id="函数">函数</h2>
<h3 id="函数的定义">函数的定义</h3>
<ul>
<li>Def：函数</li>
<li>Def：函数相等</li>
<li>Def：从A到B的函数</li>
<li>Def：“B上A”</li>
<li>Def：函数的像、完全原像</li>
<li>Def：满射、单射、双射</li>
<li>Def：常函数、恒等函数、单调递增/减、严格单调递增、特征函数、自然映射</li>
</ul>
<h3 id="集合的复合和反函数">集合的复合和反函数</h3>
<ul>
<li><p>Thm：<span class="math inline">\(dom(F\circ G)= \{ x| x\in dom(F) \wedge x \in dom(G)\}\)</span></p></li>
<li><p>Thm：</p>
<ul>
<li><span class="math inline">\(f,g满射\rightarrow f\circ g满射\)</span></li>
<li><span class="math inline">\(f,g单射\rightarrow f\circ g单射\)</span></li>
<li><span class="math inline">\(f,g双射\rightarrow f\circ g双射\)</span></li>
</ul></li>
<li><p>Thm</p>
<ul>
<li>若 f 双射，则<span class="math inline">\(f^{-1}\)</span>双射</li>
</ul></li>
</ul>
<h3 id="双射函数和集合基数">双射函数和集合基数</h3>
<ul>
<li><p>Def：等势</p></li>
<li><p>Thm：等势是等价关系</p></li>
<li><p>Thm：康托定理</p></li>
<li><p>Def：优势</p>
<ul>
<li>若存在从A到B的单射函数，则称B优势于A</li>
<li>B真优势于A</li>
</ul></li>
<li><p>Thm：</p>
<ul>
<li>A优势于A</li>
<li>A优势于B，B优势于A，则A, B等势</li>
<li>传递</li>
</ul></li>
<li><p>Def：集合后继</p>
<ul>
<li>用空集和后继<span class="math inline">\(n^+\)</span>可以吧自然数定义为集合</li>
</ul></li>
<li><p>Def：一个集合是有穷的，当且仅当其于某个自然数等势，反之为无穷集</p></li>
<li><p>Def：集合基数、<span class="math inline">\(alef_0\)</span></p></li>
<li><p>Thm：集合基数和优势、等势的关系</p></li>
<li><p>Def：可数集</p>
<ul>
<li>可数集的子集是可数集</li>
<li>可数个可数集的并是可数集</li>
<li>两个可数集的笛卡尔积是可数集</li>
<li>无穷集 A 的幂集 P(A) 不是可数集</li>
</ul></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数 [Review] 目录</title>
    <url>/2020/09/26/study/Math/LinearAlgebra&amp;MatriceComputation/index/</url>
    <content><![CDATA[
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数学</tag>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>「数值分析」 Chapter1</title>
    <url>/2021/03/01/study/Math/NumericRecipies/chapter1/</url>
    <content><![CDATA[<p>现代数值方法-01</p>
<span id="more"></span>
<p>TOC：</p>
<ol type="1">
<li>绪论</li>
<li>非线性方程求根</li>
<li>线性方程组的数值解</li>
<li>插值和逼近</li>
<li>数值积分和数值微分</li>
<li>常微分方程的数值解</li>
<li>偏微分方程的数值解</li>
</ol>
<h1 id="绪论">绪论</h1>
<p>主要内容：</p>
<ol type="1">
<li><strong>科学计算的内容</strong>：科学模拟的过程、一般策略</li>
<li><strong>误差的概念</strong>：绝对误差、相对误差、向前/向后误差、有效数字及它们之间的关系</li>
<li><strong>数据误差对函数值的影响</strong>：讨论函数的误差与自变量误差之间的关系</li>
<li><strong>算法的数值稳定性</strong>：讨论初始数据的误差对计算结果的影响</li>
<li><strong>实际计算中应该注意的问题</strong></li>
</ol>
<h2 id="科学计算">科学计算</h2>
<h3 id="计算模拟解决问题的过程">计算模拟解决问题的过程</h3>
<ol type="1">
<li>建立数学模型</li>
<li>给出数值算法</li>
<li>计算机软件实现算法</li>
<li>运行、进行数值模拟</li>
<li>表示计算结果</li>
<li>解释计算结果</li>
</ol>
<h3 id="一般策略">一般策略</h3>
<ol type="1">
<li>有限维空间代替无限维空间</li>
<li>用有限过程代替无限过程</li>
<li>用线性方程代替微分方程</li>
<li>用低阶方程组代替高阶方程组</li>
<li>用简单函数代替复杂函数</li>
<li>用简单结构矩阵代替一般矩阵</li>
</ol>
<h2 id="误差的基本概念">误差的基本概念</h2>
<h3 id="误差的来源">误差的来源</h3>
<ol type="1">
<li>模型误差</li>
<li>观测误差</li>
<li>阶段误差</li>
<li>舍入误差</li>
</ol>
<p>例1：</p>
<ul>
<li><span class="math inline">\(A=4\pi r^2\)</span> 中，包含了各种误差</li>
</ul>
<p>例2：</p>
<ul>
<li>Taylor 展开：<span class="math inline">\(e^{-x} = 1-x+\frac 1 2{x^2} -\frac{1}{6}x^3+E_r(x)\)</span></li>
<li>略去 <span class="math inline">\(E_r\)</span> 项：产生截断误差</li>
</ul>
<h3 id="绝对误差">绝对误差</h3>
<p><strong>Def</strong>（绝对误差） 设 <span class="math inline">\(x^*\)</span> 是准确值，<span class="math inline">\(x\)</span> 是近似值，则：</p>
<p><span class="math display">\[
e(x)=x^*-x
\]</span></p>
<p>为近似值 <span class="math inline">\(x\)</span> 的<strong>绝对误差</strong>，简称<strong>误差</strong>。在实际计算中，绝对误差无法求出，但只需要知道误差的一个范围，从而有<strong>绝对误差限</strong> <span class="math inline">\(\varepsilon\)</span>：</p>
<p><span class="math display">\[
|e(x)|\le \varepsilon
\]</span></p>
<h3 id="相对误差">相对误差</h3>
<p><span class="math display">\[
e_r(x)=\frac{x^*-x}{x^*}
\]</span></p>
<p>若 <span class="math inline">\(x^*\)</span> 无法确定，也用：</p>
<p><span class="math display">\[
e_r(x)=\frac{x^*-x}{x}
\]</span></p>
<p>相应的，有相对误差限：</p>
<p><span class="math display">\[
|e_r(x)|\le \varepsilon
\]</span></p>
<h3 id="有效数">有效数</h3>
<p>若 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(x^*\)</span> 的近似值，若 <span class="math inline">\(|e(x)|\)</span> 是其某个数位的半个单位，从左起第一个非零数到这一位有 n 位，则称 n 个数字为其有效数字。</p>
<h3 id="数据误差和计算误差">数据误差和计算误差</h3>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数值方法</tag>
      </tags>
  </entry>
  <entry>
    <title>概率统计与随机过程</title>
    <url>/2020/09/26/study/Math/Probabilities/index/</url>
    <content><![CDATA[<span id="more"></span>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「概率统计与随机过程」 1 - 随机事件及其概率</title>
    <url>/2020/11/18/study/Math/Probabilities/notes1/</url>
    <content><![CDATA[<p>随机事件及其概率</p>
<span id="more"></span>
<h2 id="随机事件及其概率">随机事件及其概率</h2>
<h3 id="随机事件">随机事件</h3>
<p><strong>Def</strong>：样本空间</p>
<p><strong>Def</strong>：随机事件</p>
<h3 id="随机事件的概率">随机事件的概率</h3>
<h4 id="事件的概率">事件的概率</h4>
<p><strong>Def</strong>：频率</p>
<p><strong>Thm</strong>：频率满足</p>
<ul>
<li><span class="math inline">\(0\le f_n(A)\le 1\)</span></li>
<li><span class="math inline">\(f_n(\varOmega)=1\)</span></li>
<li>互不相容的随机事件，<span class="math inline">\(f_n(\cup A_i)=\sum f_n(A_i)\)</span></li>
</ul>
<h4 id="概率的公理化定义">概率的公理化定义</h4>
<p><strong>Def</strong>：设<span class="math inline">\(E\)</span>是随机试验，<span class="math inline">\(\varOmega\)</span> 是 <span class="math inline">\(E\)</span> 的样本空间，对于每一个随机事件，赋予唯一的实数<span class="math inline">\(P(A)\)</span>，满足：非负性、规范性、可列可加性，则称集合函数<span class="math inline">\(P(\cdot)\)</span>为概率测度。</p>
<p><strong>Thms</strong></p>
<ul>
<li>不可能事件的概率为 0</li>
<li>有限可加性：不相容的随机事件，和的概率等于概率的和</li>
<li>对立事件的概率：<span class="math inline">\(P(\bar A)=1-P(A)\)</span></li>
<li>概率的加法公式：<span class="math inline">\(P(A+B)=P(A)+P(B)-P(AB)\)</span></li>
<li>概率的减法公式：若 A 包含 B，<span class="math inline">\(P(A-B)=P(A)-P(B)\)</span></li>
<li>概率的单调性：若 A 包含于 B，<span class="math inline">\(P(A)\le P(B)\)</span></li>
</ul>
<h3 id="古典概型">古典概型</h3>
<p><strong>Def</strong>：一个古典概型 <span class="math inline">\(E\)</span> 满足：</p>
<ol type="1">
<li>样本空间只有有限个基本事件</li>
<li>每个基本事件出现可能性相同</li>
</ol>
<h3 id="条件概率">条件概率</h3>
<h4 id="条件概率的定义">条件概率的定义</h4>
<p><strong>Def</strong>：（有穷划分）设 <span class="math inline">\(\varOmega\)</span> 是随机试验 <span class="math inline">\(E\)</span> 的样本空间，<span class="math inline">\(A_1,A_2,\dots, A_n\)</span> 是随机事件，若满足： 1. <span class="math inline">\(A_iA_j = \emptyset,~\forall i\ne j\)</span> 2. <span class="math inline">\(\cup A_j = \varOmega\)</span> 则称<span class="math inline">\(A_1,A_2,\dots, A_n\)</span> 是<span class="math inline">\(\varOmega\)</span> 的一个有穷划分。</p>
<blockquote>
<p>相同定义 可列无穷划分 %}</p>
</blockquote>
<p><strong>Def</strong>（条件概率）设 <span class="math inline">\(A,B\)</span> 是两个随机事件，<span class="math inline">\(P(B)&gt;0\)</span> 则称 <span class="math inline">\(P(A|B)=P(AB)/P(B)\)</span> 为事件 <span class="math inline">\(B\)</span> 发生条件下，事件 <span class="math inline">\(A\)</span> 发生的概率</p>
<h4 id="概率的乘法公式">概率的乘法公式</h4>
<p><strong>Thm</strong>：设 <span class="math inline">\(A_1, ...,A_n\)</span> 为 n 个随机事件，且 <span class="math inline">\(P(\bigcap A_i)&gt;0\)</span>，则 <span class="math inline">\(P(\bigcap A_i)=P(A_1)P(A_2|A_1)...P(A_n|\bigcap_{i=1}^{n-1}A_i)\)</span></p>
<h4 id="全概率公式和贝叶斯公式">全概率公式和贝叶斯公式</h4>
<p><strong>Thm</strong>（全概率公式）设随机事件组是 <span class="math inline">\(\varOmega\)</span> 的一组<strong>可列无穷划分</strong> <span class="math inline">\(P(A_i) &gt; 0,\forall i\)</span>，则对于任意随机事件 <span class="math inline">\(B\)</span>，有：<span class="math inline">\(P(B) = \sum P(A_i)P(B|A_i)\)</span></p>
<p><strong>Thm</strong>（Bayes 公式）设<span class="math inline">\(A_1, A_2,\dots\)</span> 是样本空间<span class="math inline">\(\varOmega\)</span> 的一组可列无穷划分，<span class="math inline">\(P&gt;0,B\subset \varOmega\)</span> 则：</p>
<p><span class="math display">\[
  P(A_i|B) = \frac{P(A_i)P(B|A_i)}{\sum P(A_i)P(B|A_i)}, i = 1, 2,\dots
\]</span></p>
<h3 id="随机事件的独立性">随机事件的独立性</h3>
<h4 id="两个随机事件的独立性">两个随机事件的独立性</h4>
<p><strong>Def</strong>（独立性）设<span class="math inline">\(A,B\)</span>是两个随机事件，若：<span class="math inline">\(P(AB) = P(A)P(B)\)</span>则称 <span class="math inline">\(A, B\)</span> 是两个相互独立的随机事件</p>
<blockquote>
<p><span class="math inline">\(\varOmega,~\emptyset\)</span> 与任一事件相互独立</p>
</blockquote>
<p><strong>Thm</strong>：<span class="math inline">\(P(A),P(B)&gt;0\)</span> 时 <span class="math inline">\(A,B独立\iff P(A|B)=P(A), P(B|A)=P(B)\)</span></p>
<p><strong>Thm</strong>（独立扩张定理）<span class="math inline">\(A,B独立\iff \bar A,B~A,\bar B~ \bar A,\bar B 独立\)</span></p>
<h4 id="多个随机事件的独立性">多个随机事件的独立性</h4>
<p><strong>Def</strong>：三个独立的随机事件，满足： <span class="math display">\[
  \begin{cases}
      两两独立\\
      P(ABC) = P(A)P(B)P(C)
  \end{cases}
\]</span></p>
<p><strong>Def</strong>（n 个事件的独立性）</p>
<blockquote>
<p>独立的多个随机事件满足：</p>
<ol type="1">
<li><span class="math inline">\(P(\cap A_i) = \prod P(A_i)\)</span></li>
<li><span class="math inline">\(P(\cup A_i) = 1 - \prod[1-P(A_i)]\)</span></li>
</ol>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「概率统计与随机过程」 10 - 马尔科夫链</title>
    <url>/2020/12/11/study/Math/Probabilities/notes10/</url>
    <content><![CDATA[<p>马尔科夫链 <span id="more"></span></p>
<h2 id="马尔科夫链">马尔科夫链</h2>
<h3 id="马尔科夫链的基本概念">马尔科夫链的基本概念</h3>
<p><strong>Def</strong>（马尔科夫链）随机过程 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 如果满足如下条件：</p>
<ol type="1">
<li>状态空间 <span class="math inline">\(I=\{x_0, x_1, ..., x_n,...\}\)</span> 为可数集</li>
<li>对于一切 <span class="math inline">\(n\ge 1\)</span> 和所有的 <span class="math inline">\(x\)</span>, <span class="math inline">\(x_{i_0}, x_{i_1},...,x_{i_{n-1}}\in I\)</span> 都有</li>
</ol>
<p><span class="math display">\[
P(X_n=x|X_0=x_{i_0},X_1=X_{i_1},...,X_{n-1}=x_{i_{n-1}})=P(X_n=x|X_{n-1}=x_{n-1})
\]</span></p>
<p>则称 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 是马尔科夫链。</p>
<p><strong>Def</strong>（n 步转移概率）设 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 是一个马尔科夫链，称 <span class="math inline">\(p_{ij}(m,m+n)=P(X_{m+n}=j|X_m=i)\)</span> 为马氏链的 n 步转移概率（<span class="math inline">\(\forall i,j\in I\)</span>）。</p>
<p>由 <span class="math inline">\(p_{ij}(m,m+n)\)</span> 组成的矩阵 <span class="math inline">\(P(m,m+n)=(p_{ij}(m,m+n))\)</span> 称为 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 的 <strong>n 步转移概率矩阵</strong>。</p>
<p><strong>Def</strong>（齐次的马尔科夫链）设 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 为一马尔科夫链，如果对所有的 <span class="math inline">\(m\ge 0\)</span>，<span class="math inline">\(n\ge 1, i,j\in I\)</span> 有 <span class="math inline">\(P(X_{m+n}=j|X_m=i)=P(X_n=j|X_0=i)\)</span> 则称为齐次的马氏链。</p>
<p>此时，一步转移概率矩阵记为 <span class="math inline">\(P=P(1)=(p_{ij})\)</span>。</p>
<p><strong>Thm</strong>：若对于一切的 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(i,j\in I\)</span> 有：</p>
<p><span class="math display">\[
P(X_{n+1}=j|X_n=i)=P(X_1=j|X_0=i)
\]</span></p>
<p>则 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 是齐次的马氏链</p>
<p><strong>Thm</strong>：齐次的马氏链的 <span class="math inline">\(P(n)\)</span> 有：</p>
<p><span class="math display">\[
\begin{cases}
    p_{ij}\ge 0,\\
    \sum p_{ij}=1
\end{cases}
\]</span></p>
<h3 id="齐次马尔科夫链的有限维分布">齐次马尔科夫链的有限维分布</h3>
<p><strong>Def</strong>（分布律）设 <span class="math inline">\(\{X_n,n\ge0\}\)</span> 是一个齐次的马尔科夫链，状态空间为 <span class="math inline">\(I=\{0,1,2,...\}\)</span> 对于任意时刻 <span class="math inline">\(n\ge 0\)</span>，称离散型随机变量的分布律为齐次马氏链的一维分布律，记为 <span class="math inline">\(\mathbb p(n)=(p_0(n),....)\)</span></p>
<p>当 <span class="math inline">\(n=0\)</span> 时，称为初始分布律。</p>
<p><strong>Thm</strong>：<span class="math inline">\(p(n)=p(0)P(n)\)</span>，其中 <span class="math inline">\(P(n)\)</span> 为多步转移概率矩阵。</p>
<h3 id="多步转移概率的确定">多步转移概率的确定</h3>
<p><strong>Pre</strong>（条件的全概率公式）设随机事件 <span class="math inline">\(A_1,...A_n,...\)</span> 构成完备事件组：</p>
<p><span class="math display">\[
\bigcup_{i=1}^\infty A_i=\Omega,A_iA_j=\varnothing
\]</span></p>
<p>则：<span class="math inline">\(P(B|C)=\sum_{i=1}^\infty P(A_i|C)P(B|A_iC)\)</span></p>
<p><strong>Thm</strong>：设 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 是齐次马尔科夫链，其状态空间为 <span class="math inline">\(I=\{0,1,...\}\)</span> n 步转移矩阵为 <span class="math inline">\(P(n)\)</span>。则对于任意时刻 <span class="math inline">\(m,n\ge 1\)</span>，有<span class="math inline">\(P(m+n)=P(m)P(n)\)</span>（C-K 方程）</p>
<p>根据 C-K 方程：<span class="math inline">\(P(n)=P^n\)</span></p>
<h3 id="遍历性">遍历性</h3>
<p><strong>Def</strong>（极限分布）设 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 是齐次马氏链，状态空间为 <span class="math inline">\(I=\{0, 1,2,...\}\)</span>，对于所有的 <span class="math inline">\(i,j\)</span> 而言，n 步转移概率极限存在且与 <span class="math inline">\(i\)</span> 无关，</p>
<p><span class="math display">\[
P(n)=P^n\rightarrow^{n\rightarrow\infty}\left[
\begin{matrix}
    \pi_0&amp;\pi_1&amp;\cdots&amp;\pi_j&amp;\cdots\\
    \pi_0&amp;\pi_1&amp;\cdots&amp;\pi_j&amp;\cdots\\
    \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
    \pi_0&amp;\pi_1&amp;\cdots&amp;\pi_j&amp;\cdots\\
    \vdots&amp;\vdots&amp;&amp;\vdots
\end{matrix}
\right]
\]</span></p>
<p>则称此链具有遍历性。</p>
<p><span class="math inline">\(P^n\)</span> 求法：</p>
<ol type="1">
<li>求出矩阵的特征值分解 <span class="math inline">\(A=V\Lambda V^{-1}\)</span></li>
<li>求 <span class="math inline">\(P^n\)</span></li>
</ol>
<p><strong>Thm</strong>：若 <span class="math inline">\(\{X_n,n\ge 0\}\)</span> 是齐次马氏链，一部转移概率为 <span class="math inline">\(P\)</span> 若存在 n 步转移概率矩阵 <span class="math inline">\(P(n)\)</span> 无零元，则此链具有遍历性，其极限分布 <span class="math inline">\(\pi\)</span> 是：</p>
<p><span class="math display">\[
\pi P=\pi
\]</span></p>
<p>满足归一性条件（<span class="math inline">\(\mathbf 1^T\pi=1\)</span>）的唯一解。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「概率统计与随机过程」 2 - 随机变量及其概率分布</title>
    <url>/2020/11/18/study/Math/Probabilities/notes2/</url>
    <content><![CDATA[<p>随机变量及其概率分布</p>
<span id="more"></span>
<h2 id="随机变量及其概率分布">随机变量及其概率分布</h2>
<h3 id="随机变量">随机变量</h3>
<p><strong>Def</strong>：设 <span class="math inline">\(E\)</span> 时一个随机试验，<span class="math inline">\(\varOmega\)</span> 是其样本空间，如果对于每一个试验的结果 <span class="math inline">\(\omega\in \varOmega\)</span>，由唯一的实数<span class="math inline">\(X(\omega)\)</span>与之对应，这个定义在试验样本空间上的实值函数<span class="math inline">\(X(\omega)\)</span>称为<span class="math inline">\(E\)</span>的随机变量。</p>
<h3 id="随机变量的分布函数">随机变量的分布函数</h3>
<p><strong>Def</strong>（随机变量的分布函数）设 <span class="math inline">\(X(\omega)\)</span>是随机变量，称 <span class="math inline">\(F(x) = P(X\le x),~-\infty&lt;x&lt;\infty\)</span></p>
<p><strong>Thm</strong>：一些定义</p>
<ul>
<li><span class="math inline">\(P(x_1 &lt; X\le x_2) = F(x_2) - F(x_1)\)</span></li>
<li><span class="math inline">\(P(x_1\le X&lt; x2) = F(x_2-0) - F(x_1-0)\)</span></li>
<li><span class="math inline">\(P(x_1 &lt; X&lt; x2) = F(x_2-0) - F(x_1)\)</span></li>
<li><span class="math inline">\(P(x_1\le X\le x2) = F(x_2) - F(x_1-0)\)</span></li>
</ul>
<p><strong>Thm</strong>：分布函数的性质</p>
<ol type="1">
<li><span class="math inline">\(0\le F(x) \le 1\)</span></li>
<li>单调不降</li>
<li>右连续函数：<span class="math inline">\(F(x+0)=F(x)\)</span></li>
<li>有<em>可数</em>个间断点</li>
</ol>
<h3 id="离散型随机变量">离散型随机变量</h3>
<h4 id="离散型随机变量的分布律">离散型随机变量的分布律</h4>
<p><strong>Def</strong>（概率函数）设离散随机变量<span class="math inline">\(X\)</span>可能取得一切之为 <span class="math inline">\(x_1, x_2,\dots, x_n\)</span> 称为 <span class="math inline">\(X\)</span> 分布律（列），也称为 <span class="math inline">\(X\)</span> 的概率函数。</p>
<blockquote>
<p>分布律也可以用表格的形式表示： |X|x1|x2|x3|...| |---|---|---|---|---| |P|p1|p2|p3|...|</p>
</blockquote>
<p><span class="math inline">\(X\)</span> 的分布函数 <span class="math inline">\(F(x) = \sum\limits_{x_k\le x} p_k\)</span></p>
<h4 id="常见的离散分布">常见的离散分布</h4>
<h5 id="分布">0 - 1 分布</h5>
<p><strong>Def</strong>：<span class="math inline">\(0 - 1\)</span>分布：<span class="math inline">\(X\)</span> 只取 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 两个值，且<span class="math inline">\(P(X=1)=p,~P(X=0)=1-p\)</span>，则称 <span class="math inline">\(X\)</span> 服从 <span class="math inline">\((0-1)\)</span> 分布。</p>
<h5 id="二项分布">二项分布</h5>
<p><strong>Def</strong>：n次独立试验概型</p>
<blockquote>
<p><strong>伯努利试验</strong>只有两个可能结果，<span class="math inline">\(A,~\bar A\)</span>，且<span class="math inline">\(P(A)=p\)</span> - <span class="math inline">\(n\)</span> 重伯努利试验是指将试验独立重复 <span class="math inline">\(n\)</span> 次。 - <span class="math inline">\(X\)</span> 表示 <span class="math inline">\(n\)</span> 重伯努利试验中事件 <span class="math inline">\(A\)</span> 发生的次数</p>
<p>称随机变量<span class="math inline">\(X\)</span>服从参数为<span class="math inline">\(n,~p\)</span> 的二项分布，<span class="math inline">\(X\sim B(n,p)\)</span> - <span class="math inline">\(P(X=k) = C_n^k p^k (1-p)^{n-k}\)</span></p>
</blockquote>
<p><strong>Thm</strong>：<span class="math inline">\(X\)</span>是伯努利试验中<span class="math inline">\(A\)</span>发生的次数，<span class="math inline">\(p\)</span>是每次试验中 <span class="math inline">\(A\)</span> 发生的概率，则 <span class="math inline">\(X\sim b(n,p)\)</span></p>
<p><strong>Def</strong>：最可能成功次数<span class="math inline">\(k = \lfloor (n+1)p \rfloor~(n+1)p不是整数\)</span></p>
<h5 id="泊松分布">泊松分布</h5>
<p><strong>Def</strong>（泊松分布）<span class="math inline">\(\displaystyle P(X=k) = \frac{\lambda^ke^{-\lambda}}{k!},~X\sim P(\lambda)\)</span></p>
<p><strong>Thm</strong>（泊松定理）设 <span class="math inline">\(\lambda &gt;0\)</span>是一个常数，<span class="math inline">\(n\)</span> 是任意正整数，设<span class="math inline">\(np_n=\lambda\)</span>。则对于任意固定的非负整数<span class="math inline">\(k\)</span>有 <span class="math inline">\(\displaystyle\lim_{n\rightarrow \infty}C_n^kp_n^k(1-p_n)^{n-k}=\frac{\lambda^ke^{-\lambda}}{k!}\)</span></p>
<h5 id="几何分布">几何分布</h5>
<p><span class="math inline">\(\displaystyle P(X=k) = q^{k-1} p, k=1,2,\dots\)</span></p>
<h5 id="超几何分布">超几何分布</h5>
<p><span class="math inline">\(\displaystyle P(X=k) = \frac{C_M^k\cdot C_{N-M}^{n-k}}{C_N^n}, k = 0, 1, 2, \dots, l=\min\{n,M\}\)</span></p>
<ul>
<li><span class="math inline">\(X\sim H(N,M,n)\)</span></li>
</ul>
<h5 id="负二项分布">负二项分布**</h5>
<p><span class="math inline">\(\displaystyle P(X=k) = C_{k-1}^{r-1}p^r(1-p)^{k-r}\)</span> - <span class="math inline">\(X\sim Nb(r,p)\)</span></p>
<h4 id="连续型随机变量">连续型随机变量</h4>
<p><strong>Def</strong>（连续性随机变量）<span class="math inline">\(F(x) = \int_{-\infty}^xf(x)\mathrm dx,-\infty &lt; x &lt; \infty\)</span> - 其中<span class="math inline">\(f(x)\)</span> 是非负可积函数，称为<span class="math inline">\(X\)</span>的概率分布密度函数（概率密度函数<code>Probability Density Function</code>） - 规范性：<span class="math inline">\(\displaystyle\int_R f(x) \mathrm dx =1\)</span> - <span class="math inline">\(P(x&lt; X \le x+\Delta x)\approx f(x)\Delta x\)</span> - 连续性，<span class="math inline">\(F(-\infty) = 0\)</span>，<span class="math inline">\(F(\infty)=1\)</span></p>
<p><strong>Def</strong>（累积分布函数）<span class="math inline">\(\displaystyle P(a&lt;X\le b) = \int_a^bf(x)\mathrm dx\)</span></p>
<h5 id="均匀分布">均匀分布</h5>
<p><span class="math display">\[
f(x)=\begin{cases}
  \displaystyle\frac{1}{b-a},&amp;a\le x\le b,\\
  0,&amp;otherwise
\end{cases}\\
\\
F(x) = P(X\le x) = \begin{cases}
  0,&amp;x &lt; a\\
  \displaystyle\frac{x-a}{b-a}, &amp;a\le x \le b\\
  1, &amp;x&gt;b
\end{cases}
\]</span></p>
<ul>
<li><span class="math inline">\(X\sim U[a,b]\)</span></li>
</ul>
<h5 id="指数分布">指数分布</h5>
<p><span class="math display">\[
f(x) = \begin{cases}
  \lambda e^{-\lambda x}, &amp;x&gt;0\\
  0, &amp; x\le 0
\end{cases}
\\
F(x) = \begin{cases}
  1- e^{-\lambda x}, &amp;x&gt;0\\
  0, &amp;x\le 0
\end{cases}
\]</span></p>
<ul>
<li><span class="math inline">\(X\sim e(\lambda)\)</span></li>
</ul>
<h5 id="正态分布">正态分布</h5>
<p><strong>Def</strong>：<span class="math inline">\(\displaystyle f(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span> - <span class="math inline">\(X\sim N(\mu, \sigma^2)\)</span> - <span class="math inline">\(\mu\)</span> 为位置参数，<span class="math inline">\(\sigma\)</span> 为尺度参数 - 关于<span class="math inline">\(\mu\)</span>对称，最大值 - <span class="math inline">\(\sigma\)</span>固定，形状保持不变 - 拐点为：<span class="math inline">\(x=\mu\pm\sigma\)</span> - <span class="math inline">\(erf(x)=F(x)= \int_{-\infty}^{x}\frac{1}{\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\mathrm dx\)</span> - <span class="math inline">\(3\sigma,~6\sigma\)</span>理论</p>
<p><strong>Def</strong>（标准正态分布）<span class="math inline">\(N(0,1)\)</span></p>
<ul>
<li><span class="math inline">\(\mu = 0, \sigma = 1\)</span> 的正态分布称为标准正态分布</li>
<li>密度函数和分布函数通常用 <span class="math inline">\(\varphi(x),\Phi(x)\)</span> 表示</li>
<li><span class="math inline">\(\Phi(0)=0.5,~\Phi(-x) = 1-\Phi(x)\)</span></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
  &amp;\varphi(x) = \frac{1}{\sqrt{2\pi}}e^{\frac{-x^2}{2}}\\
  &amp;\Phi(x) = \int_{-\infty}^x\varphi(x)\mathrm dx
\end{aligned}
\]</span></p>
<p><strong>Thm</strong>（一般正态分布的标准化）：若<span class="math inline">\(X\sim N(\mu, \sigma^2)\)</span>，则<span class="math inline">\(U=\frac{X-\mu}{\sigma}\sim N(0,1)\)</span></p>
<p><strong>Def</strong>：（<span class="math inline">\(\alpha\)</span>分位点）<span class="math inline">\(P(X&gt;\mu_\alpha) = \alpha,\quad0&lt;\alpha&lt;1\)</span></p>
<h3 id="随机变量函数的分布">随机变量函数的分布</h3>
<h4 id="已知离散随机变量x的分布求函数-y-gx-的分布">已知离散随机变量X的分布，求函数 Y = g(X) 的分布</h4>
<p><span class="math display">\[
P(Y=y_j) = P(g(X)=y_j) = \sum_{\{x_k|g(x_k) = y_j\}}P(X=x_k), j = 1, 2, \dots,
\]</span></p>
<p>离散型均匀分布：</p>
<p><span class="math display">\[
Y = [NX+1],\quad where~X\sim U(0, 1)
\]</span></p>
<h4 id="一致连续型随机变量x的概率密度求-gx-的概率密度">一致连续型随机变量X的概率密度，求 g(X) 的概率密度</h4>
<ul>
<li><strong>分布函数法</strong></li>
<li>Key Point：<span class="math inline">\(F_Y(y)=P(Y\le y)=P(g(x)\le y)=\displaystyle\int_{\{x|g(x)&lt;y\}}f_X(x)\mathrm dx\)</span></li>
</ul>
<p><span class="math display">\[
Y = aX+b\Rightarrow
f_Y(y)=\frac{\mathrm d}{\mathrm dy}F_Y(y) =\begin{cases}
  \frac 1 a f_X(\frac{y-b}{a}),&amp;a&gt;0\\
  -\frac{1}{a} f_X(\frac{y-b}{a}),&amp;a&lt;0\\
\end{cases}
\]</span></p>
<p>「例」：<span class="math inline">\(X\sim N(0,1),~Y=X^2\)</span></p>
<p><span class="math display">\[
f_Y(y) = F&#39;_Y(y) =\begin{cases}
  \frac{1}{\sqrt{2\pi y}}e^{-\frac{y}{2}},&amp; y&gt;0\\
  0,&amp;y\le 0
\end{cases}
\]</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「概率统计与随机过程」 3 - 随机向量及其概率分布</title>
    <url>/2020/11/18/study/Math/Probabilities/notes3/</url>
    <content><![CDATA[<p>随机向量及其概率分布</p>
<span id="more"></span>
<h2 id="随机向量及其概率分布">随机向量及其概率分布</h2>
<h3 id="二维随机向量的联合分布">二维随机向量的联合分布</h3>
<p><strong>Def</strong>（二维随机向量）假设 <span class="math inline">\(\Omega = \{\omega\}\)</span> 是随机试验 E 的样本空间，<span class="math inline">\(X(\omega),~Y(\omega)\)</span> 是定义在<span class="math inline">\(\Omega\)</span> 上的两个随机变量，由他们构成一个二维向量<span class="math inline">\((X,Y)\)</span>称为随机试验 E 的一个二维向量。</p>
<p><strong>Def</strong>（二维随机变量的联合分布函数）假设<span class="math inline">\((X,Y)\)</span>是二维随机向量，对于任意实数<span class="math inline">\(x,y\)</span>，二元函数<span class="math inline">\(F(x,y)=P(X\le x,Y\le y)\)</span> 称为二维随机向量<span class="math inline">\((X,Y)\)</span> 的联合分布函数（分布函数）。</p>
<p><em>联合分布函数的性质</em>：</p>
<ol type="1">
<li><span class="math inline">\(0\le F\le 1\)</span></li>
<li><span class="math inline">\(F\)</span> 是变量 <span class="math inline">\(x,~y\)</span> 的不降函数。</li>
<li>右连续性</li>
<li><span class="math inline">\(\forall x_1&lt;x_2, y_ 1 &lt; y _ 2:~P(x\\_1\le X \le x\\_2,y\\_1\le X \le y\\_2) = F(x\\_2,y\\_2) +F(x\\_1, y\\_1) - F(x\\_1,y\\_2) - F(x\\_2, y\\_1)\ge0\)</span></li>
</ol>
<h4 id="二维离散型随机向量">二维离散型随机向量</h4>
<p><strong>Def</strong>（二维离散型随机向量）若随机向量 <span class="math inline">\((X,Y)\)</span> 最多取可列无穷多个点 <span class="math inline">\((x_i, y_j), i, j\in \mathrm N\)</span>，则称 <span class="math inline">\(P(X=x_i,Y=y_j)=p_{ij}\)</span> 为 <span class="math inline">\((X,Y)\)</span> 的联合分布律。</p>
<p><em>表格表示</em>：</p>
<table>
<thead>
<tr class="header">
<th>X\Y</th>
<th>y1</th>
<th>...</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x1</td>
<td>p11</td>
<td>...</td>
</tr>
<tr class="even">
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p><strong>Def</strong>（离散型随机向量的联合分布律）<span class="math inline">\(F(x,y) = \sum_{y_j\le y} \sum_{x_j\le x} p_{ij}\)</span></p>
<ul>
<li><span class="math inline">\(p_{ij}\ge 0\)</span></li>
<li><span class="math inline">\(\sum_{j=1}^\infty \sum p{ij}=1\)</span></li>
</ul>
<h4 id="二维随机连续向量">二维随机连续向量</h4>
<p><strong>Def</strong>（连续型随机向量）<span class="math inline">\(F(x,y)\)</span> 是二维随机向量<span class="math inline">\((X, Y)\)</span> 的联合分布函数，若存在非负可积函数 <span class="math inline">\(f(x,y)\)</span> ，有 <span class="math inline">\(F(x,y)=\int_{-\infty}^y\int_{-\infty}^0\)</span> 则称<span class="math inline">\((X,Y)\)</span> 的二维连续型随机向量，<span class="math inline">\(f(x,y)\)</span> 称为概率密度函数（<code>PDF</code>）</p>
<p><em>相关性质</em>： 1. 非负性 2. 规范性 3. <span class="math inline">\(f(x,y) =\frac{\partial^2}{\partial x\partial y}F(x,y)\)</span> 4. <span class="math inline">\(P((X,Y)\in G) = \iint_G f\mathrm dx \mathrm dy\)</span></p>
<h4 id="二维连续型随机向量">二维连续型随机向量</h4>
<p><strong>Def</strong>（二维连续型随机向量的联合概率密度函数）设 <span class="math inline">\(F(x,y)\)</span> 是二维随机向量 <span class="math inline">\((X,Y)\)</span> 的联合分布函数，若存在非负可积函数 <span class="math inline">\(f(x,y)\)</span> 有，<span class="math inline">\(F(x,y)=\int\int f(x,y)dxdy\)</span> 则称 <span class="math inline">\((X,Y)\)</span> 为二维连续性随机向量 <span class="math inline">\(f\)</span> 为密度函数</p>
<p><em>例</em>：</p>
<ol type="1">
<li>二维均匀分布：
<ul>
<li>面积为 <span class="math inline">\(A\)</span> 若 <span class="math inline">\((X,Y)\)</span> 具有概率密度：<span class="math inline">\(f(x,y) = 1/A~if~(x,y)\in G~else~0\)</span></li>
</ul></li>
<li>二维正态分布</li>
</ol>
<p><span class="math display">\[f(x,y) = \frac{1}{2\pi \sigma_1\sigma_1\sqrt{1-\rho^2}}\exp\{-\frac{1}{2(1-\rho^2)}[\frac{(x-\mu_1)^2}{\sigma_1^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu)2)^2}{\sigma_2^2}  ]\}\]</span></p>
<h3 id="边缘分布">边缘分布</h3>
<p><strong>Def</strong>（边缘分布函数）假设二维随机向量<span class="math inline">\((X,Y)\)</span> 的联合概率分布函数 <span class="math inline">\(F(x,y)\)</span>，令<span class="math inline">\(F_1(x) = F(x,+\infty),F_2(y) = F(+\infty, y)\)</span>为关于 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的边缘分布函数</p>
<p><strong>Thm</strong>：二维随机向量的联合分布函数为 <span class="math inline">\(F(x,y)\)</span>，分布函数为 <span class="math inline">\(F_X, F_Y\)</span>，则 <span class="math inline">\(F_X(x) = F_1(x),~F_Y(y) = F_2(y)\)</span></p>
<h4 id="离散型-边缘分布律"><em>离散型</em>-边缘分布律</h4>
<p>：</p>
<ul>
<li><span class="math inline">\(\displaystyle F_X(x) = \sum_{x_i\le x}\sum p_{ij}\)</span></li>
<li><span class="math inline">\(P(X = x_i) = \sum_{j=1}^\infty p_{ij},~P(X = x_j) = \sum_{i=1}^\infty p_{ij}\)</span></li>
<li><span class="math inline">\(p_{i\cdot}=P(X=x_i),~p_{\cdot j}=P(Y=y_j)\)</span></li>
</ul>
<h4 id="连续型-边缘分布密度"><em>连续型</em>-边缘分布密度</h4>
<blockquote>
<p>根据 <span class="math inline">\(F_X(x) = F(x, +\infty) = \int_{-\infty}^x\int_{-\infty}^{+\infty}f(x,y)\mathrm dy\mathrm dx=\int_{-\infty}^{x}f_1(x)\mathrm dx\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(f_X(x) = \int_{-\infty}^\infty f(x,y)\mathrm dy\)</span></li>
<li><span class="math inline">\(f_Y(Y) = \int_{-\infty}^\infty f(x,y)\mathrm dx\)</span></li>
</ul>
<h3 id="条件概率">条件概率</h3>
<p><strong>Def</strong>：(条件分布函数）假设<span class="math inline">\(X,~Y\)</span> 是两个随机变量，</p>
<ul>
<li><p>若对于固定的 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(P(X=x)\ge 0\)</span> 则对于任意的 <span class="math inline">\(y\in R\)</span> 称：<span class="math inline">\(P(Y\le y|X=x)=\frac{P(X=x, Y\le y)}{P(X = x)}\)</span> 为 <span class="math inline">\(X = x\)</span> 条件下，<span class="math inline">\(Y\)</span> 的条件分布函数，记为 <span class="math inline">\(F_{Y|X}(y|x)\)</span></p></li>
<li><p>若对于固定的 <span class="math inline">\(y\)</span> 有 <span class="math inline">\(P(Y=y)\ge 0\)</span> 则对于任意的 <span class="math inline">\(x\in R\)</span> 称：<span class="math inline">\(P(X\le x|Y=y)=\frac{P(Y=y, X\le x)}{P(Y = y)}\)</span> 为 <span class="math inline">\(Y = y\)</span> 条件下，<span class="math inline">\(X\)</span> 的条件分布函数，记为 <span class="math inline">\(F_{Y|X}(x|y)\)</span></p></li>
</ul>
<p><em>连续型随机变量的条件分布函数</em>：对于连续型随机变量，考虑极限：</p>
<ul>
<li><span class="math inline">\(\displaystyle\lim_{\Delta x\rightarrow 0}\frac{P(x-\Delta x&lt; X\le x,Y\le y)}{P(x-\Delta x &lt; X\le x)}=\frac{\int_{-\infty}^yf(x,y)\mathrm dy}{f_X(x)}~-\infty &lt; y &lt; +\infty\)</span></li>
</ul>
<h4 id="离散型随机变量的条件分布律">离散型随机变量的条件分布律</h4>
<p>设 <span class="math inline">\((X,Y)\)</span> 是二维离散型随机变量，联合分布律为<span class="math inline">\(P(X=x_i,Y=y_j)=p_{ij},~i,j=1,2,\dots\)</span></p>
<ul>
<li><p>可知：<span class="math inline">\(P(Y=y_j|X=x_i)=\displaystyle\frac{p_{ij}}{p_{i\cdot}}\)</span></p></li>
<li><p>类似地，条件分布律为：<span class="math inline">\(\displaystyle F_{Y|X} (y|x) = \frac{\sum_{y_j\le y}P_{ij}}{p_{i\cdot}}\)</span></p></li>
</ul>
<h5 id="连续型随机变量的条件分布条件分布密度">连续型随机变量的条件分布、条件分布密度</h5>
<p>设二维连续型随机变量<span class="math inline">\((X,Y)\)</span> 的连续概率密度函数为<span class="math inline">\(f(x,y)\)</span> 对于固定的 <span class="math inline">\(x\)</span>，<span class="math inline">\((X,Y)\)</span> 关于边缘概率密度 <span class="math inline">\(f_X(x)&gt;0\)</span> 则在<span class="math inline">\(X=x\)</span>条件下，<span class="math inline">\(Y\)</span> 的<em>条件分布函数</em>：</p>
<ul>
<li><span class="math inline">\(\displaystyle\lim_{\Delta x\rightarrow 0}\frac{P(x-\Delta x&lt; X\le x,Y\le y)}{P(x-\Delta x &lt; X\le x)}=\frac{\int_{-\infty}^yf(x,y)\mathrm dy}{f_X(x)}=\int_{-\infty}^y\frac{f(x,y)}{f_X(x)}\mathrm dy=\int_{-\infty}^yf_{Y|X}(y|x)\mathrm dy\)</span></li>
</ul>
<p>则，<em>条件分布密度</em>为：</p>
<p><span class="math display">\[
\displaystyle f_{X|Y}(x|y)=\frac{f(x,y)}{f_Y(y)}\\
\displaystyle f_{Y|X}(y|x)=\frac{f(x,y)}{f_X(x)}
\]</span></p>
<ul>
<li>类似于<em>乘法公式</em>：<span class="math inline">\(f_{X,Y}(x,y)=f_Y(y)f_{X|Y}(x|y)\)</span></li>
</ul>
<h3 id="随机变量的独立性">随机变量的独立性</h3>
<blockquote>
<p>随机变量 X Y 独立是指：与 X 相关的任一事件发生与否与 Y 有关的任一事件发生与否无关。</p>
</blockquote>
<p><strong>Def</strong>（随机变量间的独立性）设随机向量的联合分布函数为<span class="math inline">\(F(x,y)\)</span>，而<span class="math inline">\(F_X(x),F_Y(y)\)</span> 分别为随机变量 X, Y 的分布函数，若 <span class="math inline">\(\forall (x,y)\in R^2, F(x,y)=F_X(x)F_Y(y)\)</span> 则 X Y 相互独立</p>
<p><strong>Thm</strong>：若<span class="math inline">\((X,Y)\)</span> 为二维离散型随机向量，其联合分布律为：<span class="math inline">\(P(X=x_i,Y=y_i)=p_{ij}\)</span> 则 X Y 相互独立的充要条件是 <span class="math inline">\(\forall (x_i,y_i),p_{ij}=P(X=x_i)P(Y=y_j)\)</span></p>
<p><strong>Thm</strong>：若<span class="math inline">\((X,Y)\)</span> 为二维连续型随机向量，其联合概率密度函数为：<span class="math inline">\(f(x,y)\)</span> 则 X Y 相互独立的充要条件是 <span class="math inline">\(\forall (x,y),f(x,y) = f_X(x)f_Y(y)\)</span></p>
<h5 id="例">例</h5>
<ol type="1">
<li>正态变量 <span class="math inline">\((X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\)</span></li>
</ol>
<ul>
<li><span class="math inline">\(\rho\)</span>：相关系数</li>
<li>独立 <span class="math inline">\(\iff\rho=0\)</span></li>
</ul>
<ol start="2" type="1">
<li>矩形区域的均匀分布 → 独立</li>
<li>若联合密度 <span class="math inline">\(f(x,y)\)</span> 可分离变量，即 <span class="math inline">\(f(x,y)=g(x)h(y)\)</span> 且定义域互不影响，则 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 相互独立。</li>
<li>独立 → 条件分布与边缘分布相同。</li>
</ol>
<h3 id="n-维随机向量">n 维随机向量</h3>
<p><strong>Def</strong>（联合分布）n维随机向量的联合分布</p>
<p><strong>Def</strong>（概率分布律）</p>
<p><strong>Def</strong>（联合概率密度函数）<span class="math inline">\(F=\int\int\dots\int f\)</span></p>
<ul>
<li><strong>Thm</strong>：规范性</li>
</ul>
<p><strong>Def</strong>（k维边缘分布）<span class="math inline">\(F_{X_1,..,X_k}=F(X_1, ..,X_k,+\infty,+\infty,...,+\infty)\)</span></p>
<ul>
<li><strong>Def</strong>（1维边缘分布、密度函数）</li>
</ul>
<p><strong>Def</strong>（条件分布）</p>
<p><strong>Def</strong>（n维随机向量的独立性）<span class="math inline">\(F(x_1,x_2,...,x_n)=\Pi F_{X_i}\)</span></p>
<p><strong>Def</strong>（独立性）X，Y独立，则<span class="math inline">\(\bar X,S^2, \bar Y,S^2\)</span>独立</p>
<h3 id="随机向量函数的分布">随机向量函数的分布</h3>
<blockquote>
<p>课程中主要考虑：</p>
<ul>
<li><span class="math inline">\(Z=g(X,Y)=X+Y\)</span></li>
<li><span class="math inline">\(Z=XY\)</span></li>
<li><span class="math inline">\(Z=Z/Y\)</span></li>
<li><span class="math inline">\(Z=\min\{X,Y\}~(or~\max\{X,Y\})\)</span></li>
<li><span class="math inline">\(Z=\sqrt{X^2+Y^2}\)</span></li>
</ul>
</blockquote>
<h4 id="二维离散型随机向量函数的分布">二维离散型随机向量函数的分布</h4>
<p><span class="math display">\[
P(Z=z_k)=\sum_{Z=z_k}P(X=x_i,Y=y_i)
\]</span></p>
<p>例如，<em>一些分布的可加性</em>：</p>
<ul>
<li><p><span class="math inline">\(X\sim P(\lambda_1),Y\sim P(\lambda_2)\)</span> 且独立，则 <span class="math inline">\(X+Y\sim P(\lambda_1+\lambda_2)\)</span></p></li>
<li><p><span class="math inline">\(X\sim b(n,p),Y\sim b(m,p)\)</span> 且独立，则 <span class="math inline">\(X+Y\sim b(n+m,p)\)</span></p></li>
</ul>
<p><strong>Thm</strong>（离散场合的卷积公式）通常的：X，Y 独立，则对于<span class="math inline">\(Z=X+Y\)</span>，有<span class="math inline">\(\displaystyle P(Z=z_i)=\sum_{j=1}^\infty P(x=z_j-y_j)P(Y=y_j)\)</span></p>
<h4 id="二维连续型随机向量函数的分布密度">二维连续型随机向量函数的分布密度</h4>
<blockquote>
<p><em>review</em>: <span class="math inline">\(x\sim f(x)\)</span> 求 <span class="math inline">\(Y=h(X)\)</span> 密度：<span class="math inline">\(F_X(y)=P(h(x)\le y) = \int f(y)\mathrm dy\)</span></p>
<p><em>solution</em>: <span class="math inline">\(F_Z(z)=P(Z\le z)=\iint_{g(x,y)\le z} f(x,y)\mathrm dx\mathrm dy\)</span></p>
</blockquote>
<h5 id="zxy">z=x+y</h5>
<p><span class="math display">\[
\begin{aligned}
F(z)&amp;=P(X+Y\le Z)&amp;\\
&amp;=\int_{-\infty}^{+\infty}\int^{z-y}_{-\infty} f(x,y)\mathrm dx\mathrm dy\\
\Rightarrow\qquad&amp;
p(z) = \int_{-\infty}^{+\infty} p(x,z-x)\mathrm dx = \int_{-\infty}^{+\infty} p(z-y, y)\mathrm dy
\end{aligned}
\]</span></p>
<p><strong>Thm</strong>（卷积公式）X，Y 相互独立，则对于<span class="math inline">\(Z=X+Y\)</span>：<span class="math inline">\(p_Z(z)=\int_{-\infty}^{+\infty}p(x)p(z-x)\mathrm dx=\int_{-\infty}^{+\infty}p(z-y)p(y)\mathrm dy\)</span></p>
<ul>
<li><p>正态分布具有可加性：<span class="math inline">\(X_1\sim N(\mu_1, \sigma_1), X_2\sim N(\mu_2,\sigma_2),...\)</span> 则 <span class="math inline">\(\sum c_iX_i\sim N(\sum c_i\mu_i,\sum c_i^2\sigma_i^2)\)</span></p></li>
<li><p><span class="math inline">\(\Gamma\)</span> 函数与卡方分布 <span class="math inline">\(X\sim\chi(n) = P(n/2, 1/2)\)</span>，<span class="math inline">\(x_1...x_n~\sim N(0,1)\)</span>，<span class="math inline">\(\sum x_i^2\sim \chi(n)\)</span></p>
<ul>
<li><span class="math inline">\(X,Y\sim \Gamma(\alpha_{1,2},\beta)\rightarrow X+Y\sim\Gamma(\alpha_1+\alpha_2,\beta)\)</span></li>
</ul></li>
</ul>
<p><strong><em>一般步骤</em></strong></p>
<ol type="1">
<li>先求出分布函数</li>
<li>关于 z 求导数得到结果</li>
</ol>
<h5 id="最大值最小值函数">最大值最小值函数</h5>
<p><em>相互独立情况下</em>：</p>
<p><span class="math display">\[
\begin{aligned}
  &amp;N=\min\{X_i\}, M = \max\{X_i\}\\
  &amp;F_{\min}(z)=1-\Pi[1-F_{X_i}(z)]\\
  &amp;F_{\max}(z)=\Pi F_{X_i}(z)
\end{aligned}
\]</span></p>
<p><em>独立同分布的情况下</em>：</p>
<p><span class="math display">\[
\begin{aligned}
  &amp;F_{\min}(z)=1-[1-F(z)]^n\\
  &amp;F_{\max}(z)=F(z)^n\\
  &amp;f_{\min}(z) =n[1-F(z)]^{n-1} f(z)\\
  &amp;f_{\max}(z) =nF(z)^{n-1} f(z)
\end{aligned}
\]</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「概率统计与随机过程」 4 - 随机向量的数字特征</title>
    <url>/2020/12/02/study/Math/Probabilities/notes4/</url>
    <content><![CDATA[<p>随机向量的数字特征</p>
<span id="more"></span>
<h2 id="随机向量的数字特征">随机向量的数字特征</h2>
<h3 id="随机变量的数学期望">随机变量的数学期望</h3>
<h4 id="数学期望的定义">数学期望的定义</h4>
<p><strong>Def</strong>（离散型随机变量期望的定义）设离散随机变量的分布列为：<span class="math inline">\(P(X=x_i)=p_i\)</span> 若级数 <span class="math inline">\(\sum x_ip_i\)</span> <em>绝对收敛</em>，则称该级数为 <span class="math inline">\(X\)</span> 的数学期望，记为 <span class="math inline">\(E(X)=\sum x_ip_i\)</span></p>
<blockquote>
<ul>
<li>与项的排列顺序无关</li>
<li>有限个值 → 必然存在</li>
</ul>
</blockquote>
<h4 id="连续型随机变量">连续型随机变量</h4>
<p><strong>Def</strong>（连续型随机变量期望的定义）设连续型随机变量，其密度函数为：<span class="math inline">\(f(x)\)</span> 若积分 <span class="math inline">\(\int_{-\infty}^\infty xf(x)\mathrm dx\)</span> <em>绝对收敛</em>，则称该积分为 <span class="math inline">\(X\)</span> 的数学期望，记为<span class="math inline">\(E(X)=\int_{-\infty}^{+\infty}xf(x)\mathrm dx\)</span></p>
<ul>
<li>例如柯西分布：<span class="math inline">\(F(x)=\frac{1}{\pi}(\arctan x+\frac{\pi}{2})\)</span> 不存在数学期望</li>
</ul>
<h4 id="随机变量函数的数学期望">随机变量函数的数学期望</h4>
<p><strong>Thm</strong>：若 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(X\)</span> 的函数 <span class="math inline">\(Y=g(X)\)</span>，绝对收敛的情况下：</p>
<ol type="1">
<li><span class="math inline">\(E(Y)=\sum g(x_i)P(X=x_i)\)</span></li>
<li><span class="math inline">\(E(Y)=\int g(x)f(x)\mathrm dx\)</span></li>
</ol>
<p><strong>Thm</strong>：若 <span class="math inline">\(Z=g(X,Y)\)</span>，则：</p>
<ol type="1">
<li><span class="math inline">\(Eg(X,Y)=\sum\sum g(x _ i,y _ j)p_{ij}\)</span></li>
<li><span class="math inline">\(Eg(X,Y)=\iint g(x,y)f(x,y)\mathrm dx\mathrm dy\)</span></li>
</ol>
<p><em>期望的性质</em>：</p>
<ul>
<li><span class="math inline">\(E(·)\)</span>是线性的：<span class="math inline">\(E(aX+bY+c)=aEX+bEY+c\)</span></li>
<li><span class="math inline">\(X,Y\)</span> 独立 则：<span class="math inline">\(E(XY) = E(X)E(Y)\)</span></li>
</ul>
<h3 id="随机变量的方差">随机变量的方差</h3>
<h4 id="方差的定义">方差的定义</h4>
<p><strong>Def</strong>（方差）若随机变量 <span class="math inline">\(X\)</span> 的数学期望存在，则 <span class="math inline">\(E(X-EX)^2\)</span> 为 <span class="math inline">\(X\)</span> 的方差随机变量偏离中心的程度 <span class="math inline">\(DX=Var(X)=E(X-EX)^2\)</span></p>
<ol type="1">
<li>标准差：<span class="math inline">\(\sigma(X)\)</span></li>
<li>计算方法：<span class="math inline">\(DX=EX^2-(EX)^2\)</span></li>
</ol>
<h5 id="方差的性质">方差的性质</h5>
<ol type="1">
<li>对于常数 c <span class="math inline">\(Dc=0\)</span></li>
<li><span class="math inline">\(D(aX+b)=a^2DX\)</span></li>
<li><span class="math inline">\(X,Y\)</span> 独立，则 <span class="math inline">\(D(X\pm Y)=DX+DY\)</span>
<ul>
<li><span class="math inline">\(D(\sum c_iX_i)=\sum c_i^2DX_i\)</span></li>
</ul></li>
<li><span class="math inline">\(DX=E(X^2)-(EX)^2\)</span></li>
<li><span class="math inline">\(DX=0\iff P(X=EX=c)=1\)</span></li>
<li><span class="math inline">\(X_i\sim N(\mu_i,\sigma_i^2)\)</span> 则：<span class="math inline">\(\sum c_iX_i\sim N(\sum c_iu_i, \sum c_i^2 \sigma_i^2)\)</span></li>
</ol>
<p><strong>Thm</strong> 切比雪夫不等式：<span class="math inline">\(\forall\varepsilon&gt;0, E(X)=\mu,DX=\sigma^2\Rightarrow P(|X-\mu|&gt;\varepsilon)\le \sigma^2/\varepsilon^2\)</span></p>
<h3 id="协方差与相关系数">协方差与相关系数</h3>
<h4 id="定义">定义</h4>
<p><strong>Def</strong>（协方差）设 <span class="math inline">\(X，Y\)</span> 是两个随机变量，<span class="math inline">\(E(X-EX)(Y-EY)\)</span> 存在，则<span class="math inline">\(\displaystyle Cov(x,y)=E(X-EX)(Y-EY)\)</span> <strong>Def</strong>（相关系数）<span class="math inline">\(\displaystyle\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{DX}\sqrt{DY}}\)</span></p>
<p><strong>Thm</strong>：<span class="math inline">\(D(X\pm Y)=DX+DY+2Cov(X,Y)\)</span></p>
<ul>
<li>推广至 n 个：<span class="math inline">\(D(\sum c_iX_i)=\sum c_i^2DX_i+2\sum c_ic_jCov(X_i,X_j)\)</span></li>
<li>常用计算公式：<span class="math inline">\(Cov(X,Y)=EXY-EX\cdot EY\)</span></li>
</ul>
<h4 id="性质">性质</h4>
<ul>
<li><span class="math inline">\(Cov(X,Y)=Cov(Y,X)\)</span></li>
<li><span class="math inline">\(DX=Cov(X,X)\)</span></li>
<li><span class="math inline">\(Cov(X,const)=0\)</span></li>
<li><span class="math inline">\(Cov(X+Y,Z)=Cov(X,Z)+Cov(Y,Z)\)</span>
<ul>
<li><span class="math inline">\(Cov(\sum c_iX_i,Y)=\sum c_i Cov(X_i,Y)\)</span></li>
</ul></li>
<li><span class="math inline">\(Y_i=a_iX+b_i\rightarrow \rho_{Y_1Y_2}=\frac{a_1a_2}{|a_1a_2|}\rho_{X_1X_2}\)</span></li>
<li><span class="math inline">\(Y=aX+b\rightarrow \rho_{XY}=\pm1\)</span></li>
<li><span class="math inline">\(|\rho_{XY}|=1\)</span> 的充要条件为 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 以概率 <span class="math inline">\(1\)</span> 线性相关： 存在常数 <span class="math inline">\(a,b,a\ne0\)</span> 使得 <span class="math inline">\(P(Y=aX+b)=1\)</span></li>
</ul>
<h4 id="独立与不相关的关系">独立与不相关的关系</h4>
<ul>
<li><strong>Def</strong>（不相关）：若<span class="math inline">\(\rho_{XY}=0\)</span> （<span class="math inline">\(Cov(X,Y)=0\)</span>） 则称 <span class="math inline">\(X,Y\)</span> 不相关。</li>
<li><strong>Thm</strong>：相互独立 则 不相关 （反之不一定成立）</li>
</ul>
<p><em>特殊的</em>：</p>
<ol type="1">
<li>二维正态随机变量：相关<span class="math inline">\(\iff\)</span>独立<span class="math inline">\(\iff\rho=0\)</span></li>
<li><span class="math inline">\((0-1)\)</span> 分布：相关<span class="math inline">\(\iff\)</span>独立<span class="math inline">\(\iff\rho=0\)</span></li>
</ol>
<h3 id="协方差矩阵">协方差矩阵</h3>
<h4 id="矩">矩</h4>
<p><strong>Def</strong>（矩）若 <span class="math inline">\(X,Y\)</span> 为随机变量 1. <span class="math inline">\(\alpha_k=EX^k\)</span> 称为 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(k\)</span> 阶原点矩</p>
<p><span class="math inline">\(\alpha_1=EX\)</span></p>
<ol start="2" type="1">
<li><p><span class="math inline">\(\beta_k=E(X-EX)^k\)</span> 称为 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(k\)</span> 阶中心矩</p>
<p><span class="math inline">\(\beta_1=0,\quad\beta_2=DX\)</span></p></li>
<li><p><span class="math inline">\(k,l\in N_+\)</span> 则 <span class="math inline">\(\gamma_{kl} = E(X-EX)^k(Y-EY)^l\)</span> 称为 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的 <span class="math inline">\(k+l\)</span> 阶混合中心矩</p>
<p><span class="math inline">\(\gamma_{11} = Cov(X,Y)\)</span></p></li>
</ol>
<h4 id="协方差矩阵-1">协方差矩阵</h4>
<ul>
<li><strong>Def</strong>（协方差矩阵）<span class="math inline">\(\mathbf X=(X_1,X_2,\dots,X_n)^T\)</span> 为 n 维随机向量
<ol type="1">
<li><span class="math inline">\(\mu=(\mu_1,\mu_2,\dots)^T\)</span> 为随机向量 <span class="math inline">\(X\)</span> 的数学期望</li>
<li><span class="math inline">\(\sigma^2=(\sigma_1^2, \sigma_2^2,\dots)^T\)</span>为随机向量 <span class="math inline">\(X\)</span> 的方差</li>
<li>协方差矩阵为：</li>
</ol></li>
</ul>
<p><span class="math display">\[
\varSigma=\left(\begin{matrix}
  \sigma_{11}&amp; \sigma_{12}&amp;\dots&amp; \sigma_{1n}\\
  \sigma_{21}&amp; \sigma_{22}&amp;\dots&amp; \sigma_{2n}\\
  \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
  \sigma_{n1}&amp; \sigma_{n2}&amp;\dots&amp; \sigma_{nn}\\
\end{matrix}\right)
\]</span></p>
<h5 id="性质-1">性质</h5>
<ul>
<li><span class="math inline">\(\mathbf{diag}\varSigma=\sigma^2\)</span></li>
<li>半正定的对称阵，即<span class="math inline">\(\varSigma\in S_+\)</span></li>
<li><span class="math inline">\(\sigma^2_{ij}\le \sigma_{ii}\sigma_{jj}\)</span></li>
<li>n 维正态分布：<span class="math inline">\(f(\mathbb{x})=\frac{1}{(2\pi)^{n/2}|\sigma|^{1/2}}\exp\{-\frac{1}{2} (x-\mu)^T\Sigma^{-1}(x-\mu)\}\)</span></li>
</ul>
<div class="note"><p>primary</p></div>
<h3 id="summary">Summary</h3>
<h4 id="分布">0 - 1 分布</h4>
<ol type="1">
<li>形式：<span class="math inline">\(P(X=0)=1-p, P(X=1)=p\)</span></li>
<li>期望：<span class="math inline">\(EX=p\)</span></li>
<li>方差：<span class="math inline">\(DX=p(1-p)\)</span></li>
</ol>
<h4 id="二项分布-bnp">二项分布 <span class="math inline">\(b(n,p)\)</span></h4>
<ol type="1">
<li>形式：<span class="math inline">\(P(X=k) = C_n^kp^k(1-p)^k\)</span></li>
<li>期望：<span class="math inline">\(EX=np\)</span></li>
<li>方差：<span class="math inline">\(DX=np(1-p)\)</span></li>
</ol>
<h4 id="泊松分布-plambda">泊松分布 <span class="math inline">\(P(\lambda)\)</span></h4>
<ol type="1">
<li>形式：<span class="math inline">\(P(X=k)=\frac{\lambda^k e^{-\lambda}}{k!}\)</span></li>
<li>期望：<span class="math inline">\(EX=\lambda\)</span></li>
<li>方差：<span class="math inline">\(DX=\lambda\)</span></li>
</ol>
<h4 id="超几何分布-hnmn----not-important">超几何分布 <span class="math inline">\(H(N,M,n)\)</span> <code>-- not important</code></h4>
<ol type="1">
<li>形式：<span class="math inline">\(P(X=k)=\frac{C_M^kC_{N-M}^{N-k}}{C_N^n}\)</span></li>
<li>期望：<span class="math inline">\(EX=nM/N\)</span></li>
<li>方差：<span class="math inline">\(DX=\frac{nM(N-n)(N-M)}{N^2(N-1)}\)</span></li>
</ol>
<h4 id="均匀分布-uab">均匀分布 <span class="math inline">\(U(a,b)\)</span></h4>
<ol type="1">
<li>形式：<span class="math inline">\(P(X=x) = 1/(b-a)\quad if ~ ~ x \in [a,b]\)</span></li>
<li>期望：<span class="math inline">\(EX=\frac{1}{2}(a+b)\)</span></li>
<li>方差：<span class="math inline">\(DX=\frac{(b-a)^2}{12}\)</span></li>
</ol>
<h4 id="指数分布-elambda">指数分布 <span class="math inline">\(e(\lambda)\)</span></h4>
<ol type="1">
<li>形式：<span class="math inline">\(P(X=x)=\lambda e^{-\lambda x}\)</span></li>
<li>期望：<span class="math inline">\(EX=1/\lambda\)</span></li>
<li>方差：<span class="math inline">\(DX=1/\lambda^2\)</span></li>
</ol>
<h4 id="高斯分布正态分布-nmusigma2">高斯分布（正态分布） <span class="math inline">\(N(\mu,\sigma^2)\)</span></h4>
<ol type="1">
<li>形式：<span class="math inline">\(P(X=x)=\frac{1}{\sqrt{2\pi}\sigma}\exp[-\frac{(x-\mu)^2}{2\sigma^2}]\)</span></li>
<li>期望：<span class="math inline">\(EX=\mu\)</span></li>
<li>方差：<span class="math inline">\(DX=\sigma^2\)</span></li>
</ol>
<h4 id="卡方分布-chi2n">卡方分布 <span class="math inline">\(\chi^2(n)\)</span></h4>
<ol type="1">
<li>形式（自由度为 n）：<span class="math inline">\(\chi^2=\sum_{i=1}^nX_i^2,~X_i\sim N(0,1)\)</span></li>
<li>期望：<span class="math inline">\(E\chi^2=n\)</span></li>
<li>方差：<span class="math inline">\(E\chi^2=2n\)</span></li>
</ol>
<h4 id="t-分布">t-分布</h4>
<ol type="1">
<li>形式（自由度为 n）：<span class="math inline">\(T=\frac{X}{\sqrt{Y/n}},~X\sim N(0,1),~Y\sim \chi^2(n)\)</span></li>
</ol>
<h4 id="f-分布">F-分布</h4>
<ol type="1">
<li>形式（自由度为 m, n）：<span class="math inline">\(F=\frac{X/m}{Y/n},~X\sim \chi^2(m),~Y\sim\chi^2(n)\)</span></li>
</ol>
<!-- TODO: endnote-->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「概率统计与随机过程」 5 - 极限定理</title>
    <url>/2020/12/11/study/Math/Probabilities/notes5/</url>
    <content><![CDATA[<p>极限定理</p>
<span id="more"></span>
<h2 id="极限定理">极限定理</h2>
<h3 id="大数定律">大数定律</h3>
<p><strong>Def</strong>（依概率收敛）设 <span class="math inline">\(X_1, X_2, X_3, ...\)</span> 为一随机变量序列，若存在随机变量 X，使得对于任意整数 <span class="math inline">\(\varepsilon &gt; 0\)</span> 总有: <span class="math inline">\(\lim_{n\rightarrow \infty} P(|X_n-X|\ge \varepsilon)=0\)</span> 则称随机变量序列 <span class="math inline">\(\\{X_n\\}_{n\ge 1}\)</span> 依概率收敛于 <span class="math inline">\(X\)</span></p>
<ul>
<li><span class="math inline">\(\lim_{n\rightarrow \infty} X_n=X(P)\)</span></li>
<li><span class="math inline">\(X_n\mathop\longrightarrow\limits^PX.\)</span></li>
</ul>
<p><strong>Def</strong>（大数定律）设 <span class="math inline">\(X_1, X_2, \dots\)</span> 为一随机变量序列，数学期望 <span class="math inline">\(EX_n\)</span> 存在，记 <span class="math inline">\(\bar X = \frac 1 n \sum X_i\)</span> 若 <span class="math inline">\(\displaystyle\lim_{n\rightarrow\infty}\bar X_n=E\bar X_n\quad(P)\)</span>则称随机变量序列 <span class="math inline">\(\{X_n\}\)</span> 服从大数定律，或者说大数法则成立</p>
<p><strong>Thm</strong>（切比雪夫大数定律）设 <span class="math inline">\(X_1, X_2, \dots\)</span> 为一相互独立的随机变量序列，数学期望 <span class="math inline">\(EX_n\)</span>，方差 <span class="math inline">\(DX_n\)</span> 存在，且方差一致有界，则 <span class="math inline">\(\{X_n\}\)</span> 服从大数定律，对于任意的 <span class="math inline">\(\varepsilon&gt;0,\lim P(|\frac 1 n \sum X_i - \frac 1 n \sum EX_i|\ge \varepsilon)=0\)</span></p>
<p><strong>Thm</strong>（辛钦大数定律）设 <span class="math inline">\(X_i\)</span> 是独立同分布的随机变量序列，公共数学期望为<span class="math inline">\(\mu\)</span> 则其满足大数定律:<span class="math inline">\(\lim_{n\rightarrow \infty}P(|\frac 1 n \sum X_i-\mu|\ge \varepsilon)=0\)</span></p>
<p><strong>Thm</strong>（伯努利大数定律）设 <span class="math inline">\(n_A\)</span> 是 <span class="math inline">\(n\)</span> 次独立重复试验中 <span class="math inline">\(A\)</span> 发生的次数，<span class="math inline">\(p\)</span>为发生概率，则对于任意正数 <span class="math inline">\(\varepsilon &gt; 0\)</span> 有 <span class="math inline">\(\lim_{n\rightarrow \infty}P(|\frac{n_A}{n}-p|&lt;\varepsilon)=1\)</span></p>
<h3 id="中心极限定理">中心极限定理</h3>
<p><strong>Def</strong>（中心极限定理）设 <span class="math inline">\(X_i\)</span> 为相互独立的随机变量序列，数学期望 <span class="math inline">\(EX_n=\mu_n\)</span> 方差 <span class="math inline">\(DX_n=\sigma_n^2, n= 1, 2, ...\)</span>都存在，记：</p>
<p><span class="math display">\[B_n^2=\sum_{i=1}^2\sigma_i^2,\quad Y_n=\sum_{i=1}^n \frac{X_i-\mu_i}{B_n},\quad n = 1,2,...\]</span></p>
<p>则 <span class="math inline">\(Y_n\)</span> 依概率收敛到标准正态分布 <span class="math inline">\(N(0,1)\)</span>：</p>
<p><span class="math display">\[\lim_{n\rightarrow \infty} P(Y_n\le x)=\lim_{n\rightarrow \infty}P(\frac{(\sum X_i-\sum EX_i)}{\sqrt{\sum DX_i}}\le x)=\varPhi(x)\]</span></p>
<p><strong>Thm</strong>（林德伯格定理）设 <span class="math inline">\(X_1, X_2,...\)</span> 为<em>相互独立</em>的随机变量序列，且满足：</p>
<p><span class="math display">\[\forall \varepsilon,\displaystyle\lim _{n\rightarrow \infty}\frac 1 {B_n^2}\sum\int_{|x-\mu_k|\ge \varepsilon B_n}(x-\mu_k)^2\mathrm dF_k(x)=0\]</span></p>
<p>其中 <span class="math inline">\(F_k(x)\)</span> 为分布函数，<span class="math inline">\(\mu_k=EX_k,\sigma_k^2=DX_k,B_n^2=\sum \sigma_k^2\)</span>，则 <span class="math inline">\(\{X_n\}\)</span> 服从中心极限定理</p>
<p><strong>Thm</strong>（列维-林德伯格定理）设 <span class="math inline">\(X_1,...\)</span> 为<em>相互独立同分布</em>的随机变量序列，且</p>
<p><span class="math display">\[EX_n=\mu, DX_n=\sigma^2&lt;+\infty\]</span></p>
<p>则随机变量序列 <span class="math inline">\(\{X_n\}\)</span> 服从中心极限定理。</p>
<p>从而，<span class="math inline">\(n\)</span> 充分大时：<span class="math inline">\(\displaystyle P(x_1&lt;\sum X_i\le x_2)\approx\varPhi(\frac{x_2-n\mu}{\sigma\sqrt n})-\varPhi(\frac{x_1-n\mu}{\sigma\sqrt n})\)</span></p>
<p><strong>Thm</strong>（棣莫弗-拉普拉斯中心极限定理）若 <span class="math inline">\(\mu_1, ...\)</span> 服从二项分布 <span class="math inline">\(b(n,p),q=1-p\)</span> 则：</p>
<p><span class="math display">\[\displaystyle\lim_{n\rightarrow \infty}P(\frac{\mu_n-np}{\sqrt{npq}}\le x)=\varPhi(x)\]</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「概率统计与随机过程」 6 - 抽样分布</title>
    <url>/2020/12/18/study/Math/Probabilities/notes6/</url>
    <content><![CDATA[<p>Chapter 6 抽样分布</p>
<span id="more"></span>
<h2 id="抽样分布">抽样分布</h2>
<h3 id="基本概念">基本概念</h3>
<ol type="1">
<li><p><strong>总体</strong>：在一个统计问题中，研究对象的全体。（所研究对象的某个（某些）数量指标的全体，一个随机变量（多维随机变量）记为 <span class="math inline">\(X\)</span>）</p></li>
<li><p><strong>样本</strong>：</p>
<ul>
<li>分组样本</li>
<li>完全样本</li>
</ul></li>
</ol>
<p><strong>Def</strong>（简单随机样本）设总体 <span class="math inline">\(X\)</span> 的分布为 <span class="math inline">\(F(X)\)</span>，<span class="math inline">\(X_1, X_2,...,X_n\)</span> 是是相互独立和总体同分布的随机变量，则称其为来自总体 X 容量为 n 的简单随机样本。</p>
<p><em>性质</em>：</p>
<ul>
<li>样本联合分布函数为 <span class="math inline">\(F(x_1,\dots,x_n)=\prod F(x_i)\)</span></li>
<li>简单随机样本的联合分布律：<span class="math inline">\(P(X_1=x^{(1)}, \dots, X_n=x^{(n)})=\prod P(X_i=x^{(i)})\)</span></li>
</ul>
<h4 id="统计量">统计量</h4>
<p><strong>Def</strong>（统计量）设 <span class="math inline">\(X_1, \dots, X_n\)</span> 为取自总体的样本，若样本函数 <span class="math inline">\(T=T(X_1, \dots, X_n)\)</span> 不含有任何未知的参数。则称 <span class="math inline">\(T\)</span> 为统计量。统计量的分布称为抽样分布。</p>
<p><em>例如</em>：</p>
<ul>
<li><strong>Def</strong>（样本均值）<span class="math inline">\(\bar X=\frac{1}{n}\sum_1^nX_i\)</span> 为样本均值</li>
<li><strong>Def</strong>（样本方差）<span class="math inline">\(S_n^2=\frac{1}{n-1}\sum_{i=1}^n(X_i-\bar X)^2\)</span> 为样本方差。<span class="math inline">\(S=\sqrt{S_n^2}\)</span> 为样本标准差</li>
<li><strong>Def</strong>（偏差平方和）：<span class="math inline">\(\sum(X_i-\bar X)^2=\sum X_i^2-\frac{1}{n}(\sum X_i)^2=\sum X_i^2-n\bar X^2\)</span></li>
<li><strong>Def</strong>（原点矩、中心矩）<span class="math inline">\(A_k=\frac{1}{n}\sum X_i^k,~B_k=\frac{1}{n}\sum (X_i-\bar X)^k\)</span></li>
</ul>
<p><strong>Thm</strong>：对于总体 <span class="math inline">\(X\)</span>，均值为 <span class="math inline">\(\mu=EX\)</span> 方差 <span class="math inline">\(\sigma^2\)</span> 都存在，<span class="math inline">\(X_1,\dots,X_n\)</span> 是来自总体容量为 <span class="math inline">\(n\)</span> 的简单随机样本。则 - <span class="math inline">\(E\bar X=\mu\)</span> - <span class="math inline">\(D\bar X=\sigma^2/n\)</span> - <span class="math inline">\(ES_n^2=\sigma^2\)</span></p>
<h3 id="常用分布">常用分布</h3>
<h4 id="卡方分布">卡方分布</h4>
<p><strong>Def</strong>：设<span class="math inline">\(X_1,\dots,X_n\)</span> iid，<span class="math inline">\(N(0,1)\)</span> 的随机变量，则 <span class="math inline">\(\chi^2=\sigma_{i=1}^nX_i^2\)</span> 服从自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\chi^2\)</span>-分布。</p>
<p><strong>Thm</strong>：<span class="math inline">\(\chi^2\sim \chi^2(n)\)</span> 则：<span class="math inline">\(f(x)=\frac{1}{2^{n/2}\Gamma(n/2)}e^{n/2-1}e^{-x/2},~x&gt;0\)</span></p>
<p><strong>Thm</strong>（可加性）若<span class="math inline">\(X_1\sim \chi^2(n),~X_2\sim \chi^2(n)\)</span> 且 <span class="math inline">\(X_1,X_2\)</span> 独立，则<span class="math inline">\(X_1+X_2\sim\chi^2(m+n)\)</span></p>
<p><strong>Thm</strong>（数字特征）若<span class="math inline">\(X\sim \chi^2(m)\)</span> 则：<span class="math inline">\(EX=n,DX=2n\)</span></p>
<p><strong>Def</strong>（上侧 <span class="math inline">\(\alpha\)</span> 分位点）：<span class="math inline">\(P(\chi^2\ge\chi^2_\alpha(n))=\alpha\)</span> 则称 <span class="math inline">\(\chi^2(n)\)</span> 为自由度为 n 的 <span class="math inline">\(\chi^2\)</span>-分布的上侧<span class="math inline">\(\alpha\)</span>-分位点</p>
<h4 id="t-分布">t-分布</h4>
<p><strong>Def</strong>：<span class="math inline">\(X\)</span> 是标准正态分布，<span class="math inline">\(Y\)</span>服从自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\chi^2\)</span> 分布且相互独立，称随机变量 <span class="math inline">\(T=\frac{X}{\sqrt{Y/n}}\)</span> 服从自由度为 <span class="math inline">\(n\)</span> 的 t-分布。</p>
<p><strong>Thm</strong>：概率密度为</p>
<p><span class="math display">\[
f(t)=\frac{\Gamma(\frac{n+1}{2})}{\Gamma(\frac{n}{2})\sqrt{n\pi}}(1+\frac{t^2}{n})^{-\frac{n+1}{2}}
\]</span></p>
<p><strong>Def</strong>（分位点）上侧<span class="math inline">\(\alpha\)</span>-分位点</p>
<h4 id="f-分布">F-分布</h4>
<p><span class="math inline">\(X\sim \chi^2(m),~Y\sim\chi^2(n)\)</span> idd. 称<span class="math inline">\(F=\frac{X/m}{Y/n}\)</span>服从自由度为 F-分布</p>
<p><strong>Thm</strong>：密度函数、分位点 <span class="math inline">\(F_{1-\alpha}(m,n)=1/F_\alpha(n,m)\)</span></p>
<h3 id="正态总体中统计量的分布">正态总体中统计量的分布</h3>
<p><strong>Thm</strong>（单个正态总体统计量的分布）：设<span class="math inline">\(X\)</span> 服从正态 分布 <span class="math inline">\(N(\mu,\sigma^2),X_1,\dots,X_n\)</span> 是来自总体 <span class="math inline">\(X\)</span> 容量为 <span class="math inline">\(n\)</span> 的简单随机样本：</p>
<ol type="1">
<li><span class="math inline">\(\displaystyle U=\frac{\bar X-\mu}{\sigma/\sqrt{n}}\sim N(0,1)\)</span></li>
<li><span class="math inline">\(\displaystyle\bar X\)</span> 与 <span class="math inline">\(S^2\)</span> 独立</li>
<li><span class="math inline">\(\displaystyle W=\frac{(n-1)S^2}{\sigma^2}=\sum (\frac{X-\bar X}{\sigma})^2\sim \chi^2(n-1)\)</span></li>
<li><span class="math inline">\(\displaystyle T=\frac{\bar X-\mu}{S}\sqrt{n}\sim t(n-1)\)</span></li>
</ol>
<p><strong>Thm</strong>（两个正态总体统计量的分布）：</p>
<ol type="1">
<li><span class="math inline">\(\displaystyle\frac{\bar X-\bar Y-(\mu_1-\mu_2)}{\sqrt{\sigma_1^2/m+\sigma_2^2/n}}\sim N(0,1)\)</span></li>
<li><span class="math inline">\(\displaystyle\frac{(m-1)S_{1m}^2}{\sigma^2_1}+\frac{(n-1)S_{2n}^2}{\sigma^2_2}\sim\chi^2(m+n-2)\)</span></li>
<li><span class="math inline">\(\displaystyle\sigma_1=\sigma_2=\sigma\)</span> 则 <span class="math inline">\(\frac{\bar X-\bar Y-(\mu_1-\mu_2)}{S_\omega\sqrt{1/m+1/n}}\sim t(m+n-2)\)</span> 其中 <span class="math inline">\(S_\omega=\frac{(m-1)S_{1m}^2+(n-1)S_{2n}^2}{m+n-2}\)</span></li>
<li><span class="math inline">\(\displaystyle\frac{S_{1m}^2/\sigma_1^2}{S^2_{2n}/\sigma_2^2}\sim F(m-1,n-1)\)</span></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「随机数学与数理统计」7 - 参数估计</title>
    <url>/2020/12/23/study/Math/Probabilities/notes7/</url>
    <content><![CDATA[<ol type="1">
<li>矩估计</li>
<li>极大似然估计</li>
<li>评判估计量的方法</li>
</ol>
<span id="more"></span>
<h2 id="参数估计">参数估计</h2>
<h3 id="两种常用的参数估计方法">两种常用的参数估计方法</h3>
<h4 id="矩估计法">矩估计法</h4>
<blockquote>
<ul>
<li>辛钦大数定律：样本较大时，<span class="math inline">\(A_r=\frac{1}{n}\sum_{i=1}^nX_i^r\rightarrow EX_r\)</span></li>
<li>格里汶科定理：格里汶科定理是指当样本容量n→∞时，经验分布函数以概率1一致收敛于总体的分布函数。</li>
</ul>
</blockquote>
<p><strong>Def</strong>（矩估计）设总体 <span class="math inline">\(X\)</span> 的分布 <span class="math inline">\(f(x;\theta_1,...,\theta_k)\)</span> 中有 <span class="math inline">\(k\)</span> 个位置的参数 <span class="math inline">\(\theta_{1..k}\)</span>，<span class="math inline">\((X_1,...,X_n)\)</span> 时总体 <span class="math inline">\(X\)</span> 的样本。若总体 <span class="math inline">\(X\)</span> 的<span class="math inline">\(k\)</span> 阶原点矩 <span class="math inline">\(EX_k\)</span> 存在，并且 <span class="math inline">\(\alpha_r(\theta_1,...\theta_k)=EX^r\)</span> 时总体 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(r\)</span> 阶原点矩，记 <span class="math inline">\(A_r\)</span> 为样本的 <span class="math inline">\(r\)</span> 阶原点矩，由：</p>
<p><span class="math display">\[
\alpha_r(\theta_1,\dots, \theta_k)=A_r(\theta_1,\dots,\theta_r)\qquad r=1,...,k
\]</span></p>
<p>解得的 <span class="math inline">\(\hat\theta_r=\hat\theta_r(X_1,...,X_k)\)</span>，并以 <span class="math inline">\(\hat\theta_r\)</span> 作为参数的估计量，称 <span class="math inline">\(\hat\theta_r\)</span> 为参数 <span class="math inline">\(\theta_r\)</span> 的估计量。</p>
<blockquote>
<ol type="1">
<li>不唯一（依赖于 r）</li>
<li><span class="math inline">\(EX^k\)</span> 有限</li>
<li>要求 <span class="math inline">\(n\)</span> 比较大</li>
</ol>
</blockquote>
<h4 id="极大似然估计">极大似然估计</h4>
<blockquote>
<p>基本思想：<span class="math inline">\(X\sim P(X;\theta)\rightarrow P(X=x)\)</span> 使得：<span class="math inline">\(\hat\theta\)</span> 能使得出现样本 <span class="math inline">\(X_{1..k}\)</span> 的概率最大</p>
</blockquote>
<p><strong>Def</strong>（似然函数）设总体 <span class="math inline">\(X\)</span> 的分布为 <span class="math inline">\(f(x;\theta_1,\dots,\theta_k)\)</span>，其中 <span class="math inline">\(\theta_{1\dots k}\)</span> 为未知参数，<span class="math inline">\((X_1,\dots,X_n)\)</span> 为简单随机样本，称</p>
<p><span class="math display">\[
L(\theta_1,...,\theta_k)=\prod_{i=1}^nf(x_i;\theta_1,...,\theta_k)
\]</span></p>
<p><strong>Def</strong>（MLE-极大似然估计）称 <span class="math inline">\(\hat\theta =\mathrm{argmax} L(\theta)\)</span> 为 <span class="math inline">\(\theta\)</span> 最大似然估计量</p>
<blockquote>
<p>求法： 1. 写似然函数 2. 优化似然函数</p>
<p>例如：假设总体服从参数为 <span class="math inline">\(p\)</span> 的 0-1 分布，<span class="math inline">\((X_1,...,X_n)\)</span> 为样本，求 <span class="math inline">\(p\)</span> 的最大似然估计</p>
<ol type="1">
<li>似然函数为：<span class="math inline">\(L(x_1,...,x_n;p)=p^{n\bar X}(1-p)^{n-n\bar X}\)</span></li>
<li>取对数：<span class="math inline">\(\ln L=n\bar X\ln p+n(1-\bar X)\ln (1-p)\)</span></li>
<li>对 <span class="math inline">\(p\)</span> 求偏导，取得极值 <span class="math inline">\(\hat p=\bar X\)</span></li>
</ol>
</blockquote>
<p><em>常见的有</em>：</p>
<ol type="1">
<li><span class="math inline">\(\displaystyle X\sim P(\lambda)\Rightarrow \hat \lambda=\bar X\)</span></li>
<li><span class="math inline">\(\displaystyle X\sim e(\lambda)\Rightarrow \hat \lambda=\frac{1}{\bar{X}}\)</span></li>
<li>0-1 分布：<span class="math inline">\(\hat p = \bar X\)</span></li>
<li><span class="math inline">\(X\sim U(a,b)\Rightarrow,a=\min x_i,b=\max x_i,\quad i = 1,...,n\)</span></li>
</ol>
<p><em>对于正态分布</em> <span class="math inline">\(\displaystyle X\sim N(\mu, \sigma^2)\)</span>，注意对于 <span class="math inline">\(\sigma^2\)</span> 整体求导，得到：</p>
<p><span class="math display">\[
\begin{cases}
\hat \mu=\bar X\\
\hat{\sigma^2} = \frac{1}{n}\sum_{i=1}^n(X_i-\bar X)^2=B_2
\end{cases}
\]</span></p>
<p><strong>Thm</strong>（最大似然估计的不变性）</p>
<h3 id="评选估计量的标准">评选估计量的标准</h3>
<ol type="1">
<li>无偏性</li>
<li>有效性</li>
<li>相合性</li>
</ol>
<h4 id="无偏性">无偏性</h4>
<p><strong>Def</strong>（无偏性）若 <span class="math inline">\(\hat\theta(X_1,...,X_n)\)</span> 为 <span class="math inline">\(\theta\)</span> 的估计量，若<span class="math inline">\(\hat \theta(X_1,..,X_n)\)</span> 的数学期望 <span class="math inline">\(E\hat\theta\)</span> 存在，且对于任一的 <span class="math inline">\(\theta \in \Theta\)</span>，<span class="math inline">\(E\hat\theta=\theta\)</span> 则称 <span class="math inline">\(\hat\theta\)</span> 为 <span class="math inline">\(\theta\)</span> 的一个无偏估计量</p>
<ul>
<li><span class="math inline">\(EX\)</span> 为<span class="math inline">\(\mu\)</span> 的无偏估计</li>
<li><span class="math inline">\(A_k\)</span> 为 <span class="math inline">\(EX^k\)</span> 的无偏估计</li>
<li><span class="math inline">\(ET^2\)</span> 为 <span class="math inline">\(\sigma^2\)</span> 的<strong>渐进</strong>无偏估计</li>
<li><span class="math inline">\(ES^2\)</span> 为 <span class="math inline">\(\sigma^2\)</span> 的无偏估计</li>
</ul>
<p><em>注意</em>：</p>
<ol type="1">
<li>若 <span class="math inline">\(\hat\theta\)</span> 是 <span class="math inline">\(\theta\)</span> 的无偏估计，<span class="math inline">\(\hat{g(\theta)}\)</span> 不一定是 <span class="math inline">\(g(\theta)\)</span> 的无偏估计。（除非 <span class="math inline">\(g(\theta)\)</span> 是线性的）</li>
<li>同一个参数的无偏估计不一定唯一</li>
</ol>
<h4 id="有效性">有效性</h4>
<p><strong>Def</strong>（有效性）若 <span class="math inline">\(\hat\theta_1,\hat\theta_2\)</span> 都是 <span class="math inline">\(\theta\)</span> 的无偏估计，若<span class="math inline">\(D\hat\theta_1\le D\hat\theta_2\)</span> 则称 <span class="math inline">\(\hat\theta_1\)</span> 比 <span class="math inline">\(\hat\theta_2\)</span> 有效。</p>
<h4 id="相合性">相合性</h4>
<p><strong>Def</strong>（相合性）若<span class="math inline">\(\hat\theta(X_1,...,X_n)\)</span> 是 <span class="math inline">\(\theta\)</span> 的一个估计量，若对于任一 <span class="math inline">\(\varepsilon&gt;0\)</span> 有：</p>
<p><span class="math display">\[
\lim_{n\rightarrow\infty}P(|\hat\theta-\theta|\ge \varepsilon)=0
\]</span></p>
<p>则称 <span class="math inline">\(\hat\theta\)</span> 为 <span class="math inline">\(\theta\)</span> 的相合估计量</p>
<p><strong>Def</strong>（均方误差）设 <span class="math inline">\(\hat\theta\)</span> 为 <span class="math inline">\(\theta\)</span> 的一个估计量，</p>
<ul>
<li>称 <span class="math inline">\(E(\hat\theta - \theta)^2\)</span> 为 <span class="math inline">\(\hat \theta\)</span> 估计 <span class="math inline">\(\theta\)</span> 时的均方误差</li>
<li>称 <span class="math inline">\(b=E(\hat\theta - \theta)\)</span> 为 <span class="math inline">\(\hat \theta\)</span> 估计 <span class="math inline">\(\theta\)</span> 时的偏差</li>
</ul>
<p><strong>Thm</strong>：若 <span class="math inline">\(D\hat\theta\)</span> 存在，则 <span class="math inline">\(E(\hat\theta-\theta)^2=D\hat\theta +b(\theta)^2\)</span></p>
<p><strong>Thm</strong>（Markov 不等式）<span class="math inline">\(E|X|^k\)</span> 则对与任意的 <span class="math inline">\(\varepsilon&gt;0\)</span>，有<span class="math inline">\(\displaystyle P(|X|&gt;\varepsilon)\le \frac{E|X|^k}{\varepsilon^k}\)</span></p>
<p><strong>Thm</strong>（相合性判定定理）若<span class="math inline">\(\lim D\hat\theta=\lim b(\theta)=\lim E(\hat\theta-\theta)=0\)</span> 则称 <span class="math inline">\(\hat\theta\)</span> 是 <span class="math inline">\(\theta\)</span> 的相合估计量</p>
<p>例如：证明 <span class="math inline">\(X_1,...\)</span> 是来自总体<span class="math inline">\(N(\mu,\sigma^2)\)</span> 的容量为 n 的简单随机样本，则<span class="math inline">\(S^2=\frac1{n-1}\sum(X_i-\bar X)^2\)</span> 和 <span class="math inline">\(B_2=\frac1{n}\sum(X_i-\bar X)^2\)</span> 都是 <span class="math inline">\(\sigma\)</span> 的相合估计</p>
<p><strong>Thm</strong>：用矩估计得到的估计量都具有相合性</p>
<h3 id="区间估计">区间估计</h3>
<p><strong>Def</strong>（置信区间）设 <span class="math inline">\(X_1,...\)</span> 是来自总体<span class="math inline">\(X\)</span> 容量为 n 的简单随机样本，<span class="math inline">\(\theta\)</span> 是一个参数，<span class="math inline">\(\hat\theta_1,\hat\theta_2\)</span> 是两个统计量，若给定<span class="math inline">\(\alpha\)</span> 满足：<span class="math inline">\(P(\hat\theta_1&lt;\theta &lt; \hat\theta_2)=1-\alpha\)</span> 则称区间 <span class="math inline">\((\hat\theta_1,\hat\theta_2)\)</span> 是参数 <span class="math inline">\(\theta\)</span> 的置信度为 <span class="math inline">\(1-\alpha\)</span> 的区间估计，<span class="math inline">\(\hat\theta_1,\hat\theta_2\)</span> 为置信区间的下限、上限。</p>
<ul>
<li>对于离散型随机变量，若无法达到 <span class="math inline">\(P=1-\alpha\)</span> 则我们找到尽量接近的值使得<span class="math inline">\(P\ge 1-\alpha\)</span></li>
</ul>
<div class="note"><p>info</p></div>
<h4 id="已知-σ-如何求参数-theta-的置信区间">（已知 σ） 如何求参数 <span class="math inline">\(\theta\)</span> 的置信区间？</h4>
<blockquote>
<p>若 <span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span> <span class="math inline">\(\sigma^2\)</span> 已知，<span class="math inline">\(\mu\)</span> 未知，求 <span class="math inline">\(\mu\)</span> 置信水平为 1-α 的置信区间</p>
</blockquote>
<p>注意到：<span class="math inline">\(\displaystyle\frac{\bar X-\mu}{\sigma/\sqrt n}\sim N(0,1)\)</span></p>
<p>则：<span class="math inline">\(P(\displaystyle|\frac{\bar X-\mu}{\sigma/\sqrt n}|&lt;z_{\alpha/2})=1-\alpha\)</span></p>
<p>即：<span class="math inline">\(P(\bar X-\frac{\sigma}{\sqrt n}z_{\alpha/2}&lt;\mu&lt;\bar X+\frac{\sigma}{\sqrt n}z_{\alpha/2})=1-\alpha\)</span>，其中<span class="math inline">\(z_{\alpha}\)</span> 为上侧 α 分位点</p>
<!-- TODO: endnote-->
<blockquote>
<p>置信区间越短 → 精度高</p>
</blockquote>
<div class="note"><p>primary</p></div>
<ol type="1">
<li>寻求样本和 <span class="math inline">\(\theta\)</span> 的函数 <span class="math inline">\(W(X_1,...,X_n;\theta)\)</span> 其分布不依赖于 <span class="math inline">\(\alpha\)</span> 和其他位置参数。（<em>枢轴量</em>）</li>
<li>构造常数 <span class="math inline">\(a,b\)</span> 使得 <span class="math inline">\(P(a&lt;W&lt;b)=1-\alpha\)</span></li>
<li>从中解出 <span class="math inline">\(\hat\theta_1(X_1,...,X_n),\hat\theta_2(X_1,...,X_n)\)</span> 得到置信区间</li>
</ol>
<!-- TODO: endnote-->
<h4 id="单个正态总体的置信区间">单个正态总体的置信区间</h4>
<h5 id="μ-的置信区间">μ 的置信区间</h5>
<p><em><span class="math inline">\(\sigma^2\)</span> 已知</em>，利用 <span class="math inline">\(W=\frac{\bar X-\mu}{\sigma/\sqrt n}\sim N(0,1)\)</span> 置信区间为：</p>
<p><span class="math display">\[
\left(\bar X-\frac{\sigma}{\sqrt n}z_{\alpha/2},\bar X+\frac{\sigma}{\sqrt n}z_{\alpha/2}\right)
\]</span></p>
<p><em><span class="math inline">\(\sigma^2\)</span> 未知</em>，利用 <span class="math inline">\(W=\frac{\bar X-\mu}{S/\sqrt n}\sim t(n-1)\)</span></p>
<p><span class="math display">\[
\left(\bar{X}-\frac{S}{\sqrt{n}}t_{\alpha/2} (n-1),\bar{X}+\frac{S}{\sqrt{n}}t_{\alpha/2} (n-1)\right)
\]</span></p>
<h5 id="σ2-的置信区间">σ2 的置信区间</h5>
<p><em>μ未知</em>，利用 <span class="math inline">\(\frac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1)\)</span>，置信区间为：</p>
<p><span class="math display">\[
\left(\frac{(n-1)S^2}{\chi^2_{\alpha/2}(n-1)},\frac{(n-1)S^2}{\chi^2_{1-\alpha/2}(n-1)}\right)
\]</span></p>
<p><em>μ已知</em>，在上式 <span class="math inline">\(S^2\)</span> 中用 <span class="math inline">\(\mu\)</span> 代替 <span class="math inline">\(\bar X\)</span></p>
<p><span class="math display">\[
\left(\frac{\sum (X_i-\mu)^2}{\chi^2_{\alpha/2}(n-1)},\frac{\sum (X_i-\mu)^2}{\chi^2_{1-\alpha/2}(n-1)}\right)
\]</span></p>
<h4 id="两个正态总体的均值差和方差比的置信区间">两个正态总体的均值差和方差比的置信区间</h4>
<h5 id="μ1-μ2-的置信区间">μ1-μ2 的置信区间</h5>
<p><em>σ1, σ2 已知</em>，利用：</p>
<p><span class="math display">\[
\frac{\bar X-\bar Y-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{m}+\frac{\sigma_2^2}{n}}}\sim N(0,1)
\]</span></p>
<p>则：</p>
<p><span class="math display">\[
\left(
    \bar X-\bar Y -u_{\alpha/2}\sqrt{\frac{\sigma_1^2}{m}+\frac{\sigma_2^2}{n}},\bar X-\bar Y + u_{\alpha/2}\sqrt{\frac{\sigma_1^2}{m}+\frac{\sigma_2^2}{n}}
\right)
\]</span></p>
<p><em><span class="math inline">\(\sigma_1^2=\sigma_2^2=\sigma^2\)</span> 未知</em>，利用：</p>
<p><span class="math display">\[
\frac{\bar X-\bar Y-(\mu_1-\mu_2)}{S_w\sqrt{\frac{1}{m}+\frac{1}{n}}}\sim t(m+n-2)
\]</span></p>
<p>因而，置信区间为：</p>
<p><span class="math display">\[
\left(\bar X-\bar Y-t_{\frac{\alpha}{2}}(m+n-2)S_w\sqrt{\frac{1}{m}+\frac{1}{n}},\bar X-\bar Y+t_{\frac{\alpha}{2}}(m+n-2)S_w\sqrt{\frac{1}{m}+\frac{1}{n}}\right)
\]</span></p>
<h5 id="两个正态总体方差比-σ12σ22-的置信区间">两个正态总体方差比 σ12/σ22 的置信区间</h5>
<p><em>μ1, μ2 未知</em>，利用：</p>
<p><span class="math display">\[
\frac{S_{1m}^2}{S^2_{2n}}\frac{\sigma_2^2}{\sigma_1^2}\sim F(m-1,n-1)
\]</span></p>
<p>置信区间为：</p>
<p><span class="math display">\[
\left(\frac{1}{F_{\alpha/2}(m,n)}\frac{n}{m}\frac{\sum(X_i-\mu_1)^2}{\sum(Y_i-\mu_2)^2},\frac{1}{F_{1-\alpha/2}(m,n)}\frac{n}{m}\frac{\sum(X_i-\mu_1)^2}{\sum(Y_i-\mu_2)^2}\right)
\]</span></p>
<p>同样的，用<span class="math inline">\(S^2\)</span> 代替其中的 <span class="math inline">\(\sum (X_i-\mu_1)^2\)</span>：</p>
<p><em>μ1, μ2 已知</em>，利用：</p>
<p><span class="math display">\[
\frac{S_{1m}^2}{S_{2n}^2}\frac{\sigma_2^2}{\sigma_1^2}\sim F(m-1,n-1)
\]</span></p>
<p>有：</p>
<p><span class="math display">\[
\left(\frac{1}{F_{\alpha/2}(m-1,n-1)}\frac{n}{m}\frac{S_{1m}^2}{S_{2n}^2},\frac{1}{F_{1-\alpha/2}(m-1,n-1)}\frac{n}{m}\frac{S_{1m}^2}{S_{2n}^2}\right)
\]</span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「随机数学与数理统计」8 - 假设检验</title>
    <url>/2020/12/23/study/Math/Probabilities/notes8/</url>
    <content><![CDATA[<p>假设检验</p>
<span id="more"></span>
<h2 id="假设检验">假设检验</h2>
<h3 id="假设检验的基本概念">假设检验的基本概念</h3>
<p><em>假设检验的基本步骤</em>：</p>
<ol type="1">
<li>建立假设：
<ul>
<li>在假设检验中，通常把一个被检验的假设称为原假设 <span class="math inline">\(H_0\)</span>，将不应轻易加以否定的假设作为原假设。当 <span class="math inline">\(H_0\)</span> 被拒绝时而接受的假设称为备择假设 <span class="math inline">\(H_1\)</span>，它们常常成对出现。</li>
<li>例如：<span class="math inline">\(H_0:\theta \ge 10,H_1:\theta &lt; 10\)</span></li>
</ul></li>
<li>选择检验统计量，给出拒绝域形式
<ul>
<li>由样本对原假设进行判断总是通过一个统计量完成的，该统计量被称为检验统计量。使得原假设被拒绝的样本观测值所在的区域称为拒绝域 <span class="math inline">\(W\)</span>。例如：<span class="math inline">\(W=\{(x_1,x_2,...,x_n):\bar x \le c\}\)</span></li>
</ul></li>
<li>选择显著性水平 <span class="math inline">\(\alpha\)</span>
<ul>
<li>预先给定数 <span class="math inline">\(\alpha\)</span>（显著性水平），根据：<span class="math inline">\(P(reject~H_0|H_0~right)\le\alpha\)</span></li>
</ul></li>
<li>给出拒绝域，确定显著性水平后，可以给出检验的拒绝域 <span class="math inline">\(W\)</span></li>
<li>做出判断
<ul>
<li>给出了观察值 <span class="math inline">\(x_1,...,x_n\)</span> 若 <span class="math inline">\((x_1,...,x_n)\in W\)</span> 则拒绝 <span class="math inline">\(H_0\)</span>；反之接受 <span class="math inline">\(H_0\)</span></li>
</ul></li>
</ol>
<p><em>两类错误</em>：</p>
<ol type="1">
<li>第一类错误（<span class="math inline">\(H_0\)</span> 成立，而样本满足拒绝域）的概率 <span class="math inline">\(\alpha\)</span></li>
<li>第二类错误（<span class="math inline">\(H_0\)</span> 不成立，而样本不满足拒绝域）的概率 <span class="math inline">\(\beta\)</span></li>
</ol>
<h3 id="单个正态总体参数的假设检验">单个正态总体参数的假设检验</h3>
<h4 id="均值-μ-的检验-σ-已知">均值 μ 的检验 （σ 已知）</h4>
<p>检验统计量：<span class="math inline">\(\displaystyle U=\frac{\bar x-\mu_0}{\sigma/\sqrt n}\)</span></p>
<p><em>双边检验</em>：<span class="math inline">\(H_0:\mu=\mu_0\leftrightarrow H_1:\mu\ne\mu_0\)</span></p>
<p><span class="math display">\[
\begin{aligned}
    &amp;U=\frac{\bar{X}-\mu_0}{\sigma/\sqrt n}\sim N(0,1)\\
    &amp;P(reject~H_0|H_0~right)\le \alpha
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\bar X\)</span> 为 <span class="math inline">\(\mu\)</span> 的无偏估计则：<span class="math inline">\(\displaystyle P(reject~H_0|H_0~right)=P(\frac{|\bar{X}-\mu_0|}{\sigma/\sqrt n}\ge \frac{k}{\sigma/\sqrt n})\)</span></p>
<p>拒绝域为：</p>
<p><span class="math display">\[
W=\left\{ (x_1,...,x_n)||\bar x-\mu_0|\ge \frac{\sigma}{\sqrt n}u_{\alpha/2} \right\}
\]</span></p>
<p><em>单边右检验</em>：<span class="math inline">\(H_0:\mu\le \mu_0\)</span></p>
<p><span class="math display">\[
P(\frac{\bar X-\mu_0}{\sigma /\sqrt n}\ge \frac{k}{\sigma /\sqrt n})\le \alpha
\]</span></p>
<p>拒绝域为：</p>
<p><span class="math display">\[
S=\left\{ (x_1,...,x_n)|\bar x-\mu_0 \ge \frac{\sigma}{\sqrt n}u_\alpha \right\}
\]</span></p>
<p><em>单边左检验</em>：<span class="math inline">\(H_0:\mu\ge \mu_0\)</span> 拒绝域为 <span class="math inline">\(\displaystyle S=\left\{ (x_1,...,x_n)|\bar x-\mu_0 \le -\frac{\sigma}{\sqrt n}u_\alpha\right\}\)</span></p>
<h4 id="均值-μ-的检验-σ-未知">均值 μ 的检验 （σ 未知）</h4>
<p>使用 t 检验法，将上述的 <span class="math inline">\(\sigma\)</span> 替换为 <span class="math inline">\(S_n=\sqrt{\frac{1}{n-1}\sum(x_i-\bar x)^2}\)</span>，正态分布替换为自由度为 n-1 的 t - 分布，检验统计量为：<span class="math inline">\(\displaystyle T=\frac{\bar x-\mu_0}{s_n/\sqrt n}\)</span></p>
<p>双侧检验，拒绝域为：</p>
<p><span class="math display">\[
W=\left\{ (x_1,...,x_n)||\bar x-\mu_0|\ge \frac{s_n}{\sqrt n}t_{\alpha/2}(n-1) \right\}
\]</span></p>
<p>单侧右检验，拒绝域为：</p>
<p><span class="math display">\[
S=\left\{ (x_1,...,x_n)|\bar x-\mu_0 \ge \frac{s_n}{\sqrt n}t_\alpha(n-1) \right\}
\]</span></p>
<p>单侧左检验，拒绝域为：</p>
<p><span class="math display">\[
S=\left\{ (x_1,...,x_n)|\bar x-\mu_0 \le -\frac{s_n}{\sqrt n}t_\alpha(n-1) \right\}
\]</span></p>
<h4 id="方差-σ2-的检验">方差 σ2 的检验</h4>
<h5 id="μ未知">μ未知</h5>
<p>利用：</p>
<p><span class="math display">\[
\frac{(n-1)S_n^2}{\sigma_0^2}\sim \chi^2(n-1)
\]</span></p>
<h5 id="μ已知">μ已知</h5>
<p><span class="math display">\[
\frac{\sum(X_i-\mu)^2}{\sigma_0^2}\sim\chi^2(n)
\]</span></p>
<h4 id="summary">Summary</h4>
<table>
<thead>
<tr class="header">
<th>情况</th>
<th>分布</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>σ已知</td>
<td>U~N(0,1)</td>
</tr>
<tr class="even">
<td>σ未知</td>
<td>T~t(n-1)</td>
</tr>
<tr class="odd">
<td>μ已知</td>
<td>χ2~χ2(n)</td>
</tr>
<tr class="even">
<td>μ未知</td>
<td>χ2~χ2(n-1)</td>
</tr>
</tbody>
</table>
<h3 id="两个正态总体参数的假设检验">两个正态总体参数的假设检验</h3>
<h4 id="均值μ1μ2的检验σ12-σ22已知">均值μ1，μ2的检验（σ12 σ22已知）</h4>
<blockquote>
<p>检验 <span class="math inline">\(μ_1~\underline{~~}~μ_2\)</span></p>
</blockquote>
<p><span class="math display">\[
U=\frac{\bar X-\bar Y}{\sqrt{\sigma_1^2/m+\sigma_2^2/n}}\sim N(0,1)
\]</span></p>
<h4 id="均值μ1μ2的检验σ12-σ22未知">均值μ1，μ2的检验（σ12 σ22未知）</h4>
<p><span class="math display">\[
T=\frac{\bar X-\bar Y}{S_w\sqrt{1/m+1/n}}\sim t(m+n-2),\\
S_w=\sqrt{\frac{(m-1)S_{1m}^2+(n-1)S_{2n}^2}{m+n-2}}
\]</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(H_0\)</span></th>
<th>拒绝域</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\sigma_1, \sigma_2\)</span> 已知</td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\mu_1 =\mu_2\)</span></td>
<td><span class="math inline">\(abs(u)\ge u_{\alpha/2}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\mu_1 =\mu_2\)</span></td>
<td><span class="math inline">\(u\ge u_{\alpha}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\mu_1 \ge\mu_2\)</span></td>
<td><span class="math inline">\(u\le u_{1-\alpha}=u_{-\alpha}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\sigma_1, \sigma_2\)</span> 未知</td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\mu_1=\mu_2\)</span></td>
<td><span class="math inline">\(abs(t) \ge t_{\alpha/2}(m+n-2)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\mu_1\le \mu_2\)</span></td>
<td><span class="math inline">\(t\ge t_\alpha(m+n-2)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\mu_1\ge \mu_2\)</span></td>
<td><span class="math inline">\(t\le -t_\alpha(m+n-2)\)</span></td>
</tr>
</tbody>
</table>
<h4 id="方差-σ12σ22-的检验μ1μ2未知">方差 σ12，σ22 的检验（μ1，μ2未知）</h4>
<blockquote>
<p>检验 <span class="math inline">\(\sigma_1^2 ~ \mathrm{\underline{~~~}} ~\sigma_2^2\)</span></p>
</blockquote>
<p><span class="math display">\[
F=\frac{S_{1m}^2}{S_{2n}^2}\sim F(m-1, n-1)
\]</span></p>
<h4 id="方差-σ12σ22-的检验μ1μ2已知">方差 σ12，σ22 的检验（μ1，μ2已知）</h4>
<p><span class="math display">\[
F=\frac{\sum_{i=1}^m (x_i-\mu_1)^2/m}{\sum_{i=1}^n (y_i-\mu_1)^2/n}\sim F(m, n)
\]</span></p>
<p><strong>Summary:</strong></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(H_0\)</span></th>
<th>拒绝域</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\mu_1,\mu_2\)</span> 已知</td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\sigma_1^2=\sigma_2^2\)</span></td>
<td><span class="math inline">\(f\le F_{1-\alpha/2}(m,n)\)</span> 或 <span class="math inline">\(f\ge F_{\alpha/2}(m,n)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\sigma_1^2\le \sigma_2^2\)</span></td>
<td><span class="math inline">\(f\ge F_\alpha(m,n)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\sigma_1^2\ge \sigma_2^2\)</span></td>
<td><span class="math inline">\(f\le F_{1-\alpha}(m,n)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\mu_1,\mu_2\)</span> 未知</td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\sigma_1^2=\sigma_2^2\)</span></td>
<td><span class="math inline">\(f\le F_{1-\alpha/2}(m,n)\)</span> 或 <span class="math inline">\(f\ge F_{\alpha/2}(m,n)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\sigma_1^2\le \sigma_2^2\)</span></td>
<td><span class="math inline">\(f\ge F_\alpha(m,n)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\sigma_1^2\ge \sigma_2^2\)</span></td>
<td><span class="math inline">\(f\le F_{1-\alpha}(m,n)\)</span></td>
</tr>
</tbody>
</table>
<h3 id="总体分布的-χ2-拟合优度检验">总体分布的 χ2-拟合优度检验</h3>
<h4 id="理论分布完全已知">理论分布完全已知</h4>
<h5 id="理论分布-f0-是取有限个值的离散分布">理论分布 F0 是取有限个值的离散分布</h5>
<p><strong>Thm</strong>（K · 皮尔逊）若假设 <span class="math inline">\(H_0\)</span> 成立，则当样本容量 <span class="math inline">\(n\rightarrow \infty\)</span> 时，则 $^2=_{i=1}^2 $ 渐进分布为 <span class="math inline">\(\chi^2(r-1)\)</span>。</p>
<p>若理论分布律为：<span class="math inline">\(P(X=a_i)=p_i\)</span>，原假设可以写为：<span class="math inline">\(H_0:P(X=a_i)=p_i\)</span>，<span class="math inline">\(r\)</span> 为x取值的个数</p>
<p>使用：</p>
<p><span class="math display">\[
\chi^2=\sum_{i=1}^2\frac{(\gamma_i-np_i)^2}{np_i}
\]</span></p>
<p>拟合优度：<span class="math inline">\(p(\chi^2_0)=P(\chi^2\ge \chi^2_0)\)</span></p>
<p>利用：<span class="math inline">\(\chi^2=\sum\frac{(\gamma_i-np_i)^2}{np_i}\)</span> 在 <span class="math inline">\(n\rightarrow \infin\)</span> 时，其渐进分布为 <span class="math inline">\(\chi^2(r-1)\)</span></p>
<p>当 <span class="math inline">\(\chi^2\ge\chi^2_\alpha(r-1)\)</span> 则拒绝假设。</p>
<h5 id="理想分布为一般情况">理想分布为一般情况</h5>
<p>假设可以写为：<span class="math inline">\(H_0:F(x)=F_0(x)\)</span></p>
<ol type="1">
<li>选择常数，将区间分割成：<span class="math inline">\((-\infty, a_1],...,(a_{i-1},a_i],...,...(a_r-1,\infty]\)</span></li>
<li>计算 <span class="math inline">\(p_i=F_0(a_i)-F_0(a_{i-1})\)</span></li>
<li>计算统计量 <span class="math inline">\(\chi^2=\sum\frac{(\gamma_i-np_i)^2}{np_i}\)</span></li>
<li>计算出观察值 <span class="math inline">\(\chi^2\)</span>
<ul>
<li>若 <span class="math inline">\(\chi^2\ge\chi^2_\alpha(r-1)\)</span> 则拒绝假设。</li>
</ul></li>
</ol>
<h4 id="理论分布-f0-含有未知参数的情况">理论分布 F0 含有未知参数的情况</h4>
<p>我们的假设为：</p>
<p><span class="math display">\[
H_0:F(x)=F_0(x:\theta_1,...,\theta_k)\leftrightarrow
H_0:F(x)\ne F_0(x:\theta_1,...,\theta_k)
\]</span></p>
<ol type="1">
<li>使用最大似然估计确定参数</li>
<li>统计量 <span class="math inline">\(\chi^2=\sum\frac{(\gamma_i-np_i)^2}{np_i}\sim \chi^2(r-k-1)\)</span> k 为未知参数个数</li>
<li>当 <span class="math inline">\(\chi^2\ge\chi^2_\alpha(r-1)\)</span> 则拒绝假设。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>「概率统计与随机过程」 9 - 随机过程的基本概念</title>
    <url>/2020/12/11/study/Math/Probabilities/notes9/</url>
    <content><![CDATA[<p>:no_mouth:</p>
<span id="more"></span>
<h2 id="随机过程">随机过程</h2>
<h3 id="随机过程的基本概念">随机过程的基本概念</h3>
<p><strong>Def</strong>（随机过程）设 <span class="math inline">\(\Omega=\{\omega\}\)</span> 是随机试验 <span class="math inline">\(E\)</span> 的样本空间，<span class="math inline">\(T\subset (-\inf,+\inf)\)</span> 如果对于一个固定的 <span class="math inline">\(t\in T\)</span>，有定义在 <span class="math inline">\(\Omega\)</span> 上的随机变量，<span class="math inline">\(X(\omega,t),\omega\in \Omega\)</span> ,令 <span class="math inline">\(t\)</span> 在 <span class="math inline">\(T\)</span> 中变动，得到依赖于 <span class="math inline">\(t\)</span> 的一族随机变量 <span class="math inline">\(\{X(\omega, t), t\in T\}\)</span> 称为随机过程。</p>
<h3 id="有限维的分布函数族">有限维的分布函数族</h3>
<p><strong>Def</strong>（随机过程分布函数）<span class="math inline">\(F(t; x)=P(X(t, w)\le x)\)</span> 为 <span class="math inline">\(X(t, w)\)</span> 的分布函数。（一维）</p>
<p><strong>Def</strong>（随机过程分布函数）<span class="math inline">\(F(t _ 1,t _ 2...,t _ n; x _ 1, x _ 2,...,x _ n)=P(X(t_1, w)\le x _ 1,X(t _ 2, w)\le x _ 2,...)\)</span> 为 <span class="math inline">\(X(t, w)\)</span> 的分布函数。</p>
<h3 id="随机过程的数字特征">随机过程的数字特征</h3>
<p>均值函数：</p>
<p><span class="math display">\[
m_X(t)=EX(t)
\]</span></p>
<p>均方值函数：</p>
<p><span class="math display">\[
\varPsi^2(t)=EX^2(t)
\]</span></p>
<p>方差函数：</p>
<p><span class="math display">\[
D_X(t)=E(X(t)-m_X(t))^2
\]</span></p>
<p>相关函数：</p>
<p><span class="math display">\[
R_X(s,t)=EX(s)X(t)
\]</span></p>
<p>协方差函数：</p>
<p><span class="math display">\[
\begin{aligned}
C_X(s,t)&amp;=Cov(X(s),X(t))\\
&amp;=R_X(s,t)-m_X(s)m_X(t)
\end{aligned}
\]</span></p>
<h3 id="泊松过程和维纳过程">泊松过程和维纳过程</h3>
<h4 id="独立增量过程">独立增量过程</h4>
<p><strong>Def</strong>（独立增量过程）设 <span class="math inline">\(\{X(t) ,t\in T\}\)</span> 是一个随机过程，对于任意的 <span class="math inline">\(t_1,...,t_n\)</span> 增量 <span class="math inline">\(X(t_2)-X(t_1) ...\)</span> 是独立的，则称 <span class="math inline">\(X(t)\)</span> 是一个<strong>独立增量过程</strong>。</p>
<p>增量 <span class="math inline">\(X(t+h)-X(t)\)</span> 的分布仅依赖于<span class="math inline">\(h\)</span> 而不依赖于 t，则称 <span class="math inline">\(X(t)\)</span> 是齐次的。</p>
<p>例如：</p>
<p><span class="math inline">\(X_n\)</span> 是独立同分布的随机变量序列，部分和序列 <span class="math inline">\(S_n=\sum X_i\)</span> 是齐次的独立增量过程。</p>
<p><strong>Thm</strong>：独立增量过程在 <span class="math inline">\(P(X(0)=0)=1\)</span> 的条件下，<span class="math inline">\(X(t)\)</span>的任意有限维分布函数族可以由增量 <span class="math inline">\(X(t)-X(s)\)</span> 的分布唯一确定。</p>
<p><strong>Thm</strong>：独立增量过程 <span class="math inline">\(\{X(t),t\in T\}\)</span> 的均值函数 <span class="math inline">\(m_X(t)\)</span> 和方差函数 <span class="math inline">\(X_X(t)\)</span> 存在，在 <span class="math inline">\(P(X(0)=0)=1\)</span> 的条件下，其协方差函数：</p>
<p><span class="math display">\[
C_X(s,t)=D_X(min\{s,t\}).
\]</span></p>
<h4 id="泊松过程">泊松过程</h4>
<p><strong>Def</strong>（泊松过程）设 <span class="math inline">\(\{N(t), t\ge 0\}\)</span> 表示 <span class="math inline">\([0, t]\)</span> 内随机点发生的数目，<span class="math inline">\(N(t)\)</span> 有以下性质，则称其为一个强度为 <span class="math inline">\(\lambda,\lambda\ge 0\)</span> 的泊松过程：</p>
<ol type="1">
<li>齐次性（平稳性）</li>
<li>独立增量性（无后效性）</li>
<li>普通性</li>
<li><span class="math inline">\(P(N(0)=0)=1\)</span></li>
</ol>
<h5 id="泊松过程的有限维分布和数字特征">泊松过程的有限维分布和数字特征</h5>
<ol type="1">
<li><p>有限维分布：<span class="math inline">\(\{N(t) ,t\ge 0\}\)</span> 是一个强度为 <span class="math inline">\(\lambda\)</span> 的泊松过程，则 <span class="math inline">\(N(t)\)</span> 的一维分布是参数为 <span class="math inline">\(\lambda t\)</span> 的泊松分布，即：<span class="math inline">\(N(t)\sim P(\lambda t)\)</span></p></li>
<li><p>数字特征：</p>
<ul>
<li><span class="math inline">\(m_N(t)=\lambda t\)</span></li>
<li><span class="math inline">\(D_N(t)=\lambda t\)</span></li>
<li><span class="math inline">\(C_N(s,t)=\lambda \min \{s,t\}\)</span></li>
</ul></li>
<li><p>设 <span class="math inline">\(\{N(t) ,t\ge 0\}\)</span> 是一个强度为 <span class="math inline">\(\lambda\)</span> 的泊松分布，则 <span class="math inline">\(N(s)-N(t)\)</span> 是一个参数为 <span class="math inline">\(\lambda(s-t)\)</span> 的泊松分布</p></li>
</ol>
<p>同时，我们把强度为 <span class="math inline">\(\lambda\)</span> 的泊松过程 <span class="math inline">\(\{N(t),t\ge 0\}\)</span> 中机点出现的时刻 <span class="math inline">\(W_1,...,W_n,...\)</span> 为强度为 <span class="math inline">\(\lambda\)</span> 的泊松流。</p>
<p>记 <span class="math inline">\(T_i=W_i-W_{i-1}\)</span> 其表示的第 <span class="math inline">\(i-1\)</span> 个随机点与第 <span class="math inline">\(i\)</span> 个随机点在时刻 <span class="math inline">\(t_{i-1}\)</span> 出现的间隔时间。则 <span class="math inline">\(T\sim e(\lambda)\)</span>，反之：</p>
<p><strong>Thm</strong>：如果任意相邻两个随机点出现的间隔时间相互独立同服从于参数为 <span class="math inline">\(\lambda\)</span> 的指数分布，则随机点流构成强度为 <span class="math inline">\(\lambda\)</span> 的泊松过程。</p>
<h4 id="维纳过程">维纳过程</h4>
<p><strong>Def</strong>（维纳过程 / 布朗运动）随机过程满足如下条件：</p>
<ol type="1">
<li><span class="math inline">\(W(0)=0\)</span></li>
<li><span class="math inline">\(W(t)\)</span> 是齐次增量过程</li>
<li><span class="math inline">\(t&gt;s\ge0\)</span> 时，<span class="math inline">\(W(t)-W(s)=h(X_{[s/\delta]+1}+...+X_{[s/\delta]})\)</span>是独立同分布的随机变量。</li>
<li><span class="math inline">\(EW(t)=0,t&gt;0\)</span></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>19-20-3复习记录</title>
    <url>/2020/08/13/talk-chat/19-20-3%E5%A4%8D%E4%B9%A0%E6%97%A5%E7%A8%8B/</url>
    <content><![CDATA[<p>19-20-3复习</p>
<span id="more"></span>
<h3 id="考试时间">考试时间</h3>
<p>数学分析, true, false %}</p>
<p>爆炸【危】 %} 08-17 09:00-11:30(星期一)</p>
<p>近代史, true, false %}</p>
<p>爆炸【危】 %} 08-18 18:30-20:30(星期二)</p>
<div class="note"><p>warning</p></div>
<p>为啥我 7：30写得差不多了，睡了一觉，你们都还在写啊？？？就两道大题啊喂！！！</p>
<p>给孩子留个生路叭！！！</p>
<!-- TODO: endnote-->
<p>基础物理, true, false %}</p>
<p>爆炸【危】 %} 08-21 09:00-11:00(星期五)</p>
<p>离散数学, false, false %}</p>
<p>08-22 09:00-11:00(星期六)</p>
<p>数据结构, false, false %}</p>
<p>08-24 09:t00-11:00(星期一)</p>
<h3 id="基础物理学">基础物理学</h3>
<div class="note"><p>primary</p></div>
<p>刚体运动学的公式：</p>
<ol type="1">
<li>能量</li>
<li>角动量</li>
<li>角动量定理、角动量守恒</li>
<li>动能定理</li>
<li>柯尼希定理</li>
</ol>
<!-- TODO: endnote-->
<div class="note"><p>success</p></div>
<p>波节、波腹？傻傻分不清。</p>
<p>载频：<span class="math inline">\(\frac{\omega_1+\omega_2}{2}\)</span></p>
<!-- TODO: endnote-->
<div class="note"><p>success</p></div>
<p><strong>静电场部分：</strong></p>
<p>**练习题 二 - 11 %}</p>
<p>注意球壳上每一个电荷对于球心的电势方便累加。</p>
<p><strong>「孤立导体的电容」 %}</strong></p>
<p><strong>「击穿场强」 %}</strong></p>
<!-- TODO: endnote-->
<h3 id="离散数学">离散数学</h3>
<p>数理逻辑（1-5）, true, false %}</p>
<p>集合论（6-8）, true, false %}</p>
<p>代数结构（9-11）, true, false %}</p>
<p>图论（14-17）, false, false %}</p>
<ul>
<li>大纲
<ul>
<li>命题逻辑
<ul>
<li>题型1：命题的判断，关键掌握什么样的语句是命题；</li>
<li>题型2：什么是等值、与等价的区别；</li>
<li>题型3；析取范式、合取范式、方法和作用；</li>
<li>题型4：如何应用等值演算完成逻辑应用的推导；</li>
<li>题型5：判断连接词的完备集。</li>
<li>题型6：命题符号化，推理的基本方法、格式；（推理过程非常重要！）</li>
</ul></li>
<li>一阶逻辑
<ul>
<li>题型1：给定解释下，一阶谓词公式真值的判定；</li>
<li>题型2：前束范式；</li>
<li>题型3：一阶命题符号化，推理的基本方法、格式；（推理过程）</li>
</ul></li>
<li>集合代数
<ul>
<li>题型1：什么是子集、什么是元素？集合的元素都是集合。围绕的考点；</li>
<li>题型2：集合的基本运算、集合恒等式；</li>
</ul></li>
<li>二元关系
<ul>
<li>题型1：关系的基本性质、判定、证明方法；</li>
<li>题型2：等价关系的证明；</li>
<li>题型3：哈斯图；</li>
<li>题型4：偏序关系证明；极大极小、最大最小的区别；</li>
<li>题型5：划分、商集的概念。</li>
</ul></li>
<li>函数
<ul>
<li>题型1：证明两个集合的关系（单射、满射），可以和代数系统的同态、同构结合考察；</li>
</ul></li>
<li>代数系统
<ul>
<li>题型1：单位元、零元、逆元的判定方法；</li>
<li>题型2：代数系统的概念、同态同构的证明方法；</li>
</ul></li>
<li>群
<ul>
<li>题型1：群、子群的概念；子群判定方法、陪集、元素的阶，拉格朗日定理。</li>
</ul></li>
<li>格与布尔代数
<ul>
<li>题型1：概念题、判断题，如格、布尔代数的概念及其判断</li>
<li>题型2：证明题，如证明等式、某代数结构是布尔代数或格等。这些都需要抓住基本概念，以及基本性质进行直接证明。</li>
</ul></li>
<li>图的基本概念
<ul>
<li>深刻理解握手定理及推论的内容并能灵活地应用它们。给出度数列，能判断是否可(简单)图化</li>
<li>深刻理解图同构、简单图、完全图、正则图、子图、补图、二部图的概念以及它们的性质及相互之间的关系。</li>
<li>掌握通路与回路的定义、分类及表示法</li>
<li>深刻理解与无向图连通性、连通度有关的诸多概念，判别有向图连通性的类型</li>
<li>深刻理解并会利用极大路径证明相关问题</li>
<li>深刻掌握用邻接矩阵及其幂求有向图中通路与回路数的方法，会求可达矩阵</li>
</ul></li>
<li>欧拉图与哈密顿图
<ul>
<li>深刻理解欧拉图、半欧拉图的定义及判别定理，及其证明过程。</li>
<li>深刻理解哈密顿图、半哈密顿图的定义。</li>
<li>深刻理解哈密顿图的必要条件，充分条件的证明。</li>
<li>会用哈密顿图的必要条件判断给定的图不是哈密顿图，会用充分条件证明给定的图是哈密顿图。</li>
</ul></li>
<li>树
<ul>
<li>无向树及其性质（六个等价命题）</li>
<li>生成树、基本回路系统、基本割集系统</li>
<li>根树及其分类</li>
</ul></li>
<li>平面图
<ul>
<li>深刻理解平面图的概念和性质；</li>
<li>深刻理解极大平面图的概念和性质（连通，3次）；</li>
<li>掌握欧拉公式及其推广形式，理解欧拉公式及其推广形式的推导过程。</li>
<li>掌握平面图的对偶图的定义，熟悉对偶图边，面、顶点与原平面图边，面、顶点之间的关系。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="命题逻辑">命题逻辑</h4>
<p>判断是否是命题、符号化、判断真值, true, false %}</p>
<ul>
<li>疑问句、方程、无法判断真值的句子都不是命题</li>
<li>特殊符号：<span class="math inline">\(\downarrow\quad\uparrow\)</span></li>
</ul>
<p>判断公式类型（永真式、矛盾式、可满足式）, true, false %}</p>
<ul>
<li>注意蕴含式的真值</li>
<li>真值表</li>
</ul>
<p>等值演算法, true, false %}</p>
<ul>
<li>注意用 <span class="math inline">\(\Leftrightarrow\)</span> 连接不同步的式子</li>
</ul>
<p>求主范式, true, false %}</p>
<div class="note"><p>info</p></div>
<p>Method %} <strong>求范式</strong></p>
<ol type="1">
<li>消去 <span class="math inline">\(\rightarrow\)</span> 和 <span class="math inline">\(\leftrightarrow\)</span></li>
<li>消去双重否定</li>
<li>使用分配律</li>
</ol>
<p><em>这里的分配律可以让析取词和合取词放在合适的位置，即使可能会让整个式子“看起来”更复杂</em></p>
<p>Method%} <strong>求主范式</strong></p>
<ol type="1">
<li>先化成范式</li>
<li>在缺少某一项时，用排中律 <span class="math inline">\(A\vee \neg A = 1\)</span> 和结合律<strong>添加</strong>缺少的命题变元</li>
</ol>
<p>Method%} <strong>主范式互化</strong></p>
<ol type="1">
<li>取 <span class="math inline">\(\neg A\)</span>，并化为范式</li>
<li>则 <span class="math inline">\(A=\neg\neg A\)</span> 用德摩根律展开</li>
</ol>
<!-- TODO: endnote-->
<p>判断推理的正确性, true, false %}</p>
<p>消解法, true, false %}</p>
<ul>
<li><span class="math inline">\(C_1 \wedge C_2 \approx Res(C_1, C_2)\)</span></li>
</ul>
<p>构造证明, true, false %} - 附加前提证明法 - 归谬法 - 消解证明法</p>
<h4 id="一阶逻辑">一阶逻辑</h4>
<p>符号化、判断真值、解释、个体域, true, false %}</p>
<p>等值演算, true, false %} - 量词辖域扩张、收缩等值式</p>
<p>前束范式, true, false %}</p>
<div class="note"><p>info</p></div>
<p>Method %} <strong>前束范式</strong></p>
<ol type="1">
<li>替换<span class="math inline">\(\leftrightarrow,\rightarrow\)</span> 为 <span class="math inline">\(\wedge,\vee,\neg\)</span></li>
<li>用量词否定等值式，将 <span class="math inline">\(\neg\)</span> 调至原子公式之前</li>
<li>用换名规则</li>
<li>用扩张收缩律，将量词移到全式的最前面</li>
</ol>
<!-- TODO: endnote-->
<p>推理理论, true, false %}</p>
<h4 id="集合论">集合论</h4>
<p>表示法、集合运算（交并、广义交并、绝对补、相对补、幂集）, true, false %}</p>
<p>集合计数：, true, false %}</p>
<ul>
<li>容斥原理 %}</li>
</ul>
<h4 id="二元关系和函数">二元关系和函数</h4>
<p>关系的定义、运算（逆、右复合）, true, false %}</p>
<p>关系的性质的证明, true, false %} - 自反、反自反 - 对称、反对称 - 传递</p>
<p>闭包, true, false %} - 求闭包，特别是传递闭包 - 闭包的性质</p>
<p>等价关系, true, false %} - 定义 - 划分</p>
<div class="note"><p>light</p></div>
<p>记得 <span class="math inline">\(A/R\)</span> 被称为<strong>商集</strong>，<code>xmind</code> 有误。 <em><span class="citation" data-cites="然">@然</span></em></p>
<!-- TODO: endnote-->
<p>偏序关系, true, false %} - 生僻 %} 覆盖 - Hessen 图 - 极小、极大、最小、最大、确界</p>
<p>函数, true, false %} - 性质判定、证明（单射、满射、双射）、复合 - 集合基数 - 单射 <span class="math inline">\(f:A \rightarrow B\)</span> 则 B 优势于 A - 集合等势证明 - 连续统假设</p>
<h4 id="二元运算代数系统">二元运算、代数系统</h4>
<p>判断是否封闭（子代数）, true, false %}</p>
<p>代数系统的同态和同构, true, false %} - 定义是什么！</p>
<div class="note"><p>primary</p></div>
<p>同态：</p>
<p>指一个映射，使得 <span class="math inline">\(f(x * y) = f(x)\circ f(y)\)</span></p>
<!-- TODO: endnote-->
<h4 id="群">群</h4>
<p>判断是否是半群、独异点、群, true, false %}</p>
<p>群的性质：, true, false %} - 交换群 - 满足消去律 - 元素的阶</p>
<p>子群, true, false %} - 判定定理 - 生成子群、中心</p>
<p>陪集分解, true, false %} - 如何理解、性质 - 代表元素 - 定义在陪集上的等价关系 - 指数、拉格朗日定理</p>
<h4 id="格">格</h4>
<p>定义、性质, false, false %} - 最小上界、最大下界 - 对偶原理 - 交换律、结合律、吸收律 - 和偏序的关系</p>
<p>分配格, false, false %}</p>
<p>有补格, false, false %} - 补元 - 全下界、全上界</p>
<p>布尔代数, false, false %} - 交换、分配律、同一律、补元律</p>
<h4 id="图">图</h4>
<p>一大堆的定义！, false, false %} - （点、边）相邻、孤立点 - 空图、零图 - 悬挂顶点、悬挂边 - 简单图、多重图</p>
<ul>
<li><p>无向图：</p>
<ul>
<li><span class="math inline">\(\Delta(G),\ \delta(G)\)</span></li>
<li><span class="math inline">\(N_G(v),\overline N_G(v),I_G(v)\)</span></li>
</ul></li>
<li><p>有向图：</p>
<ul>
<li><span class="math inline">\(\Gamma^+_D(v),\Gamma^-_D(v),N_D(v),\overline N_D\)</span></li>
<li><span class="math inline">\(\Delta(G),\delta(G),\Delta^+(G),\Delta^-(G),\delta^+(G),\Delta^-(G)\)</span></li>
<li>基图</li>
</ul></li>
<li><p>握手定理</p></li>
<li><p>度数列</p>
<ul>
<li>可图化的</li>
</ul></li>
<li><p>同构</p></li>
<li><p>导出的子图</p></li>
<li><p>连通性</p>
<ul>
<li>连通分支数<span class="math inline">\(p(G)\)</span></li>
<li>短程线、距离</li>
<li>割点、点割集、割边（桥）、边割集</li>
<li>点、边连通度？</li>
<li>可达、相互可达</li>
</ul></li>
<li><p>构造证明：扩大路径法</p></li>
</ul>
<div class="note"><p>primary</p></div>
<p><strong>扩大路径法</strong></p>
<p>若此路径的始点或终点与通路外的顶点相邻，就将它们扩到通路中来，继续这一过程，直到最后得到的通路的两个端点不与通路外的顶点相邻为止。</p>
<!-- TODO: endnote-->
<ul>
<li>矩阵表示：关联矩阵<span class="math inline">\(M(D)\)</span>、邻接矩阵<span class="math inline">\(A(D)\)</span>、可达矩阵</li>
</ul>
<h4 id="欧拉图哈密顿图">欧拉图、哈密顿图</h4>
<p>欧拉图, false, false %} - 定义（半欧拉图） - 无向图是欧拉图的判定 - 有向图是欧拉图的判定 - 构造欧拉通路</p>
<div class="note"><p>primary</p></div>
<p>Method %} <strong>Fluery算法</strong></p>
<!-- TODO: endnote-->
<p>哈密顿图, false, false %} - 必要条件：<span class="math inline">\(p(G-V1) \le |V1|\)</span> - 充分条件： - <span class="math inline">\(无向简单图\wedge(\forall 不相邻的u,v,d(u)+d(v)\ge n-1)\)</span>（这是存在回路还是通路？） - <span class="math inline">\(无向简单图\rightarrow(u,v不相邻\wedge d(u)+d(v)\ge n\wedge G\cup(u,v) 是哈密顿图\leftrightarrow G是哈密顿图)\)</span> - n阶 <code>(n &gt;= 2)</code> 竞赛图</p>
<p>最短路问题, false, false %}</p>
<div class="note"><p>primary</p></div>
<p>Method %} <strong>Dijkstra标号法</strong></p>
<p><em>在此不详细叙述</em></p>
<p>注意！ %} 使用条件：无负边（实际上是无负圈）</p>
<!-- TODO: endnote-->
<p>中国邮递员问题, false, false %} - 欧拉回路最短 - 不存在则找奇度顶点、分对、重复走。</p>
<p>TSP, true, false %}</p>
<h4 id="树">树</h4>
<p>定义、性质, false, false %} - 六个等价命题 - 破圈法 %}（无向图中）生成树存在 等价于 连通</p>
<ul>
<li>生成树
<ul>
<li>基本回路、基本回路系统</li>
<li>基本割集、基本割集系统</li>
<li>MST</li>
</ul></li>
</ul>
<div class="note"><p>primary</p></div>
<p>Method %} <strong>Kruskal算法</strong>（避圈法）</p>
<!-- TODO: endnote-->
<p>根树, false, false %} - 定义？？？都是啥？？ - 树根、内点、分支点、层数、高度 - r 叉树、r 叉正则树 - r 叉完全正则树 - 最优 2 叉树</p>
<div class="note"><p>primary</p></div>
<p>Method %} <strong>Huffman 算法</strong></p>
<!-- TODO: endnote-->
<p>遍历方法, true, false %} - 前中后 - 波兰符号法、逆波兰符号法</p>
<h4 id="平面图">平面图</h4>
<p>定义, false, false %} 又一大堆 %}</p>
<ul>
<li>平面图、平面嵌入、非平面图
<ul>
<li>加了平行边和环之后还是平面图</li>
</ul></li>
<li>面、无限面（外部面）、有限面（内部面）、边界、<strong>次数</strong> <span class="math inline">\(deg(R)\)</span>
<ul>
<li>所有面的次数之和为边数两倍</li>
</ul></li>
<li>极大平面图、极小非平面图
<ul>
<li>极大平面图的性质（没有割点和桥）</li>
<li>等价于每个面的次数为3</li>
</ul></li>
</ul>
<p>欧拉公式, false, false %} - 是啥？(n-m+r=2) %} - 推广到有 k 个连通分支时如何？ - 几个不等式 - 每个面次数至少为 l 时：<span class="math inline">\(m\le\frac{l}{l-2}(n-2)\)</span> - K5, K3,3时非平面图</p>
<p>平面图的判断, false, false %} - 插入、小区二度顶点 - 同胚 - Kuratowski 定理 1 2</p>
<p>对偶图, false, false %} - 和原来的图的关系？</p>
<div class="note"><p>warning</p></div>
<h4 id="几个算法">几个算法</h4>
<ol type="1">
<li>求传递闭包 Warshall</li>
<li></li>
</ol>
<h4 id="几个性质">几个性质</h4>
<ol type="1">
<li>等价关系：自反、对称、传递</li>
<li>偏序关系：自反、反对称、传递</li>
<li>函数：单射、满射、双射</li>
<li>二元运算：交换律、结合律、幂等律、分配律</li>
<li>代数系统：同态、同构、同类型</li>
<li>群：（半群--&gt;独异点--&gt;群--&gt;交换群）、消去律、中心、<strong>「正规子群」</strong></li>
<li>格：<span class="math inline">\(\wedge,\vee\)</span> 有交换律、结合律、幂等律、吸收律。
<ol type="1">
<li>满足交换、结合、吸收律的两个二元运算构成格</li>
<li>分配格、有补格（0，1）</li>
<li>补元、有补格</li>
</ol></li>
<li>图（碎碎念）
<ol type="1">
<li>度、悬挂</li>
<li>零图、空图</li>
<li>邻域、关联集</li>
<li>多重图、简单图</li>
<li>简单通路、圈</li>
</ol></li>
<li>欧拉图、半欧拉图
<ol type="1">
<li>判定定理（有向图、无向图、欧拉图、半欧拉图）</li>
<li>Fluery 算法</li>
</ol></li>
<li>哈密顿图、半哈密顿图
<ol type="1">
<li>充分条件</li>
</ol></li>
<li>最短路问题
<ol type="1">
<li>Dijkstra 算法</li>
</ol></li>
<li>中国邮递员问题
<ol type="1">
<li>找欧拉回路</li>
</ol></li>
<li>TSP</li>
<li>树</li>
<li>平面图
<ol type="1">
<li>两个容易忘的式子</li>
</ol></li>
</ol>
<!-- TODO: endnote-->
<h3 id="高等数学">高等数学</h3>
<div class="note"><p>primary</p></div>
<p>极值的判断：</p>
<ol type="1">
<li>正定极小</li>
<li>负定极大</li>
<li>半正定、半负定不确定</li>
<li>其他：不是极值点</li>
</ol>
<p>一定要看清楚曲线是否只是一部分。如 <code>y &gt; 0</code></p>
<p>积分区域内有不可导点？</p>
<p>方向导数 = ?</p>
<p>全微分 = ?</p>
<p>连续、可偏导、可微的关系</p>
<p>幂级数和函数在 <code>x = 0</code> 处有时需要单独考虑</p>
<p><span class="math inline">\(\displaystyle\ln (1+x) = x - \frac 1 2 x^2 + \frac 1 3 x^3 + \dots\)</span></p>
<p><span class="math inline">\(\displaystyle\frac{1}{1-x} = 1 + x + x^2 + \dots\)</span></p>
<p>正向、上（下）侧</p>
<p>Gauss / Green / Stokes 公式都怎么用？</p>
<p>梯度、散度、旋度</p>
<p>别忘了连续的场：无源 = 无旋 = 有势</p>
<p>反常积分 + 级数</p>
<p>极限怎么求（泰勒公式等）。</p>
<p>别忘了和函数要求出收敛域。</p>
<p>有的题目，大可不必用 <code>Stokes</code> 公式！</p>
<p>例如：</p>
<p><span class="math display">\[
?=I=\int_C(y^2-z)dx+(2z-x^2)dy +(3x^2-y^2)dz,\\
C为x+y+z=2和\frac{x^2}{4}+y^2=1的交线
\]</span></p>
<p>令 <span class="math display">\[
\begin{aligned}
  &amp;x = 2\cos \theta\\
  &amp;y=2\sin\theta\\
  &amp;z=2-x-y
\end{aligned}
\]</span></p>
<p>几个积分中值定理！</p>
<p>柯西不等式的积分形式</p>
<p>重积分证明一些积分相关的不等式</p>
<p>曲率？？？挠率？？？</p>
<span class="btn /2020/05/22/study/Advanced-Mathematics/Vectors-and-Analytic-Geometry/"><a class="button" href="向量空间" title="向量空间">向量空间</a></span>
<p><span class="math inline">\(arsh~x=ln(x+\sqrt{x^2+1})\)</span></p>
<p><strong>难题</strong></p>
<p><span class="math display">\[
\begin{aligned}
  侧面：&amp;I_1 =\iint \frac{y\ dx\wedge dz}{x^2+y^2+z^2}\\
  底面：&amp;I_2 = 0\\
  I &amp;= I_1 + I_2 \\
    &amp;= \int_{-R}^R\int_{-R}^R 2 \frac{\sqrt{R^2-z^2}\ dz\ dx}{x^2 + R^2}\\
    &amp;= \frac{\pi^2R}{2}\\\\
    &amp;\frac{\partial f}{\partial x} = \frac{\partial f}{\partial r}\frac{\partial r}{\partial x},\quad \frac{\partial f}{\partial y} = \frac{\partial f}{\partial r}\frac{\partial r}{\partial y}\\
    \Rightarrow&amp; \sqrt{f_x^2 + f_y ^ 2} = f_r\\
    &amp;|\iint_D f\ dx\ dy\ | = |\iint_D f\cdot r\ dr \ d\theta \ |\\
    =&amp;\frac{1}{2} |0 - \iint_D r^2 f_r\ dr \ d\theta|\ dr \ d\theta\\
    \le&amp;\frac{1}{2}\iint_Dr^2\max|f_r|\\
    =&amp;2\pi\cdot\frac{1}{6}\max |f_r|
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
  (1)\quad&amp;u_{xx}+u_{yy}+cu = 0, c&lt;0\\
  &amp;若取得正最大，则为极大值，Hessian 负定\\
  &amp;而极大值点处u_{xx} + u_{yy}&gt;0\\
  &amp;u_{xx} &lt; 0,\ u_{xx}u_{yy}-u_{xy}^2 &gt;0\\
  &amp;简单讨论一下不可能，取得负最小值的时类似证明即可\\\\
  (2)\quad&amp;在u上只有可能有非负最小值和非正最大值\\
  &amp;最小值记为 m\ge 0，最大值记为M\le 0 而 M \ge m,则 M = m =0\\
  \Rightarrow&amp; u(x,y) = 0
\end{aligned}
\]</span></p>
<!-- TODO: endnote-->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>日程</category>
      </categories>
  </entry>
  <entry>
    <title>动量守恒和质点动力学</title>
    <url>/2020/06/08/study/Physics/Ch2ConservationOfMomentumAndDynamicsofMassPoint/</url>
    <content><![CDATA[<p>想当初，我也记过这么多东西，吖……</p>
<span id="more"></span>
<blockquote>
<p><strong>Kinematics</strong>：研究如何描述物体的运动</p>
<ul>
<li>基本问题：已知<span class="math inline">\(\pmb{r},\pmb v,\pmb a\)</span>中某一个求另外两个</li>
<li>解决问题的武器：根据定义进行微积分运算</li>
</ul>
<p><strong>Dynamics</strong>：研究外界作用与物体运动的关系</p>
<ul>
<li>基本问题：已知运动求力，或已知力求运动</li>
<li>解决问题的武器：牛顿定律，动量定理及其守恒定律，动能定理及能量守恒定律，角动量定理及其守恒定律</li>
</ul>
</blockquote>
<h2 id="惯性定律和惯性系">惯性定律和惯性系</h2>
<h3 id="惯性定律">惯性定律</h3>
<p><strong>伽利略的推理</strong>：当一个球沿斜面向下滚动时速度增大，沿斜面向上滚动时速度减小，因此当球沿水平面滚动时其速度应该是既不增大也不减小。若没有摩擦力，球将会永远滚下去。</p>
<p><strong>惯性定律（牛顿第一定律）</strong>：</p>
<ul>
<li><p>任何物体，只要没有外力改变它的状态，便会永远保持静止或匀速直线运动的状态。</p></li>
<li><p>或者说：自由粒子永远保持静止或匀速直线运动的状态。</p></li>
<li><p>或者说：孤立质点静止或作匀速直线运动</p>
<blockquote>
<p>在现实世界中，孤立质点可理解为质点虽受外界作用，但外界作用相互抵消。</p>
</blockquote></li>
</ul>
<h3 id="惯性参考系">惯性参考系</h3>
<p>惯性定律在其中严格成立的参考系。</p>
<p>按定义，在各个惯性系之间是不能有加速运动的。换言之，相互有加速运动的参考系，不可能都是惯性系。</p>
<ul>
<li><p><strong>局部的惯性系</strong>：在引力场中作自由运动的参考系。</p></li>
<li><p><strong>基本的惯性系</strong>：固定在地面上的参考系。地面赤道处的向心加速度约为<span class="math inline">\(3.4 \times 10 ^ {2} m/s^2\)</span>.</p></li>
<li><p><strong>近似的惯性系</strong>：地面、地球、太阳系、FK4 系等。</p>
<blockquote>
<p>某参考系是否可看作惯性系，只能根据观察和实验来确定</p>
<p>相对惯性系做匀速直线运动的参考系也是惯性系</p>
</blockquote></li>
</ul>
<h2 id="质量动量和动量守恒定律">质量、动量和动量守恒定律</h2>
<div class="note"><p>primary</p></div>
<p><strong>理想实验：两质点间的相互作用</strong></p>
<p><strong>理想实验</strong>：假设两个质点只受到它们之间相互作用的影响，而与宇宙间的其他物质隔绝。</p>
<p><strong>实验内容</strong>：</p>
<blockquote>
<ol type="1">
<li><p>在时刻<span class="math inline">\(t\)</span>：</p>
<p>质点 1 在<span class="math inline">\(A\)</span>，速度为<span class="math inline">\(v_1\)</span></p>
<p>质点 2 在<span class="math inline">\(B\)</span>，速度为<span class="math inline">\(v_2\)</span></p></li>
<li><p>在稍后的时刻<span class="math inline">\(t&#39;\)</span>：</p>
<p>质点 1 在<span class="math inline">\(A&#39;\)</span>，速度为<span class="math inline">\(v_1&#39;\)</span></p>
<p>质点 2 在<span class="math inline">\(B&#39;\)</span>，速度为<span class="math inline">\(v_2&#39;\)</span></p></li>
<li><p>在时间间隔<span class="math inline">\(\Delta t\)</span>内，两质点的速度变化分别为：</p>
<ul>
<li><span class="math inline">\(\Delta v_1 = v_1&#39;-v_1\)</span></li>
<li><span class="math inline">\(\Delta v_2 = v_2&#39;-v_2\)</span></li>
</ul></li>
</ol>
</blockquote>
<p><strong>实验结果分析</strong>(从实验数据归纳出的四点结论)：</p>
<blockquote>
<ol type="1">
<li>在任意给定的时间间隔<span class="math inline">\(\Delta t\)</span>内，速度变化<span class="math inline">\(\Delta v_1\)</span>和<span class="math inline">\(\Delta v_2\)</span>的方向相反。</li>
<li><span class="math inline">\(\Delta t \to 0\)</span>时，矢量<span class="math inline">\(\mathrm{d} v_1\)</span>和<span class="math inline">\(\mathrm{d} v_2\)</span>排在两质点的瞬时连线上。</li>
<li>不论时间间隔大小如何，两物体速度变化的大小之比为定值<span class="math inline">\(\Delta v_1=-K_{12}\Delta v_2\)</span></li>
<li>比例系数与质点有关（与如何运动无关）：<span class="math inline">\(K_{12}=\frac{m_2}{m_1}\)</span></li>
</ol>
</blockquote>
<!-- TODO: endnote-->
<h3 id="物体的质量mass">物体的质量（Mass）</h3>
<ul>
<li>惯性质量：表征物体速度改变难易程度（即惯性大小）的物理量</li>
</ul>
<p>为了便于比较，并从中找出表征质点惯性大小的物理量，我们进行以下特别设计的实验：</p>
<p><strong>实验</strong>:</p>
<p>选取某一质点<span class="math inline">\(0\)</span>作为<strong>标准质点</strong>，并让质点<span class="math inline">\(1,2,3,\dots\)</span>分别与标准质点<span class="math inline">\(0\)</span>相互作用，使标准质点<span class="math inline">\(0\)</span>产生同样的速度变化 . 为了标明是相应于这种特定情况下的实验结果，我们将这类实验中 各质点的速度变化分别表示为<span class="math inline">\(\Delta v_0,\Delta v_1^0,\Delta v_2^0,\dots\)</span></p>
<p>于是，<span class="math inline">\(\Delta v_1^0,\Delta v_2^0,\dots\)</span>的大小就反映出了 各质点在相互作用过程中<strong>速度改变的难易程度</strong>，即质点<strong>惯性</strong>的大小，<strong>速度改变大的质点惯性小</strong>。</p>
<p><strong>分析</strong>:</p>
<p>将前述理想实验的普遍结果<span class="math inline">\(\Delta v_1=-K_{12}\Delta v_2\)</span>应用于这里所安排的特殊实验，我们可以对于各个质点对<span class="math inline">\(\lbrace 0,1\rbrace,\lbrace 0,2\rbrace,\lbrace 0,3\rbrace,\dots\)</span>所进行的实验，分别写出：</p>
<p><span class="math display">\[
\Delta v_0=-K_{01}\Delta v_1^0
\\
\Delta v_0=-K_{02}\Delta v_2^0
\\
\Delta v_0=-K_{03}\Delta v_3^0
\\
\dots
\]</span></p>
<p>式中的比例常数<span class="math inline">\(K_{0i}\)</span>对所给定的每一对质点<span class="math inline">\(\lbrace 0 , i \rbrace\)</span>是确定的，与它们怎样运动无关。因此，我们可以把这些比例常数写为：</p>
<p><span class="math display">\[
K_{01}=\frac{m_1}{m_0}
\\
K_{02}=\frac{m_2}{m_0}
\\
K_{03}=\frac{m_3}{m_0}
\\
\dots
\]</span></p>
<p>式中的<span class="math inline">\(m_0,m_1,m_2,m_3,\dots\)</span>分别称为质点<span class="math inline">\(0,1,2,3,\dots\)</span>的<strong>质量</strong>。</p>
<p>实际上，上述实验过程相当于把标准质点<span class="math inline">\(0\)</span>的质量<span class="math inline">\(m0\)</span>取为单位质量。在国际单位制中，质量的单位是 kg，即：<span class="math inline">\(m_0=1\space \mathrm{kg}\)</span>.</p>
<p>这样定义的质量，其大小反映了质点在相互作用过程中速度改变的难易程度，即质点惯性的大小，因此称为惯性质量，以区别于由万有引力定律定义的引力质量。</p>
<ul>
<li><p>引力质量（gravitational mass）：用天平测出的，表征引力性质的质量</p></li>
<li><p>相对论质量：物体的质量随速度变化而变化</p></li>
</ul>
<p><span class="math inline">\(m=m_0/\sqrt{1-v^2/c^2}\)</span></p>
<h3 id="动量动量守恒定律">动量、动量守恒定律</h3>
<h4 id="动量和两粒子相互作用过程中的守恒量">动量和（两粒子相互作用过程中的守恒量）</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;K_{12}=\frac{m_2}{m_1},\quad\Delta v_1=-K_{12}\Delta v_2
\\
&amp;\Delta v_1 = v_1&#39;-v_1 ,\quad \Delta v_2 = v_2&#39;-v_2
\\
\Rightarrow\space&amp;m_1v_1&#39;+m_2v_2&#39;=m_1v_1+m_2v_2
\end{aligned}
\]</span></p>
<p>我们发现，在两质点的相互作用过程中，每个质点的质量<span class="math inline">\(m\)</span>与其速度<span class="math inline">\(v\)</span>的乘积之和是守恒量。通常用<span class="math inline">\(\pmb{p}=m\pmb{v}\)</span>来表示这个乘积，称为这个质点的动量。</p>
<h4 id="动量守恒定律孤立系">动量守恒定律（孤立系）</h4>
<p>动量守恒定律（孤立系）可表述为：</p>
<p>一系统由两个质点组成，如果这两个质点只受到它们之间的相互作用，则这系统的总动量保持恒定，即</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\pmb{p}_1&#39;+\pmb{p}_2=\pmb{p}_1+\pmb{p}_2
\\
or \quad &amp;\pmb{p}_1+\pmb{p}_2=Constant
\end{aligned}
\]</span></p>
<h4 id="动量守恒定律的普适性">动量守恒定律的普适性</h4>
<p>从现代物理学的理论高度来认识，动量守恒定律是惯性参考系中空间平移不变性的直接推论(见§4 - 4)，因而是物理学中最基本的普适原理之一。</p>
<p>从科学实践的角度来看，迄今为止，人们尚未发现动量守恒定律有任何例外，它在理论探讨和实际应用中发挥了巨大的作用。</p>
<p>在实验中每当观察到似乎是违反动量守恒定律的现象时，物理学家就提出一些新的假设来补救，最后总是以有所新发现而胜利告终。</p>
<p><span class="math inline">\(\beta\)</span><strong>衰变</strong>：原子核<span class="math inline">\(X\)</span>放出电子<span class="math inline">\({e^-}\)</span>后转化为原子核<span class="math inline">\(Y\)</span>.</p>
<p><strong>预测</strong>：按动量守恒定律，若<span class="math inline">\({X}\)</span>是孤立而静止的，则<span class="math inline">\({X\rightarrow Y~+~e^-}\)</span>产生的<span class="math inline">\({Y}\)</span>必定会在与放射出来的<span class="math inline">\({e^-}\)</span>的相反方向上反冲。</p>
<p><strong>实验结果</strong>：云室照片显示二者径迹不在一条直线上。</p>
<p><strong>分析</strong>：若坚持认为动量守恒定律是正确的，则必须假设这里还存在一个未被发现的粒子。</p>
<p>1930 年，泡利提出了中微子假说(例题 2.1)。</p>
<p>中微子既不带电又几乎无质量，在实验中极难测量。</p>
<p>1956 年，首次通过实验直接证明了中微子的存在。</p>
<h2 id="力-冲量和动量定理">力 冲量和动量定理</h2>
<h3 id="力的定义">力的定义</h3>
<blockquote>
<p>利用动量的概念：<span class="math inline">\(\Delta p_1=-\Delta p_2\)</span></p>
<p>写成微分形式：<span class="math inline">\(\frac{\mathrm{d}p_1}{\mathrm{d}t}=-\frac{\mathrm{d}p_2}{\mathrm{d}t}\)</span></p>
<p><span class="math inline">\(\Rightarrow F=\frac{\mathrm{d}p_1}{\mathrm{d}t}\)</span></p>
</blockquote>
<p><strong>力</strong>：一个<strong>物体的动量对时间的变化率</strong>，定义为该物体所受到的外力。</p>
<ul>
<li><p><span class="math inline">\(\frac{\mathrm{d}p_1}{\mathrm{d}t}=-\frac{\mathrm{d}p_2}{\mathrm{d}t}\)</span>表明，在任意时刻，构成孤立系的两个质点的动量瞬时变化率大小相等，方向相反。从另一个角度来看，当两个质点相互作用时，我们可以说每一个质点对另一个质点都作用一个力。</p></li>
<li><p>与此同时，质点 1 对质点 2 的作用力<span class="math inline">\(F_{21}\)</span>，则为单位时间内质点 1 传递给质点 2 的动量，即<span class="math inline">\(F_{12}=-F_{21}\)</span></p></li>
</ul>
<p><strong>力的累积效应</strong>：</p>
<ul>
<li>对<span class="math inline">\(t\)</span>积累：<span class="math inline">\(I,\Delta p\)</span> 冲量 、动量定理、动量守恒</li>
<li>对<span class="math inline">\(r\)</span>积累：<span class="math inline">\(W,\Delta E\)</span> 功、动能定理、机械能守恒</li>
</ul>
<h3 id="力的叠加原理质点系动量守恒的条件">力的叠加原理、质点系动量守恒的条件</h3>
<p><strong>质点系</strong>：由若干个相互作用着的质点组成。</p>
<p><strong>力的叠加原理</strong>：假定每个质点<span class="math inline">\(i\)</span>的动量<span class="math inline">\(p_i\)</span>的增加是所有其他质点传递给它的动量的矢量和；换言之，每个质点<span class="math inline">\(i\)</span>所受到的力<span class="math inline">\(F_i\)</span>，等于所有其他质点<span class="math inline">\(j\)</span>对它的作用力<span class="math inline">\(F_{ij}\)</span>的矢量和，即<span class="math inline">\(\frac{dp_i}{dt}=F_i=\sum\limits_{j \neq i}{F_{ij}}\)</span>。</p>
<p><strong>系统</strong>：从一个大体系中分离出一部分作为考虑对象。</p>
<p><strong>外界</strong>：大体系的其余部分。</p>
<p><strong>内力</strong>：系统内各质点之间的相互作用力</p>
<p><strong>外力</strong>：外界质点对它们的作用力。</p>
<p>利用牛顿第三定律可以证明，系统的内力之和为零。因此，系统所受到的总力<span class="math inline">\(F\)</span>等于系统所受到的合外力。</p>
<p><span class="math display">\[
F=F^{in}+F^{ex}=\sum{(F^{in}+F^{ex})}=\sum F^{ex}
\]</span></p>
<p>所以，系统的总动量的瞬时变化率，就等于系统所受到的合外力。如果系统所受到的合外力为零，则有<span class="math inline">\(\frac{dp}{dt}=0\quad p=\sum{p_i}=Constant\)</span></p>
<p>这是动量守恒定律的推广。</p>
<blockquote>
<p>只要系统(不限于两个质点)所受到的合外力为零，其总动量就是守恒的。当<span class="math inline">\(F^{ex}&lt;&lt;F^{in}\)</span>可忽略外力的作用。</p>
<p>若系统所受到的合外力的某个分量等于零，则总动量的相应分量是守恒的。</p>
<p>系统的动量守恒是指系统的总动量不变，系统内任一物体的动量是可变的，需注意各物体的动量要相对于同一惯性参考系。</p>
<p>动量守恒定律只在惯性参考系中成立, 是自然界最普遍，最基本的定律之一 。</p>
</blockquote>
<h3 id="牛顿运动定律">牛顿运动定律</h3>
<p>系统只包含一个质点，则有<span class="math inline">\(F = \frac{dp}{dt}=\frac{dmv}{dt}\)</span></p>
<p>换言之，一个质点所受到的力<span class="math inline">\(F\)</span>，可由其本身动量<span class="math inline">\(p=mv\)</span>的<strong>瞬时变化率</strong>来表征。</p>
<p>若质量 m 不随时间改变，则上式又可写为<span class="math inline">\(F=m \cdot a\)</span></p>
<h3 id="冲量和动量定理">冲量和动量定理</h3>
<ul>
<li>冲量</li>
</ul>
<p>利用<span class="math inline">\(F = \frac{dp}{dt}\)</span></p>
<p><span class="math display">\[
\int_{t_1}^{t_2}Fdt=p_2-p_1=m(v_2-v_1)
\]</span></p>
<p><span class="math inline">\(I=\int_{t_1}^{t_2}Fdt\)</span>称为在该时间间隔内作用在质点上的冲量。</p>
<ul>
<li>质点的冲量定理</li>
</ul>
<p>在一段时间内质点动量的增量，等于在此时间间隔内作用在该质点上的冲量。</p>
<div class="note"><p>primary</p></div>
<p><strong>特殊情形：冲击力</strong></p>
<blockquote>
<p>物体之间的相互作用力，使物体在很短时间内动量发生了有限(或可观)的变化。 冲击力与时间的关系曲线下的面积就等于力的冲量<span class="math inline">\(I\)</span>(或动量的增量<span class="math inline">\(p_2-p_1\)</span>)的大小。</p>
</blockquote>
<p><strong>平均冲击力</strong>：<span class="math inline">\(\overline{F}=\frac{\int_{t_1}^{t_2}Fdt}{t_2-t_1}=\frac{p_2-p_1}{t_2-t_1}\)</span></p>
<p><strong>实例</strong>：作用力<span class="math inline">\(F\)</span>大小有限，作用时间非常短促，即<span class="math inline">\(t_2-t_1\to 0\quad I \to 0\quad p_2-p_1 \to 0\)</span>物体的动量(或运动状态)将不会发生有限或可观的变化。</p>
<p><strong>变质量系统问题</strong></p>
<p>例题 2.2 火箭运动的基本原理</p>
<p>密舍尔斯基方程：<span class="math inline">\(m&#39;\frac{\mathrm d\vec{v}}{\mathrm dt}=\vec{F}+\vec u \frac {\mathrm d m&#39;}{\mathrm d t}\)</span></p>
<p><span class="math inline">\(\vec{u}\)</span> （离开的质量部分）相对速度</p>
<!-- TODO: endnote-->
<ul>
<li>质点系的动量定理</li>
</ul>
<p>作用于系统的合外力的冲量等于系统动量的增量<span class="math inline">\(I=\int F^{ex}\mathrm {d} t\)</span></p>
<blockquote>
<p>注意</p>
<ul>
<li>区分外力和内力</li>
<li>内力京能改变系统内单个物体的动量但不能改变系统的总动量</li>
</ul>
</blockquote>
<h2 id="牛顿运动定律及其运用">牛顿运动定律及其运用</h2>
<blockquote>
<p><strong>动力学</strong>以牛顿运动定律为基础，研究物体运动状态发生改变所遵循的规律。</p>
</blockquote>
<h3 id="牛顿运动定律的表述">牛顿运动定律的表述</h3>
<p><strong>牛顿第一定律</strong>：任何物体，只要没有外力改变它的状态，便永远保持静止或匀速直线运动的状态。<strong>惯性</strong>：物体保持其运动状态不变的性质。</p>
<p><strong>牛顿第二定律</strong>：在受到外力作用时，物体所获得的加速度的大小与外力矢量和的大小成正比，并与物体的质量成反比，加速度的方向与外力矢量和的方向相同，即<span class="math inline">\(F=ma\)</span></p>
<p><strong>牛顿第三定律</strong>：两物体相互作用时，作用力和反作用力大小相等，方向相反，在同一条直线上。若用 1 和 2 表示这两个物体，则有<span class="math inline">\(F_{12}=-F_{21}\)</span>.</p>
<blockquote>
<ul>
<li>作用力和反作用力总是成对出现。</li>
<li>作用力和反作用力分别作用于两个物体，因此不能平衡或抵消。</li>
<li>作用力和反作用力属于同一种性质的力。</li>
</ul>
</blockquote>
<p><strong>牛顿运动定律成立的条件</strong>：惯性参考系中的质点。</p>
<h3 id="牛顿运动定律和守恒定律">牛顿运动定律和守恒定律</h3>
<h4 id="力的概念和牛顿运动定律">力的概念和牛顿运动定律</h4>
<p>当我们只讨论一个物体的运动时，可以只分析该物体本身所受到的各种力，直接应用力的概念和牛顿运动定律来解决问题。</p>
<p>牛顿运动定律是以力的概念为核心的，认为力是改变物体运动状态的原因。</p>
<p>在净力(<strong>净力</strong>，是指作用于同一物体上的多个力的合，通常为矢量和。)<span class="math inline">\(F\)</span>的作用下，一个质量为 m 的质点将按牛顿第二定律受到加速。</p>
<p><strong>隔离体法</strong>：设想把系统的各个部分隔离开来，应用牛顿运动定律来分析它的每一部分的运动。</p>
<p><strong>质点系</strong>：设想把所研究的系统看成是一个内部有相互作用的质点系，将牛顿运动定律应用到质点系的每一个质点上，然后再研究整个物体或物体系的运动。</p>
<p>这时，往往并不需要了解每个质点的运动情况，而只要知道某些整体运动的特征。开山填沟的定向爆破问题。</p>
<h4 id="运动定理守恒定律">运动定理、守恒定律</h4>
<p>运动定理：动量定理、角动量定理和动能定理等。</p>
<p>按照历史的发展过程，运动定理和守恒定律起初是从牛顿运动定律导出来的。</p>
<p>然而，物理学的发展表明，即使在牛顿运动定律不再适用的许多场合，守恒定律仍然有效。这样，原来仅仅作为牛顿运动定律辅助工具而引入的运动定理的推论——守恒定律，就成为比牛顿运动定律更为基本的规律了。</p>
<p>除了基本的重要性外，守恒定律的应用对于解决很多实际问题也是十分重要的，这在物理学的近代发展中起了重要的作用。</p>
<h4 id="两类动力学问题">两类动力学问题</h4>
<blockquote>
<p>作用在物体上的力&lt;=&gt;物体的运动情况或平衡状态</p>
</blockquote>
<ul>
<li>已知作用在物体上的力，由力学规律来决定该物体的运动情况或平衡状态</li>
</ul>
<p>这类动力学问题代表一种纯粹演绎的过程，它是对物理学和工程学的问题作出成功的分析和设计的基础。</p>
<ul>
<li>已知物体的运动情况或平衡状态，由力学规律来推论作用在物体上的力</li>
</ul>
<p>这类动力学问题包括了力学的归纳性和探索性的应用，这是发现新定律的一个重要途径。</p>
<p>牛顿从开普勒行星运动规律归纳出万有引力定律，卢瑟福通过<span class="math inline">\(\beta\)</span>粒子散射实验发现原子的有核结构，人们还正在进一步通过高能粒子的散射实验去了解粒子的结构及其相互作用等等。</p>
<p>当然，通过整理实验观测结果去寻求力，往往是比较困难的。</p>
<h4 id="自然界中几种常见力">自然界中几种常见力</h4>
<ul>
<li><p><strong>万有引力</strong></p>
<p><span class="math inline">\(F_{21}=-G\frac{m_1m_2}{r^2}{e}_r,\\ e_r=\frac{\vec r}{r}\)</span></p>
<p><span class="math inline">\(g_0=9.83m/s^2\)</span></p></li>
</ul>
<blockquote>
<p>星体之间，地球与地球表面附近的物体之间，以及所有物体与物体之间都存在着一种相互吸引的力。</p>
</blockquote>
<p><strong>惯性质量和引力质量</strong>：</p>
<ul>
<li><p><strong>弹性力</strong></p>
<p>胡克定律：<span class="math inline">\(F=-kx\)</span></p>
<blockquote>
<p>物体发生弹性形变后，内部产生欲恢复形变的力。弹簧弹性力、绳索内张力、正压力和支持力）</p>
</blockquote></li>
<li><p><strong>摩擦力</strong></p>
<blockquote>
<p>静摩擦力、最大静摩擦力、滑动摩擦力</p>
</blockquote></li>
</ul>
<h2 id="伽利略相对性原理和非惯性系">伽利略相对性原理和非惯性系</h2>
<h3 id="伽利略相对性原理">伽利略相对性原理</h3>
<blockquote>
<p>对于一个封闭船舱内所发生的现象，伽利略曾生动地描绘道："即使船运动得相当快，在跳跃时你也将和以前一样。在船底板上跳过相同的距离，你跳向船尾也不会比跳向船头来得远，虽然你跳在空中时，脚下的船底板向着你跳的相反方向移动。……水滴将像先前一样滴进下面的罐子，一滴也不会滴向船尾。"</p>
<p>在一个相对于惯性系作匀速直线运动的参考系内部，所发生的一切力学过程都不受系统作匀速直线运动的影响。</p>
<p>不可能利用在惯性系内部进行的任何力学实验，来确定该系统作匀速直线运动的速度。</p>
</blockquote>
<p><strong>伽利略相对性原理</strong>（<strong>力学相对性原理</strong>）：力学定律在所有惯性系中都是相同的。</p>
<p><strong>推论</strong>：相对于一惯性系作匀速直线运动的一切参考系都是惯性系。</p>
<p>力学规律对于一切惯性系都是等价的，不存在特殊的绝对的惯性系。</p>
<h3 id="伽利略变换">伽利略变换</h3>
<p>上述等价性并不是说在不同的惯性系中所看到的现象都是相同的。同一物体的运动轨道和运动速度，在不同惯性系中看来显然可以是不同的。我们有必要建立关于一个事件在两个惯性系中的两组时空坐标之间的变换关系。</p>
<p><strong>事件</strong>：某一时刻发生在空间某一点上的一个事例。</p>
<p>在四维时空空间中，一个事件对应于一个<strong>时空点</strong>。</p>
<p>在<em>§1-2</em>中讨论相对运动时，我们导出了质点在两个相互作平移的参考系(惯性系或非惯性系)中的位矢、速度和加速度之间的变换关系式。</p>
<p>现在，我们来讨论两个相对作匀速直线运动的惯性参考系<span class="math inline">\(S\)</span>和<span class="math inline">\(S&#39;\)</span>之间的变换关系。</p>
<blockquote>
<p>由于坐标轴的取向可以任意选择，我们取<span class="math inline">\(x\)</span>和<span class="math inline">\(x&#39;\)</span>轴沿相对速度<span class="math inline">\(v_r\)</span>的方向。若把矢量式<span class="math inline">\(r&#39;=r-R,\quad R=v_rt\)</span>写成分量形式，并将时间关系也明确地表达出来，即得两惯性系<span class="math inline">\(S\)</span>和<span class="math inline">\(S&#39;\)</span>之间的时空坐标变换关系式为：</p>
<p><span class="math display">\[
\begin{aligned}
x&#39;&amp;=x-v_rt,
\\
y&#39;&amp;=y,
\\
z&#39;&amp;=z,
\\
t&#39;&amp;=t
\end{aligned}
\]</span></p>
<p>该变换称为<strong>伽利略变换</strong>，它给出了同一时空点在惯性系 和 中时空坐标之间的变换公式。</p>
</blockquote>
<p><strong>绝对时空观</strong>：伽利略变换式<span class="math inline">\(t&#39;=t\)</span>意味着，在这里我们定义了一个与参考系无关的绝对的时间。实际上，绝对时间的假设还必然会引出长度具有绝对性的结论，即物体的长度也与参考系无关。经典力学正是建立在这样一种绝对时空观基础上的，而伽利略变换就是它的具体体现。</p>
<h3 id="非惯性系">非惯性系</h3>
<p><strong>惯性系</strong>：研究地面上一般物体在不太长时间内所进行的力学过程时，可以把地球看成是近似程度相当好的惯性系。</p>
<p><strong>非惯性系</strong>：（在要求较高精度的问题中，特别是在研究大气环流等大尺度的运动时，我们必须考虑到地球的非惯性系因素的影响。） 相对于惯性系做加速运动的参考系</p>
<p><strong>牛顿运动定律只在惯性系中成立。</strong>原则上，我们可以以惯性系为基础，处理在非惯性系中物体运动的力学问题。</p>
<p><strong>目标</strong>：用普遍的物理考虑(引进惯性力的概念)，使我们能够用统一的(牛顿运动定律)形式来处理非惯性系和惯性系中物体运动的力学问题。</p>
<p><strong>出发点</strong>：具体讨论非惯性系相对于惯性系的运动。</p>
<p>固联在地面上的参考系，其原点 O 随着地球的自转而绕地轴 C 作圆周运动，其坐标架的运动可以分解为随原点的平移和围绕原点的转动两部分。</p>
<p>一般而言，一个参考系的运动，可以看成是由两部分组成的：</p>
<ol type="1">
<li>跟随原点的平移，即固联在参考系上的任一直线在各时刻的方向始终保持平行的运动；</li>
<li>坐标轴围绕原点的转动。</li>
</ol>
<p><strong>几点结论</strong>：</p>
<ol type="1">
<li>加速<strong>平移</strong>的后果是产生惯性力.</li>
<li><strong>转动</strong>的后果是产生惯性离心力和科里奥利力。</li>
</ol>
<p>惯性力与质点的速度无关，而科里奥利力却依赖于质点的速度。</p>
<h3 id="加速平移参考系中的惯性力">加速平移参考系中的惯性力</h3>
<p>假设非惯性系<span class="math inline">\(S&#39;&#39;\)</span>相对于惯性系<span class="math inline">\(S\)</span>以加速度<span class="math inline">\(a_r\)</span>平移，则质点在<span class="math inline">\(S&#39;&#39;\)</span>系和<span class="math inline">\(S\)</span>系中的加速度<span class="math inline">\(a&#39;&#39;\)</span>和 a 满足式<span class="math inline">\(\pmb a&#39;&#39;=\pmb a-\pmb a_r\)</span></p>
<p>在惯性系<span class="math inline">\(S\)</span>中，牛顿运动定律成立，我们有<span class="math inline">\(\pmb F=m\pmb a\)</span></p>
<p>在非惯性系<span class="math inline">\(S&#39;&#39;\)</span>中，牛顿第二定律的上述表达式可以写为<span class="math inline">\(\pmb F = m(\pmb a&#39;&#39;+\pmb a_r)\)</span></p>
<p>如果我们设想有一个附加的力——<strong>惯性力</strong>: <span class="math inline">\(\pmb F_{\bold i}=-m\pmb a_r\)</span></p>
<p><strong>惯性力</strong>是在而非惯性系中物体受到的一种"<strong>力</strong>"，</p>
<ol type="1">
<li><strong>惯性力</strong>由于非惯性系相对于惯性系加速运动引起的，与非惯性系加速度方向相反。</li>
<li><strong>惯性力</strong>是虚拟力，没有施力物体、反作用力</li>
<li><strong>惯性力</strong>可以测量和感受，可以看成是实在的力</li>
<li>从惯性系看，惯性力是惯性的一种表现形式</li>
<li>注意：动量守恒只在惯性系中成立！</li>
</ol>
<h3 id="惯性离心力">惯性离心力</h3>
<p><strong>圆盘实验</strong>： 水平圆盘以角速度<span class="math inline">\(\omega\)</span>绕通过圆心的竖直轴转动</p>
<p><strong>惯性离心力</strong>：<span class="math inline">\(\pmb{F}_\mathrm i=m\omega^2\pmb r\)</span></p>
<h3 id="科里奥利力">科里奥利力</h3>
<blockquote>
<p>类比为何卫星上升可以减速</p>
</blockquote>
<p>如果在绕竖直轴 O 的一个匀角速度 w 运行的圆盘中心有一个光滑小孔，m 以匀速 v'向外运动。则</p>
<p><span class="math display">\[
\begin{aligned}
   a&amp;=\frac{dv}{dt}=\frac{\mathrm{d}(\dot r \vec e_r+r\dot \theta \vec e_ \theta )}{\mathrm d t}\\
   &amp;=\ddot r \vec e_r+\dot r\dot\theta\vec e_\theta+\dot r\dot \theta\vec e_\theta+r\ddot\theta\vec e_\theta+r\dot \theta(-\dot \theta\vec e_r)\\
   &amp;=-r\dot\theta^2\vec e_r+2v\dot \theta \vec e_\theta
\end{aligned}
\]</span></p>
<p>在这里：<span class="math inline">\(-r\dot\theta^2\vec e_r\)</span>是惯性离心力的表示，而后者就是科里奥利力<span class="math inline">\(\pmb F_\mathrm c=-2mv&#39;w\pmb e_\theta = 2m\pmb v&#39; \times\pmb \omega\)</span></p>
<h2 id="习题">习题</h2>
<blockquote>
<p>这部分好难，唉</p>
</blockquote>
<div class="note"><p>primary</p></div>
<h3 id="知道运动状态求力">知道运动状态求力</h3>
<p>最简单的题目，例如</p>
<blockquote>
<p><em>例题 2-2</em></p>
<p>一辆货车以 <span class="math inline">\(3m/s\)</span> 恒定速度前进，煤以 <span class="math inline">\(5t/s\)</span> 的速率竖直注入车厢，求牵引力</p>
<p>实际上很简单，用微元法并运用动量守恒列方程即可，一道十分简单的变质量运动问题。</p>
</blockquote>
<p>也有</p>
<blockquote>
<p><em>例题 2-17</em></p>
<p>超速离心机的转速为 <span class="math inline">\(1000转/s\)</span> ，求转轴 <span class="math inline">\(10\mathrm{cm}\)</span> 处的分子受到惯性力和重力之比</p>
</blockquote>
<h3 id="变质量系统问题题解">变质量系统问题题解</h3>
<p>稍难一些的变质量运动问题：</p>
<blockquote>
<p><em>例题 2-7</em></p>
<p>一架喷气式飞机以 <span class="math inline">\(v=210~\mathrm{m/s}\)</span> 飞行，其引擎每秒吸入 <span class="math inline">\(75~\mathrm{kg}\)</span> 空气，并与 <span class="math inline">\(3~\mathrm{kg}\)</span> 燃料混合后，以相对于飞机 <span class="math inline">\(u=490~\mathrm{m/s}\)</span> 的速度向后喷出，求推力。</p>
</blockquote>
<p>实际上可以直接给出一个标准的解题方式：</p>
<p>设火箭在 <span class="math inline">\(t\)</span> 时刻有质量 <span class="math inline">\(m&#39;\)</span>，速度为 <span class="math inline">\(v\)</span>，使用微元法，在 <span class="math inline">\(dt\)</span> 时间内，有燃料 <span class="math inline">\(dm\)</span> 相对火箭以 <span class="math inline">\(u\)</span> 的速度喷出，火箭速度为 <span class="math inline">\(v+dv\)</span>：</p>
<p><span class="math display">\[
\begin{array}{l}
\vec F\mathrm dt=m&#39;\mathrm d\vec v+\vec u\mathrm dm\\
\Rightarrow\vec v =\vec v_0+\mathrm u\ln\frac {m&#39;}{m&#39;_0}
\end{array}
\]</span></p>
<p>用微元法是解决变质量系统问题的常用方法</p>
<blockquote>
<p><em>例题 2.2</em> 火箭运动的基本原理</p>
</blockquote>
<p>密舍尔斯基方程：<span class="math inline">\(m&#39;\frac{\mathrm d\vec{v}}{\mathrm dt}=\vec{F}+\vec u \frac {\mathrm d m&#39;}{\mathrm d t}\)</span></p>
<p><span class="math inline">\(\vec{u}\)</span> （离开的质量部分）相对速度</p>
<h3 id="知道力求运动状态">知道力求运动状态</h3>
<p>这一部分的题目相对简单，选择合理的坐标系并且列出运动方程即可。一般分情况讨论的问题居多</p>
<blockquote>
<p><em>例题 2-11</em></p>
<p>给定一个平面和三个木块（水平一排相靠放在桌上），现 F 作用在最左侧的木块，讨论不同推力、不同摩擦系数情况下，物体的相互作用力大小。</p>
<p>这里直接列一些公式和条件即可解出，求运动状态的特征不明显。</p>
</blockquote>
<p>或者是</p>
<blockquote>
<p><em>例题 2-14</em></p>
<p>物体 <span class="math inline">\(m\)</span> 从高度为 <span class="math inline">\(h\)</span> 初下落如水中，在水中有粘滞阻力 <span class="math inline">\(bv^2\)</span> 求 <span class="math inline">\(x(t),v(t)\)</span></p>
<p>直角坐标系下解出结果即可</p>
</blockquote>
<p>极坐标系下常常有旋转半径约束，只需要记住 <span class="math inline">\(\displaystyle F=mr^2\omega=mvr=m\frac{v^2}r\)</span></p>
<blockquote>
<p><em>例题 2-19</em></p>
<p>有一个密度均匀的球体，以角速度 <span class="math inline">\(\omega\)</span> 绕自身几何对称轴旋转，若维持其表面物质不因快速旋转二被甩掉的力只有万有引力，求其密度的最小值。</p>
</blockquote>
<h3 id="伽利略变换相对运动非惯性系">伽利略变换、相对运动、非惯性系</h3>
<p>这类题目较少，但实则非常难</p>
<blockquote>
<p>升降机中光滑桌面上有物体 <span class="math inline">\(m_A=100g\)</span> ，通过滑轮与物体 <span class="math inline">\(m_B=200g\)</span> 相连。当升降机以加速度 <span class="math inline">\(a\)</span> 上升，求升降机内、地面上两人看到的 <span class="math inline">\(A,B\)</span> 的加速度。</p>
<p>细心一点，多花点时间计算和复查，问题不大。</p>
</blockquote>
<h3 id="动量定理动量守恒">动量定理、动量守恒</h3>
<p>多用矢量表示动量。</p>
<blockquote>
<p>设有一静止的原子核，衰变辐射出一个电子和一个反中微子后成为一个新的原子核。已知电子和反中微子的运动方向互相垂直，且电子动量为<span class="math inline">\(1.2\times10^{-22}\mathrm{kg·m·s^{-1}}\)</span>，反中微子的动量为<span class="math inline">\(6.4\times10^{-23}\mathrm{kg·m·s^{-1}}\)</span>。问新的原子核的动量的值和方向如何？</p>
</blockquote>
<p>动量定理的题目一般不难：</p>
<blockquote>
<p>质量<span class="math inline">\(m=1kg\)</span>的质点从 O 点开始沿半径 R=2m 的圆周逆时针运动。以 O 点为自然坐标原点，已知质点的运动方程为 <span class="math inline">\(s=0.5\pi t^2\mathrm m\)</span>。试求从 <span class="math inline">\(t=\sqrt 2s\)</span> 到 <span class="math inline">\(t=2s\)</span> 这段时间内质点所受合外力的冲量。</p>
</blockquote>
<!-- TODO: endnote-->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>基础物理学</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>数学在计算机图形学中的应用</title>
    <url>/2020/09/26/study/ComputerScience/ComputerGraphic/Application_of_math%20_in_CG/</url>
    <content><![CDATA[<p>摘抄自刘利刚（中国科学技术大学）http://staff.ustc.edu.cn/~lgliu</p>
<span id="more"></span>
<blockquote>
<p>【注】 本文由Greg Turk. “Mathematics for Computer Graphics, August 1997.” 及网上的中文翻译整理及扩充而得。</p>
</blockquote>
<p>“学习计算机图形学需要多少的数学？”这是初学者最经常问的问题。狭义的计算机图形学指的是传统的三维建模，绘制，动画等，而广义的计算机图形学还包括计算机图像处理，视频处理，计算机视觉和机器学习等 交叉领域。</p>
<p>答案取决于你想在计算机图形学领域钻研多深：</p>
<ul>
<li>如果仅仅使用周围唾手可得的图形软件，如Photoshop, 3D Studio Max, Maya, AutoCAD, Rhino (Grasshoper)等，你不需要知道多少数学知识；通过掌握简单的概念和阅读使用教程你就能使用这些软件的基本功能；但是如果你想精通这些软件，你还是需要学习计算机图形学的一些入门知识的；</li>
<li>如果想学习计算机图形学的入门知识，你至少需要掌握数学分析（微积分）、线性代数和解析几何学的一些基本知识（这些都是大学一年级所学的数学知识）；这也是要成为图形软件高手所必需掌握的；</li>
<li>如果想成为一名计算机图形学的研究工作者，那么对数学的学习将是“活到老，学到老”。重要的是，从以前看似枯燥的数学到看到它的实际应用的过程中，你会更容易享受数学的美妙。在你不断进行计算机图形学的研究的过程中，你会感觉到你的数学知识越来越不够用，从而真正理解“数学不是没有用，而是不够用！”</li>
</ul>
<p>如果你并不特别喜欢数学，是否仍有在计算机图形学领域工作的机会？是的，计算机图形学的确有一些方面不需要考虑太多的数学问题。你不应该因为数学成绩不好而放弃它，如果你对计算机图形学具有强烈兴趣和好奇心的话，而且你还特别喜欢和擅长计算机编程的话。不过，如果学习了更多的数学知识，那么你将在研究课题上有更多的选择余地。如果你要做很好的计算机图形学的研究工作，则建议你还是多学习些数学。</p>
<hr>
<p>对于在计算机图形学中哪些数学才是重要的？这个问题是没有明确的答案的。这领域里不同的方面要求掌握不同的数学知识，也许兴趣将会决定了你的方向。那些基本的数学知识和分析能力是最重要的，而其他的数学则是根据你所从事的方向相关。</p>
<p>下面将介绍我们认为对于计算机图形学有用的数学。别以为想成为一名计算机图形学的研究者就必须精通各门数学！在大学里，你所学的那些数学看起来都很抽象，枯燥无味，这是因为你并不知道它们的用处，甚至连讲课的老师也不知道，而你们的目的只是记住那些定理和公式，考个好分数。与大学学习数学不一样的是，你在计算机图形学的学习和研究过程中会感受到数学的用处和美妙，这时你学习数学的目的将更加明确，兴趣将更加浓厚，学习方法将更加有效。因为你是在使用数学的过程中在学习数学！想想看你是如何学会中文说话的？为了对用于计算机图形学的数学有一个全面的看法，这里特地列出了很多方面。注意，不是这里提到的每个方面你都必须熟悉，许多研究工作者从不需要考虑下面提到的某些数学知识，成功的研究者总是将某一方面的数学知识和数学工具用到极致！</p>
<p>最后，虽然读了这篇文章后，你应该会对数学在计算机图形学中的应用有所了解，不过这也是一家之言。也许你应该阅读更多的此类文章，或者至少从其他从事计算机图形学工作的人那里了解不同的学习重点。</p>
<h3 id="初等代数和三角学">初等代数和三角学</h3>
<p>对于计算机图形学的初学者来说，高中的代数和三角学可能是最重要的数学。日复一日，我从简单的方程解出一个或更多的根。我时常还要解决类似求一些几何图形边长的简单三角学问题。代数和三角学是计算机图形学的最基础的知识。</p>
<p>那么高中的几何学怎么样呢？可能让人惊讶，不过在多数计算机图形学里，高中的几何学并不经常被用到。原因是许多学校教的几何学实际上是如何建立数学证明的课程。虽然证明题对提高智力显然是有效的，但对于计算机图形学来说，那些与几何课有关的定理和证明并不常被用到。如果你毕业于数学相关领域（包括计算机图形学），就会发现虽然你在证明定理，不过这对开始学习图形学不是必要的。</p>
<p>如果精通代数和三角学，就可以开始读一本计算机图形学的入门书了。下一个重要的用于计算机图形学的数学——线性代数，多数此类书籍至少包含了一个对线性代数的简要介绍。</p>
<blockquote>
<p>推荐的参考书:</p>
<p><strong>Computer Graphics: Principles and Practice</strong> James Foley, Andries van Dam, Steven Feiner, John Hughes Addison-Wesley</p>
</blockquote>
<h3 id="线性代数">线性代数</h3>
<p>线性代数的思想贯穿于计算机图形学。事实上，只要牵涉到几何数值表示法，就常常抽象出例如x,y,z坐标之类的数值，我们称之为矢量。计算机图形学自始至终离不开矢量和矩阵。用矢量和矩阵来描述旋转，平移，或者缩放是再好不过了。高中和大学都有线性代数的课程。只要想在计算机图形学领域工作，就应该打下<strong>坚实的线性代数基础</strong>。我刚才提到，许多图形学的书都有关于线性代数的简要介绍——足够教给你图形学的第一门课。</p>
<h3 id="数学分析微积分学">数学分析（微积分学）</h3>
<p>微积分学是高级计算机图形学的重要成分。如果打算学习研究图形学，我强烈建议你应该对微积分学有初步认识。理由不仅仅是微积分学是一种很有用的工具，还有许多研究者用微积分学的术语来描述他们的问题和解决办法。另外，在许多重要的数学领域，微积分学被作为进一步学习的前提。学习了基本代数之后，微积分学又是一种能为你打开多数计算机图形学与后继的数学学习之门的课程。</p>
<h3 id="最优化">最优化</h3>
<p>在计算机图形学里，我们常常为了期望的目标寻求一种合适的描述对象或者对象集的方法。例如安排灯的位置使得房间的照明看起来有种特殊的“感觉”，动画里的人物要怎样活动四肢才能实现一个特殊的动作，怎样排版才不会使页面混乱。以上这些例子可以归结为最优化问题。十年前的计算机图形学几乎没有最优化技术的文献，不过最近这个领域越来越重视最优化理论。我认为在计算机图形学里，最优化的重要性非常重要。</p>
<h3 id="微分几何">微分几何</h3>
<p>微分几何学研究描述和控制光滑曲线，曲面的方程。如果你要计算出经过某个远离曲面的点并垂直于曲面的矢量（法向矢量）就会用到微分几何学。让一辆汽车以特定速度在曲线上行驶也牵涉到微分几何学。有一种通用的绘制光滑曲面的图形学技术，叫做“凹凸帖图”，这个技术用到了微分几何学。另外，要研究曲面的一些几何性质，如曲率、可展性、测地性质等，需要较多的微分几何知识。如果要着手于用曲线和曲面来创造形体（在图形学里称之为建模），你至少应该学习微分几何学的基础。</p>
<h3 id="数值方法计算方法">数值方法（计算方法）</h3>
<p>几乎任何时候，我们在计算机里用近似值代替精确值来表示和操作数值，所以计算过程总是会有误差。而且对于给定的数值问题，常常有多种解决的方法，一些方法会更块，更精确或者对内存的需求更少。数值方法研究的对象包括“计算方法”和“科学计算”等等。这是一个很广阔的领域，而且我将提及的其他几门数学其实是数值方法的一些分支。这些分支包括抽样法理论，矩阵方程组，数值微分方程组和最优化。</p>
<blockquote>
<p>推荐的参考书:</p>
<p><strong>Numerical Recipes in C++: The Art of Scientific Computing</strong> William Press, Saul Teukolsky, William Vetterling and Brian Flannery Cambridge University Press</p>
</blockquote>
<h3 id="抽样法理论和信号处理">抽样法理论和信号处理</h3>
<p>在计算机图形学里我们反复使用储存在正规二维数组里的数字集合来表示一些对象，例如图片和曲面。这时，我们就要用抽样法来表示这些对象。如果要控制这些对象的品质，抽样法理论就变得尤为重要。抽样法应用于图形学的常见例子是当物体被绘制在屏幕上时，它的轮廓呈现锯齿状的边缘。这锯齿状的边缘（被认为是“混淆”现象）是非常让人分散注意力的，用抽样法中著名的技术例如回旋，傅立叶变换，空间和频率的函数表示就能把这个现象减少到最小。这些思想在图像和音频处理领域是同样重要的。</p>
<blockquote>
<p>推荐的参考书:</p>
<p><strong>The Fourier Transform and Its Applications</strong> Ronald N. Bracewell McGraw Hill</p>
</blockquote>
<h3 id="矩阵计算">矩阵计算</h3>
<p>计算机图形学的许多问题要用到矩阵方程组的数值解法。一些涉及矩阵的问题包括：找出最好的位置与方向以使对象们互相匹配（最小二乘法），创建一个覆盖所给点集的曲面，并使皱折程度最小（薄板样条算法），还有材质模拟，例如水和衣服等。在图形学里矩阵表述相当流行，因此在用于图形学的数学中我对矩阵方程组的评价是很高的。</p>
<blockquote>
<p>推荐的参考书:</p>
<p><strong>Matrix Computations</strong> Gene Golub and Charles Van Loan Johns Hopkins University Press</p>
</blockquote>
<h3 id="物理学物理模拟">物理学（物理模拟）</h3>
<p>物理学显然不是数学的分支，它是自成一家的学科。但是在计算机图形学的某些领域，物理学和数学是紧密联系的。在图形学里，牵涉物理学的问题包括光与物体的表面是怎样互相影响的，人与动物的移动方式，水与空气的流动。为了模拟这些自然现象，物理学的知识是必不可少的。这和解微分方程紧密联系，我将会在下一节提到微分方程。</p>
<h3 id="微分方程的数值解法有限元方法">微分方程的数值解法（有限元方法）</h3>
<p>我相信对于计算机图形学来说，解微分方程的技巧是非常重要的。像我们刚才讨论的，计算机图形学致力于模拟源于真实世界的物理系统。波浪是怎样在水里形成的，动物是怎样在地面上行走的，这就是两个模拟物理系统的例子。模拟物理系统的问题经常就是怎样解微分方程的数值解。请注意，微分方程的数值解法与微分方程的符号解法是有很大差异的。符号解法求出没有误差的解，而且时常只用于一些非常简单的方程。有时大学课程里的“微分方程”只教符号解法，不过这并不会对多数计算机图形学的问题有帮助。</p>
<p>在对物理系统的模拟中，我们把世界细分为许多表示成矢量的小元素。然后这些元素之间的关系就可以用矩阵来描述。虽然要处理的矩阵方程组往往没有很精确的解，但是取而代之的是执行了一系列的计算，这些计算产生一个表示成数列的近似解。这就是微分方程的数值解法。请注意，矩阵方程的解法与微分方程数值解法的关系是很密切的。</p>
<h3 id="概率论与统计学">概率论与统计学</h3>
<p>计算机图形学的许多领域都要用到概率论与统计学。当研究者涉足人类学科时，他们当然需要统计学来分析数据。图形学相关领域涉及人类学科，例如虚拟现实和人机交互(HCI)。另外，许多用计算机描绘真实世界的问题牵涉到各种未知事件的概率。两个例子：一棵成长期的树,它的树枝分杈的概率；虚拟的动物如何决定它的行走路线。最后，一些解高难度方程组的技巧用了随机数来估计方程组的解。重要的例子：蒙特卡罗方法经常用于光如何传播的问题。以上仅是一部分在计算机图形学里使用概率论和统计学的方法。</p>
<p>另外，在机器学习和统计学习中，需要非常多和深入的统计学知识。</p>
<h3 id="拓扑学">拓扑学</h3>
<p>用一句话来形容拓扑学，它研究油炸圈饼与咖啡杯为什么在本质上是相同的。答案是他们都是只有一个洞的曲面。对于计算机图形学来说，拓扑学的形式（符号表示法）是表达思想的简便方法，常用于分析一些曲面的性质，在形状分析、形状匹配和搜索中得到应用。</p>
<h3 id="黎曼几何">黎曼几何</h3>
<p>黎曼几何是研究流形曲面上的微积分与微分几何。不同与三维欧氏空间，它研究的曲面是在流形曲面上，其中用到不同的度量。这部分数学知识有点抽象，但是同样有效地被用到计算机图形学中。如共形几何理论就被发展起来在计算机图形学中得到广泛的应用。</p>
<h3 id="抽象代数">抽象代数</h3>
<p>抽象代数就是研究群论，环论和域的代数学。相对于线性代数，内容也比较抽象。在计算机图形学上也时有用到。</p>
<h3 id="计算几何">计算几何</h3>
<p>计算几何学研究如何用计算机高效地表示与操作几何体。典型问题如，碰撞检测，把多边形分解为三角形，找出最靠近某个位置的点，这个学科包括了运算法则，数据结构和数学。图形学的研究者，只要涉足创建形体（建模），就要大量用到计算几何学。</p>
<blockquote>
<p>推荐的参考书: <strong>Computational Geometry in C</strong> Joseph O'Rourke Cambridge University Press</p>
<p><strong>Computational Geometry: An Introduction</strong> Franco Preparata and Michael Shamos Springer-Verlag</p>
</blockquote>
<h3 id="其他几何学">其他几何学</h3>
<p>一些其他的几何学，如《仿射几何》、《射影几何》在计算机图形学的某些问题上用得比较多，对工程具有较大的促进应用。</p>
<h3 id="总结数学应用和数学理论">总结：数学应用和数学理论</h3>
<p>对于图形学来说，以上提到的许多数学学科都有个共同点：比起这些数学的理论价值，我们更倾向于发掘它们的应用价值。不要惊讶。计算机图形学的许多问题和物理学者与工程师们研究的问题是紧密联系的，并且物理学者与工程师们使用的数学工具正是计算机图形学研究者们使用的。多数研究纯数学理论的学科从不被用于计算机图形学。不过这不是绝对的。请注意这些特例：分子生物学正利用节理论来研究DNA分子动力学，亚原子物理学用到了抽象群论。也许有一天，纯数学理论也能推动计算机图形学的发展，谁知道呢？</p>
<p>事实上，文章中所提到一些数学分支，按照我国的教育体制，在数学系本科的学生（或者硕士研究生阶段的理工科学生）基本都能接触到。但是大学所学习的数学比较偏重于证明以构建完备的数学理论框架，而不太注重实际的使用，现在的大学教师授课的方式也是这样。</p>
<p>我认为，学习数学最好的方式就是使用它，使用它越多，你就觉得它越有用，越有趣，学得就越好，也越快，越扎实。当然，很少有人能精通全部的知识，对于计算机图形学的学习和实践，应当采取掌握较为宽广的数学知识基础，在需要的时候，对相关的数学知识再进行深入的学习和挖掘；不要因为自身数学知识的匮乏而沮丧，更不能因此而敌视数学，保持对计算机图形学强烈的兴趣和乐观上进的学习态度是学习计算机图形学的关键。</p>
<p>还有一点需要指出的是，在学习计算机图形学的过程中，你会发现各个方面的数学知识都会被用到，因此你掌握的数学知识会比较全面，也知道如何在实际中应用。这可能是应用数学在所有学科得到最好的体现。相反，一些做纯理论的数学工作者，掌握的数学知识就是他们所研究的一块，而对其他的数学知识掌握得就不够好，他们做得比较深入。当然，做应用数学和理论数学都有值得敬仰的地方，一个侧重在实际应用，而另一个侧重在理论深度，但要做好都不是很容易。数学说到底还是要学老用的。相对来讲，做计算机图形学能看到学到的数学在实际中所用了，“所用即所学”。试想一下，当你能看到自己做的美妙的东西被别人看到且被敬仰的时候，你的成就感一定会很大！</p>
<p>最后说一点的就是，学习计算机图形学和从事计算机图形学的研究，除了数学基础外，还需要较强的计算机编程能力，你务必要掌握和熟练一门编程语言，一般建议C/C++，因为你要实现出你的想法，你必须编程去实现出来，做出漂亮的结果。编程也是很有趣的，只要你有兴趣，提高是非常快的！当然，这里我不阐述如何提高编程的能力和水平的方法。“数学”和“编程”，两手都要抓，两手都要硬！提醒大家一点的是，如果你对编程兴趣不大，或者就不愿编程，那你就不适合选择计算机图形学，可能更适合选择其他方向，比如统计学或理论数学。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>摘抄</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/18/talk-chat/Google_C_programming_specification/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="c编程规范">c++编程规范</h1>
<h2 id="扉页">0. 扉页</h2>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 86%">
</colgroup>
<thead>
<tr class="header">
<th>版本:</th>
<th>4.45</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原作者:</td>
<td>Benjy WeinbergerCraig SilversteinGregory EitzmannMark MentovaiTashana Landray</td>
</tr>
<tr class="even">
<td>翻译:</td>
<td><a href="http://www.yulefox.com/">YuleFox</a><a href="https://github.com/yangyubo">Yang.Y</a><a href="http://acgtyrant.com/">acgtyrant</a><a href="http://github.com/lilinsanity">lilinsanity</a></td>
</tr>
<tr class="odd">
<td>项目主页:</td>
<td><a href="http://google-styleguide.googlecode.com/">Google Style Guide</a><a href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></td>
</tr>
</tbody>
</table>
<h3 id="译者前言">0.1 译者前言</h3>
<p>Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码. 但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交者造成不小的困扰. Google 因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google 的编程风格.</p>
<p>翻译初衷:</p>
<blockquote>
<p>规则的作用就是避免混乱. 但规则本身一定要权威, 有说服力, 并且是理性的. 我们所见过的大部分编程规范, 其内容或不够严谨, 或阐述过于简单, 或带有一定的武断性.</p>
<p>Google 保持其一贯的严谨精神, 5 万汉字的指南涉及广泛, 论证严密. 我们翻译该系列指南的主因也正是其严谨性. 严谨意味着指南的价值不仅仅局限于它罗列出的规范, 更具参考意义的是它为了列出规范而做的谨慎权衡过程.</p>
<p>指南不仅列出你要怎么做, 还告诉你为什么要这么做, 哪些情况下可以不这么做, 以及如何权衡其利弊. 其他团队未必要完全遵照指南亦步亦趋, 如前面所说, 这份指南是 Google 根据自身实际情况打造的, 适用于其主导的开源项目. 其他团队可以参照该指南, 或从中汲取灵感, 建立适合自身实际情况的规范.</p>
<p>我们在翻译的过程中, 收获颇多. 希望本系列指南中文版对你同样能有所帮助.</p>
</blockquote>
<p>我们翻译时也是尽力保持严谨, 但水平所限, bug 在所难免. 有任何意见或建议, 可与我们取得联系.</p>
<p>中文版和英文版一样, 使用 <code>Artistic License/GPL</code> 开源许可.</p>
<p>中文版修订历史:</p>
<blockquote>
<ul>
<li><p>2015-08 : 热心的清华大学同学 <span class="citation" data-cites="lilinsanity">@lilinsanity</span> 完善了「类」章节以及其它一些小章节。至此，对 Google CPP Style Guide 4.45 的翻译正式竣工。</p></li>
<li><p>2015-07 4.45 : acgtyrant 为了学习 C++ 的规范，顺便重新翻译了本 C++ 风格指南，特别是 C++11 的全新内容。排版大幅度优化，翻译措辞更地道，添加了新译者笔记。Google 总部 C++ 工程师 innocentim, 清华大学不愿意透露姓名的唐马儒先生，大阪大学大学院情报科学研究科计算机科学专攻博士 farseerfc 和其它 Arch Linux 中文社区众帮了译者不少忙，谢谢他们。因为 C++ Primer 尚未完全入门，暂时没有翻译「类」章节和其它一些小章节。</p></li>
<li><p>2009-06 3.133 : YuleFox 的 1.0 版已经相当完善, 但原版在近一年的时间里, 其规范也发生了一些变化.</p></li>
</ul>
<blockquote>
<p>Yang.Y 与 YuleFox 一拍即合, 以项目的形式来延续中文版 : <a href="http://github.com/yangyubo/zh-google-styleguide">Google 开源项目风格指南 - 中文版项目</a>.</p>
<p>主要变化是同步到 3.133 最新英文版本, 做部分勘误和改善可读性方面的修改, 并改进排版效果. Yang.Y 重新翻修, YuleFox 做后续评审.</p>
</blockquote>
<ul>
<li>2008-07 1.0 : 出自 <a href="http://www.yulefox.com/?p=207">YuleFox 的 Blog</a>, 很多地方摘录的也是该版本.</li>
</ul>
</blockquote>
<h3 id="背景">0.2 背景</h3>
<p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.</p>
<p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p>
<p><em>风格</em>, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 "风格" 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p>
<p>使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 "模式匹配" 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.</p>
<p>本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.</p>
<p>Google 主导的开源项目均符合本指南的规定.</p>
<p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p>
<h2 id="头文件">1. 头文件</h2>
<p>通常每一个 <code>.cc</code> 文件都有一个对应的 <code>.h</code> 文件. 也有一些常见例外, 如单元测试代码和只包含 <code>main()</code> 函数的 <code>.cc</code> 文件.</p>
<p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p>
<p>下面的规则将引导你规避使用头文件时的各种陷阱.</p>
<h3 id="self-contained-头文件">1.1. Self-contained 头文件</h3>
<p>Tip</p>
<p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code>.h</code> 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code> 头文件的做法.</p>
<p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">1.2. ##define 保护</a>，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.</p>
<p>不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 <code>.inc</code> 文件扩展名。</p>
<p>如果 <code>.h</code> 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 <code>.cc</code> 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 <code>-inl.h</code> 文件里（译者注：过去该规范曾提倡把定义放到 -inl.h 里过）。</p>
<p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 <code>.cc</code> 文件里。</p>
<h3 id="define-保护">1.2. ##define 保护</h3>
<blockquote>
<p>[!TIP]</p>
<p>1</p>
</blockquote>
<p>所有头文件都应该使用 <code>##define</code> 来防止头文件被多重包含, 命名格式当是: <code>___H_</code> .</p>
<p>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 <code>foo</code> 中的头文件 <code>foo/src/bar/baz.h</code> 可按如下方式保护:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></table></figure>
<h3 id="前置声明">1.3. 前置声明</h3>
<p>尽可能地避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</p>
<p><strong>定义：</strong></p>
<blockquote>
<p>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p>
</blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<ul>
<li>前置声明能够节省编译时间，多余的 <code>#include</code> 会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够节省不必要的重新编译的时间。 <code>#include</code> 使代码因为头文件中无关的改动而被重新编译多次。</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li><p>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</p></li>
<li><p>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</p></li>
<li><p>前置声明来自命名空间 <code>std::</code> 的 symbol 时，其行为未定义。</p></li>
<li><p>很难判断什么时候该用前置声明，什么时候该用 <code>#include</code> 。极端情况下，用前置声明代替 <code>includes</code> 甚至都会暗暗地改变代码的含义：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.h:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good_user.cc:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>&#123; <span class="built_in">f</span>(x); &#125;  <span class="comment">// calls f(B*)</span></span><br></pre></td></tr></table></figure>
</blockquote></li>
</ul>
<blockquote>
<p>如果 <code>#include</code> 被 <code>B</code> 和 <code>D</code> 的前置声明替代， <code>test()</code> 就会调用 <code>f(void*)</code> .</p>
</blockquote>
<ul>
<li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 <code>include</code> 冗长。</li>
<li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li>
</ul>
</blockquote>
<p><strong>结论：</strong></p>
<blockquote>
<ul>
<li>尽量避免前置声明那些定义在其他项目中的实体.</li>
<li>函数：总是使用 <code>#include</code>.</li>
<li>类模板：优先使用 <code>#include</code>.</li>
</ul>
</blockquote>
<p>至于什么时候包含头文件，参见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##name-and-order-of-includes">1.5. #include 的路径及顺序</a> 。</p>
<h3 id="内联函数">1.4. 内联函数</h3>
<p>Tip</p>
<p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
<p><strong>定义:</strong></p>
<blockquote>
<p>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</p>
</blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<p>只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p>
</blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<p>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p>
</blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<p>另一个实用的经验准则: 内联那些包含循环或 <code>switch</code> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <code>switch</code> 语句从不被执行).</p>
<p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p>
</blockquote>
<h3 id="include-的路径及顺序">1.5. <code>#include</code> 的路径及顺序</h3>
<p>Tip</p>
<p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.</p>
<p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <code>.</code> (当前目录) 或 <code>..</code> (上级目录). 例如, <code>google-awesome-project/src/base/logging.h</code> 应该按如下方式包含:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base/logging.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>又如, <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p>
<blockquote>
<ol type="1">
<li><code>dir2/foo2.h</code> (优先位置, 详情如下)</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的 <code>.h</code> 文件</li>
<li>本项目内 <code>.h</code> 文件</li>
</ol>
</blockquote>
<p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p>
<p><code>dir/foo.cc</code> 和 <code>dir2/foo2.h</code> 通常位于同一目录下 (如 <code>base/basictypes_unittest.cc</code> 和 <code>base/basictypes.h</code>), 但也可以放在不同目录下.</p>
<p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p>
<p>您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##forward-declarations">前置声明</a> (forward declarations) 情况除外。比如您要用到 <code>bar.h</code> 中的某个符号, 哪怕您所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code> 就够了，不用再管后者所包含的其它内容。</p>
<p>举例来说, <code>google-awesome-project/src/foo/internal/fooserver.cc</code> 的包含次序如下:</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo/public/fooserver.h&quot;</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base/basictypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base/commandlineflags.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo/public/bar.h&quot;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>例外：</strong></p>
<p>有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo/public/fooserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;base/port.h&quot;</span>  <span class="comment">// For LANG_CXX11.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LANG_CXX11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// LANG_CXX11</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="译者-yulefox-笔记">译者 (YuleFox) 笔记</h3>
<ol type="1">
<li>避免多重包含是学编程时最基本的要求;</li>
<li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li>
<li>内联函数的合理使用可提高代码执行效率;</li>
<li><code>-inl.h</code> 可提高代码可读性 (一般用不到吧:D);</li>
<li>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li>
<li>包含文件的名称使用 <code>.</code> 和 <code>..</code> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</li>
</ol>
<h3 id="译者acgtyrant笔记">译者（acgtyrant）笔记</h3>
<ol type="1">
<li>原来还真有项目用 <code>##includes</code> 来插入文本，且其文件扩展名 <code>.inc</code> 看上去也很科学。</li>
<li>Google 已经不再提倡 <code>-inl.h</code> 用法。</li>
<li>注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li>
<li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 <code>.cc</code> 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li>
<li>在 <code>#include</code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code>.h</code> 和本项目内的 <code>.h</code> 是个好习惯。</li>
</ol>
<h2 id="作用域">2. 作用域</h2>
<h3 id="命名空间">2.1. 命名空间</h3>
<p>Tip</p>
<p>鼓励在 <code>.cc</code> 文件内使用匿名命名空间或 <code>static</code> 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p>
<p><strong>定义:</strong></p>
<blockquote>
<p>命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.</p>
</blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层.</p>
<p>举例来说, 两个不同项目的全局作用域都有一个类 <code>Foo</code>, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, <code>project1::Foo</code> 和 <code>project2::Foo</code> 作为不同符号自然不会冲突.</p>
<p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace Y</span></span><br><span class="line">&#125;  <span class="comment">// namespace X</span></span><br></pre></td></tr></table></figure>
<p><code>X::Y::foo()</code> 与 <code>X::foo()</code> 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p>
</blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<p>命名空间具有迷惑性, 因为它们使得区分两个相同命名所指代的定义更加困难。</p>
<p>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p>
<p>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。</p>
<p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</p>
</blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<p>根据下文将要提到的策略合理使用命名空间.</p>
<ul>
<li><p>遵守 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/naming.html##namespace-names">命名空间命名</a> 中的规则。</p></li>
<li><p>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</p></li>
<li><p>用命名空间把文件包含, <a href="https://gflags.github.io/gflags/">gflags</a> 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure>
<p>更复杂的 <code>.cc</code> 文件包含更多, 更复杂的细节, 比如 gflags 或 using 声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="built_in">DEFINE_FLAG</span>(<span class="keyword">bool</span>, someflag, <span class="literal">false</span>, <span class="string">&quot;dummy flag&quot;</span>);</span><br><span class="line"><span class="keyword">namespace</span> a &#123;</span><br><span class="line"></span><br><span class="line">...code <span class="keyword">for</span> a...                <span class="comment">// 左对齐</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace a</span></span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>不要在命名空间 <code>std</code> 内声明任何东西, 包括标准库的类前置声明. 在 <code>std</code> 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</p></li>
<li><p>不应该使用 <em>using 指示</em> 引入整个命名空间的标识符号。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止 —— 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>不要在头文件中使用 <em>命名空间别名</em> 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .cc 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 .h 中使用别名缩短常用的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> librarian &#123;</span><br><span class="line"><span class="keyword">namespace</span> impl &#123;  <span class="comment">// 仅限内部使用</span></span><br><span class="line"><span class="keyword">namespace</span> sidetable = ::pipeline_diagnostics::sidetable;</span><br><span class="line">&#125;  <span class="comment">// namespace impl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">my_inline_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 限制在一个函数中的命名空间别名</span></span><br><span class="line">  <span class="keyword">namespace</span> baz = ::foo::bar::baz;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace librarian</span></span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>禁止用内联命名空间</p></li>
</ul>
</blockquote>
<h3 id="匿名命名空间和静态变量">2.2. 匿名命名空间和静态变量</h3>
<p>Tip</p>
<p>在 <code>.cc</code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p>
<p><strong>定义:</strong></p>
<blockquote>
<p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 <code>static</code> 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p>
</blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<p>推荐、鼓励在 <code>.cc</code> 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 <code>.h</code> 中使用。</p>
<p>匿名命名空间的声明和具名的格式相同，在最后注释上 <code>namespace</code> :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="非成员函数静态成员函数和全局函数">2.3. 非成员函数、静态成员函数和全局函数</h3>
<p>Tip</p>
<p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p>
<p><strong>优点:</strong></p>
<blockquote>
<p>某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域.</p>
</blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<p>将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.</p>
</blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">2.1. 命名空间</a> 。举例而言，对于头文件 <code>myproject/foo_bar.h</code> , 应当使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure>
<p>而非</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure>
<p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p>
<p>如果你必须定义非成员函数, 又只是在 <code>.cc</code> 文件中使用它, 可使用匿名 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">2.1. 命名空间</a> 或 <code>static</code> 链接关键字 (如 <code>static int Foo() &#123;...&#125;</code>) 限定其作用域.</p>
</blockquote>
<h3 id="局部变量">2.4. 局部变量</h3>
<p>Tip</p>
<p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p>
<p>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 坏——初始化和声明分离</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 好——初始化时声明</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 好——v 一开始就初始化</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>属于 <code>if</code>, <code>while</code> 和 <code>for</code> 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Warning</p>
<p>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环作用域外面声明这类变量要高效的多:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态和全局变量">2.5. 静态和全局变量</h3>
<p>Tip</p>
<p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p>
<p>禁止使用类的 <a href="http://zh.cppreference.com/w/cpp/language/storage_duration##.E5.AD.98.E5.82.A8.E6.9C.9F">静态储存周期</a> 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 <code>constexpr</code> 变量除外，毕竟它们又不涉及动态初始化或析构。</p>
<p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 <code>getenv()</code> 或 <code>getpid()</code> ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p>
<p>Note</p>
<p>Xris 译注:</p>
<p>同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。</p>
<p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 <code>main()</code> 返回还是对 <code>exit()</code> 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>改善以上析构问题的办法之一是用 <code>quick_exit()</code> 来代替 <code>exit()</code> 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 <code>atexit()</code> 所绑定的任何 handlers. 如果您想在执行 <code>quick_exit()</code> 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 <code>_at_quick_exit()</code>. 如果您想在 <code>exit()</code> 和 <code>quick_exit()</code> 都用上该 handler, 都绑定上去。</p>
<p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 <code>vector</code> (使用 C 数组替代) 和 <code>string</code> (使用 <code>const char []</code>)。</p>
<p>如果您确实需要一个 <code>class</code> 类型的静态或全局变量，可以考虑在 <code>main()</code> 函数或 <code>pthread_once()</code> 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p>
<p>Note</p>
<p>Yang.Y 译注:</p>
<p>上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</p>
<h3 id="译者-yulefox-笔记-1">译者 (YuleFox) 笔记</h3>
<ol type="1">
<li><code>cc</code> 中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用 <code>using</code> 关键字污染命名空间;</li>
<li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code>public</code>;</li>
<li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</li>
<li>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</li>
<li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</li>
</ol>
<h3 id="译者acgtyrant笔记-1">译者（acgtyrant）笔记</h3>
<ol type="1">
<li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li>
<li>匿名命名空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li>
<li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li>
<li>注意别在循环犯大量构造和析构的低级错误。</li>
</ol>
<h2 id="类">3. 类</h2>
<p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.</p>
<h3 id="构造函数的职责">3.1. 构造函数的职责</h3>
<p><strong>总述</strong></p>
<p>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>
<p><strong>定义</strong></p>
<p>在构造函数中可以进行各种初始化操作.</p>
<p><strong>优点</strong></p>
<ul>
<li>无需考虑类是否被初始化.</li>
<li>经过构造函数完全初始化后的对象可以为 <code>const</code> 类型, 也能更方便地被标准容器或算法使用.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</li>
<li>在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##exceptions">禁用</a> 了) 等方法的条件下, 构造函数很难上报错误</li>
<li>如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 <code>bool IsValid()</code> 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.</li>
<li>构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.</li>
</ul>
<p><strong>结论</strong></p>
<p>构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 <code>Init()</code> 方法或工厂函数.</p>
<p>构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式. Avoid <code>Init()</code> methods on objects with no other states that affect which public methods may be called (此类形式的半构造对象有时无法正确工作).</p>
<h3 id="隐式类型转换">3.2. 隐式类型转换</h3>
<p><strong>总述</strong></p>
<p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 <code>explicit</code> 关键字.</p>
<p><strong>定义</strong></p>
<p>隐式类型转换允许一个某种类型 (称作 <em>源类型</em>) 的对象被用于需要另一种类型 (称作 <em>目的类型</em>) 的位置, 例如, 将一个 <code>int</code> 类型的参数传递给需要 <code>double</code> 类型的函数.</p>
<p>除了语言所定义的隐式类型转换, 用户还可以通过在类定义中添加合适的成员定义自己需要的转换. 在源类型中定义隐式类型转换, 可以通过目的类型名的类型转换运算符实现 (例如 <code>operator bool()</code>). 在目的类型中定义隐式类型转换, 则通过以源类型作为其唯一参数 (或唯一无默认值的参数) 的构造函数实现.</p>
<p><code>explicit</code> 关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换, 例如使用 <code>cast</code>. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(Foo f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>此时下面的代码是不允许的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Func</span>(&#123;<span class="number">42</span>, <span class="number">3.14</span>&#125;);  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是 <code>explicit</code> 应当限制的行为.</p>
<p><strong>优点</strong></p>
<ul>
<li>有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强.</li>
<li>隐式类型转换可以简单地取代函数重载.</li>
<li>在初始化对象时, 列表初始化语法是一种简洁明了的写法.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</li>
<li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用.</li>
<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>
<li>如果单参数构造函数没有加上 <code>explicit</code> 关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上 <code>explicit</code> 标记.</li>
<li>并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清.</li>
<li>如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候.</li>
</ul>
<p><strong>结论</strong></p>
<p>在类型定义中, 类型转换运算符和单参数构造函数都应当用 <code>explicit</code> 进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为 <code>explicit</code>, 因为它们并不执行类型转换. 对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的. 这时应当联系项目组长并说明特殊情况.</p>
<p>不能以一个参数进行调用的构造函数不应当加上 <code>explicit</code>. 接受一个 <code>std::initializer_list</code> 作为参数的构造函数也应当省略 <code>explicit</code>, 以便支持拷贝初始化 (例如 <code>MyType m = &#123;1, 2&#125;;)</code> .</p>
<h3 id="可拷贝类型和可移动类型">3.3. 可拷贝类型和可移动类型</h3>
<p><strong>总述</strong></p>
<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
<p><strong>定义</strong></p>
<p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. <code>string</code> 类型就是一个可拷贝类型的例子.</p>
<p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). <code>std::unique_ptr</code> 就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的.</p>
<p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.</p>
<p><strong>优点</strong></p>
<p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器.</p>
<p>拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如 <code>Clone()</code>, <code>CopyFrom()</code> or <code>Swap()</code>, 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过 <code>= default</code>. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 <a href="http://en.cppreference.com/w/cpp/language/copy_elision">省略不必要的拷贝</a> 这样的优化它们也更加合适.</p>
<p>移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰.</p>
<p><strong>缺点</strong></p>
<p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型 (<code>Registerer</code>), 与特定的作用域相关的类型 (<code>Cleanup</code>), 与其他对象实体紧耦合的类型 (<code>Mutex</code>) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成 <a href="https://en.wikipedia.org/wiki/Object_slicing">对象切割</a> . 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误.</p>
<p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.</p>
<p><strong>结论</strong></p>
<p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p>
<p>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>(Foo&amp;&amp; other) : <span class="built_in">field_</span>(other.field) &#123;&#125;</span><br><span class="line">  <span class="comment">// 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Field field_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <code>public virtual Clone()</code> 和一个 <code>protected</code> 的拷贝构造函数以供派生类实现.</p>
<p>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 <code>public</code> 域中使用 <code>= delete</code> 或其他手段禁用之.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line"><span class="built_in">MyClass</span>(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass&amp;) = delee;</span><br></pre></td></tr></table></figure>
<h3 id="结构体-vs.-类">3.4. 结构体 VS. 类</h3>
<p><strong>总述</strong></p>
<p>仅当只有数据成员时使用 <code>struct</code>, 其它一概使用 <code>class</code>.</p>
<p><strong>说明</strong></p>
<p>在 C++ 中 <code>struct</code> 和 <code>class</code> 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字.</p>
<p><code>struct</code> 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, <code>Initialize()</code>, <code>Reset()</code>, <code>Validate()</code> 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.</p>
<p>如果需要更多的函数功能, <code>class</code> 更适合. 如果拿不准, 就用 <code>class</code>.</p>
<p>为了和 STL 保持一致, 对于仿函数等特性可以不用 <code>class</code> 而是使用 <code>struct</code>.</p>
<p>注意: 类和结构体的成员变量使用不同的 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##variable-names">命名规则</a>.</p>
<h3 id="继承">3.5. 继承</h3>
<p><strong>总述</strong></p>
<p>使用组合 (YuleFox 注: 这一点也是 GoF 在 &lt;<Design patterns>&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 <code>public</code> 继承.</Design></p>
<p><strong>定义</strong></p>
<p>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">接口继承</a>, 子类仅继承父类的方法名称.</p>
<p><strong>优点</strong></p>
<p>实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.</p>
<p><strong>缺点</strong></p>
<p>对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局.</p>
<p><strong>结论</strong></p>
<p>所有继承必须是 <code>public</code> 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p>
<p>不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 <code>Bar</code> 的确 “是一种” <code>Foo</code>, <code>Bar</code> 才能继承 <code>Foo</code>.</p>
<p>必要的话, 析构函数声明为 <code>virtual</code>. 如果你的类有虚函数, 则析构函数也应该为虚函数.</p>
<p>对于可能被子类访问的成员函数, 不要过度使用 <code>protected</code> 关键字. 注意, 数据成员都必须是 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##access-control">私有的</a>.</p>
<p>对于重载的虚函数或虚析构函数, 使用 <code>override</code>, 或 (较不常用的) <code>final</code> 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 <code>virtual</code> 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 <code>override</code>, <code>final</code> 或 <code>virtual</code> 的其中之一进行标记. 标记为 <code>override</code> 或 <code>final</code> 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p>
<h3 id="多重继承">3.6. 多重继承</h3>
<p><strong>总述</strong></p>
<p>真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code>Interface</code> 为后缀的 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">纯接口类</a>.</p>
<p><strong>定义</strong></p>
<p>多重继承允许子类拥有多个基类. 要将作为 <em>纯接口</em> 的基类和具有 <em>实现</em> 的基类区别开来.</p>
<p><strong>优点</strong></p>
<p>相比单继承 (见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##inheritance">继承</a>), 多重实现继承可以复用更多的代码.</p>
<p><strong>缺点</strong></p>
<p>真正需要用到多重 <em>实现</em> 继承的情况少之又少. 有时多重实现继承看上去是不错的解决方案, 但这时你通常也可以找到一个更明确, 更清晰的不同解决方案.</p>
<p><strong>结论</strong></p>
<p>只有当所有父类除第一个外都是 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##interface">纯接口类</a> 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 <code>Interface</code> 为后缀.</p>
<p><strong>注意</strong></p>
<p>关于该规则, Windows 下有个 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/exceptions/##windows-code">特例</a>.</p>
<h3 id="接口">3.7. 接口</h3>
<p><strong>总述</strong></p>
<p>接口是指满足特定条件的类, 这些类以 <code>Interface</code> 为后缀 (不强制).</p>
<p><strong>定义</strong></p>
<p>当一个类满足以下要求时, 称之为纯接口:</p>
<ul>
<li>只有纯虚函数 (“<code>=0</code>”) 和静态函数 (除了下文提到的析构函数).</li>
<li>没有非静态数据成员.</li>
<li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 <code>protected</code>.</li>
<li>如果它是一个子类, 也只能从满足上述条件并以 <code>Interface</code> 为后缀的类继承.</li>
</ul>
<p>接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 <em>The C++ Programming Language, 3rd edition</em> 第 12.4 节.</p>
<p><strong>优点</strong></p>
<p>以 <code>Interface</code> 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##multiple-inheritance">多重继承</a> 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</p>
<p><strong>缺点</strong></p>
<p><code>Interface</code> 后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户.</p>
<p><strong>结论</strong></p>
<p>只有在满足上述条件时, 类才以 <code>Interface</code> 结尾, 但反过来, 满足上述需要的类未必一定以 <code>Interface</code> 结尾.</p>
<h3 id="运算符重载">3.8. 运算符重载</h3>
<p><strong>总述</strong></p>
<p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p>
<p><strong>定义</strong></p>
<p>C++ 允许用户通过使用 <code>operator</code> 关键字 <a href="http://en.cppreference.com/w/cpp/language/operators">对内建运算符进行重载定义</a> , 只要其中一个参数是用户定义的类型. <code>operator</code> 关键字还允许用户使用 <code>operator""</code> 定义新的字面运算符, 并且定义类型转换函数, 例如 <code>operator bool()</code>.</p>
<p><strong>优点</strong></p>
<p>重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为. 重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如 <code>==</code>, <code>&lt;</code>, <code>=</code>, <code>&lt;&lt;</code>), 遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作.</p>
<p>对于创建用户定义的类型的对象来说, 用户定义字面量是一种非常简洁的标记.</p>
<p><strong>缺点</strong></p>
<ul>
<li>要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug.</li>
<li>过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时.</li>
<li>函数重载有多少弊端, 运算符重载就至少有多少.</li>
<li>运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.</li>
<li>对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了, 这时需要能够理解 C++ 语法的搜索工具.</li>
<li>如果重载运算符的参数写错, 此时得到的可能是一个完全不同的重载而非编译错误. 例如: <code>foo &lt; bar</code> 执行的是一个行为, 而 <code>&amp;foo &lt; &amp;bar</code> 执行的就是完全不同的另一个行为了.</li>
<li>重载某些运算符本身就是有害的. 例如, 重载一元运算符 <code>&amp;</code> 会导致同样的代码有完全不同的含义, 这取决于重载的声明对某段代码而言是否是可见的. 重载诸如 <code>&amp;&amp;</code>, <code>||</code> 和 <code>,</code> 会导致运算顺序和内建运算的顺序不一致.</li>
<li>运算符从通常定义在类的外部, 所以对于同一运算, 可能出现不同的文件引入了不同的定义的风险. 如果两种定义都链接到同一二进制文件, 就会导致未定义的行为, 有可能表现为难以发现的运行时错误.</li>
<li>用户定义字面量所创建的语义形式对于某些有经验的 C++ 程序员来说都是很陌生的.</li>
</ul>
<p><strong>结论</strong></p>
<p>只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, <code>|</code> 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道.</p>
<p>只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, <code>.cc</code> 中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, 请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了 <code>&lt;</code>, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数, <code>&lt;</code> 和 <code>&gt;</code> 不会同时返回 <code>true</code>.</p>
<p>建议不要将不进行修改的二元运算符定义为成员函数. 如果一个二元运算符被定义为类成员, 这时隐式转换会作用域右侧的参数却不会作用于左侧. 这时会出现 <code>a &lt; b</code> 能够通过编译而 <code>b &lt; a</code> 不能的情况, 这是很让人迷惑的.</p>
<p>不要为了避免重载操作符而走极端. 比如说, 应当定义 <code>==</code>, <code>=</code>, 和 <code>&lt;&lt;</code> 而不是 <code>Equals()</code>, <code>CopyFrom()</code> 和 <code>PrintTo()</code>. 反过来说, 不要只是为了满足函数库需要而去定义运算符重载. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入 <code>std::set</code> 中, 最好还是定义一个自定义的比较运算符而不是重载 <code>&lt;</code>.</p>
<p>不要重载 <code>&amp;&amp;</code>, <code>||</code>, <code>,</code> 或一元运算符 <code>&amp;</code>. 不要重载 <code>operator""</code>, 也就是说, 不要引入用户定义字面量.</p>
<p>类型转换运算符在 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##implicit-conversions">隐式类型转换</a> 一节有提及. <code>=</code> 运算符在 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##copyable-and-movable-types">可拷贝类型和可移动类型</a> 一节有提及. 运算符 <code>&lt;&lt;</code> 在 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##streams">流</a> 一节有提及. 同时请参见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">函数重载</a> 一节, 其中提到的的规则对运算符重载同样适用.</p>
<h3 id="存取控制">3.9. 存取控制</h3>
<p><strong>总述</strong></p>
<p>将 <em>所有</em> 数据成员声明为 <code>private</code>, 除非是 <code>static const</code> 类型成员 (遵循 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量命名规则</a>). 处于技术上的原因, 在使用 <a href="https://github.com/google/googletest">Google Test</a> 时我们允许测试固件类中的数据成员为 <code>protected</code>.</p>
<h3 id="声明顺序">3.10. 声明顺序</h3>
<p><strong>总述</strong></p>
<p>将相似的声明放在一起, 将 <code>public</code> 部分放在最前.</p>
<p><strong>说明</strong></p>
<p>类定义一般应以 <code>public:</code> 开始, 后跟 <code>protected:</code>, 最后是 <code>private:</code>. 省略空部分.</p>
<p>在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 <code>typedef</code>, <code>using</code> 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</p>
<p>不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 参见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##inline-functions">内联函数</a> 一节.</p>
<h3 id="译者-yulefox-笔记-2">译者 (YuleFox) 笔记</h3>
<ol type="1">
<li>不在构造函数中做太多逻辑相关的初始化;</li>
<li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;</li>
<li>为避免隐式转换, 需将单参数构造函数声明为 <code>explicit</code>;</li>
<li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 <code>private</code> 且无需实现;</li>
<li>仅在作为数据集合时使用 <code>struct</code>;</li>
<li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 <code>virtual</code> 关键字, 虽然编译器允许不这样做;</li>
<li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;</li>
<li>接口类类名以 <code>Interface</code> 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 <code>protected</code>;</li>
<li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;</li>
<li>存取函数一般内联在头文件中;</li>
<li>声明次序: <code>public</code> -&gt; <code>protected</code> -&gt; <code>private</code>;</li>
<li>函数体尽量短小, 紧凑, 功能单一;</li>
</ol>
<h2 id="函数">4. 函数</h2>
<h3 id="参数顺序">4.1. 参数顺序</h3>
<p><strong>总述</strong></p>
<p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p>
<p><strong>说明</strong></p>
<p>C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或 <code>const</code> 引用, 输出参数或输入/输出参数则一般为非 <code>const</code> 指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.</p>
<p>这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.</p>
<h3 id="编写简短函数">4.2. 编写简短函数</h3>
<p><strong>总述</strong></p>
<p>我们倾向于编写简短, 凝练的函数.</p>
<p><strong>说明</strong></p>
<p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
<p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.</p>
<p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p>
<h3 id="引用参数">4.3. 引用参数</h3>
<p><strong>总述</strong></p>
<p>所有按引用传递的参数必须加上 <code>const</code>.</p>
<p><strong>定义</strong></p>
<p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明为引用参数: <code>int foo(int &amp;val)</code>.</p>
<p><strong>优点</strong></p>
<p>定义引用参数可以防止出现 <code>(*pval)++</code> 这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针.</p>
<p><strong>缺点</strong></p>
<p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
<p><strong>结论</strong></p>
<p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">in</span>, <span class="built_in">string</span> *<span class="keyword">out</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code>const</code> 引用, 输出参数为指针. 输入参数可以是 <code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数, 除非特殊要求, 比如 <code>swap()</code>.</p>
<p>有时候, 在输入形参中用 <code>const T*</code> 指针比 <code>const T&amp;</code> 更明智. 比如:</p>
<ul>
<li>可能会传递空指针.</li>
<li>函数要把指针或对地址的引用赋值给输入形参.</li>
</ul>
<p>总而言之, 大多时候输入形参往往是 <code>const T&amp;</code>. 若用 <code>const T*</code> 则说明输入另有处理. 所以若要使用 <code>const T*</code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p>
<h3 id="函数重载">4.4. 函数重载</h3>
<p><strong>总述</strong></p>
<p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p>
<p><strong>定义</strong></p>
<p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数, 然后用另一个参数类型为 <code>const char*</code> 的函数对其进行重载:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *text, <span class="keyword">size_t</span> textlen)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<p>通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.</p>
<p><strong>缺点</strong></p>
<p>如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.</p>
<p><strong>结论</strong></p>
<p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等, 而不是一口气重载多个 <code>Append()</code>. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code>std::vector</code> 以便使用者可以用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##braced-initializer-list">列表初始化</a> 指定参数.</p>
<h3 id="缺省参数">4.5. 缺省参数</h3>
<p><strong>总述</strong></p>
<p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">函数重载</a> 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p>
<p><strong>优点</strong></p>
<p>有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”.</p>
<p><strong>缺点</strong></p>
<p>缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##function-overloading">不应当使用函数重载的理由</a> 也都适用于缺省参数.</p>
<p>虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p>
<p>缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值.</p>
<p>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题.</p>
<p><strong>结论</strong></p>
<p>对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 <code>void f(int n = counter++);</code> 这样的代码.)</p>
<p>在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p>
<h3 id="函数返回类型后置语法">4.6. 函数返回类型后置语法</h3>
<p><strong>总述</strong></p>
<p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p>
<p><strong>定义</strong></p>
<p>C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++11 引入了这一新的形式. 现在可以在函数名前使用 <code>auto</code> 关键字, 在参数列表之后后置返回类型. 例如:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span> foo(<span class="built_in">int</span> x) -&gt; <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure>
<p>后置返回类型为函数作用域. 对于像 <code>int</code> 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别.</p>
<p><strong>优点</strong></p>
<p>后置返回类型是显式地指定 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##lambda-expressions">Lambda 表达式</a> 的返回值的唯一方式. 某些情况下, 编译器可以自动推导出 Lambda 表达式的返回类型, 但并不是在所有的情况下都能实现. 即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了.</p>
<p>有时在已经出现了的函数参数列表之后指定返回类型, 能够让书写更简单, 也更易读, 尤其是在返回类型依赖于模板参数时. 例如:</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">auto</span> add(T t, U u) -&gt; decltype(t + u);</span><br></pre></td></tr></table></figure>
<p>对比下面的例子:</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">template</span> &lt;class <span class="type">T</span>, class <span class="type">U</span>&gt; decl<span class="keyword">type</span>(declval&lt;<span class="type">T</span>&amp;&gt;() + declval&lt;<span class="type">U</span>&amp;&gt;()) add(<span class="type">T</span> t, <span class="type">U</span> u);</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong></p>
<p>后置返回类型相对来说是非常新的语法, 而且在 C 和 Java 中都没有相似的写法, 因此可能对读者来说比较陌生.</p>
<p>在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍. 因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下, 只使用一种版本是相对来说更规整的形式.</p>
<p><strong>结论</strong></p>
<p>在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##template-metaprogramming">复杂的模板代码</a>.</p>
<h2 id="来自-google-的奇技">5. 来自 Google 的奇技</h2>
<p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.</p>
<h3 id="所有权与智能指针">5.1. 所有权与智能指针</h3>
<p>==总述==</p>
<p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p>
<p>==定义==</p>
<p>所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.</p>
<p>智能指针是一个通过重载 <code>*</code> 和 <code>-&gt;</code> 运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位. <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> 是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当 <code>std::unique_ptr</code> 离开作用域时, 对象就会被销毁. <code>std::unique_ptr</code> 不能被复制, 但可以把它移动（move）给新所有主. <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> 同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.</p>
<p>==优点==</p>
<ul>
<li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li>
<li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li>
<li>传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li>
<li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li>
<li>可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.</li>
<li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li>
</ul>
<p>==缺点==</p>
<ul>
<li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li>
<li>其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li>
<li>如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型.</li>
<li>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</li>
<li><code>std::unique_ptr</code> 的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员.</li>
<li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统.</li>
<li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li>
<li>某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁.</li>
<li>智能指针并不能够完全代替原生指针.</li>
</ul>
<p>==结论==</p>
<p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 <code>std::unique_ptr</code> 来明确所有权传递, 例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">FooFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FooConsumer</span><span class="params">(std::unique_ptr&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 <code>std::shared_ptr</code> ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 <code>std::shared_ptr</code> .</p>
<p>不要使用 <code>std::auto_ptr</code>, 使用 <code>std::unique_ptr</code> 代替它.</p>
<h3 id="cpplint">5.2. Cpplint</h3>
<p><strong>&gt; 总述</strong></p>
<p>使用 <code>cpplint.py</code> 检查风格错误.</p>
<p><strong>&gt; 说明</strong></p>
<p><code>cpplint.py</code> 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 <code>// NOLINT</code>, 或在上一行加 <code>// NOLINTNEXTLINE</code>, 可以忽略报错.</p>
<p>某些项目会指导你如何使用他们的项目工具运行 <code>cpplint.py</code>. 如果你参与的项目没有提供, 你可以单独下载 <a href="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p>
<h3 id="译者acgtyrant笔记-2">译者（acgtyrant）笔记</h3>
<ol type="1">
<li>把智能指针当成对象来看待的话, 就很好领会它与所指对象之间的关系了.</li>
<li>原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.</li>
<li><code>scoped_ptr</code> 和 <code>auto_ptr</code> 已过时. 现在是 <code>shared_ptr</code> 和 <code>uniqued_ptr</code> 的天下了.</li>
<li>按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.</li>
<li>Arch Linux 用户注意了, AUR 有对 cpplint 打包.</li>
</ol>
<h2 id="其他-c-特性">6. 其他 C++ 特性</h2>
<h3 id="引用参数-1">6.1. 引用参数</h3>
<p>==Tip==</p>
<p>所有按引用传递的参数必须加上 <code>const</code>.</p>
<p>==定义:==</p>
<blockquote>
<p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明引用参数: <code>int foo(int &amp;val)</code>.</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>定义引用参数防止出现 <code>(*pval)++</code> 这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 <code>NULL</code> 指针.</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>函数参数列表中, 所有引用参数都必须是 <code>const</code>:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> string &amp;in, string *out)</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code>const</code> 引用, 输出参数为指针. 输入参数可以是 <code>const</code> 指针, 但决不能是非 <code>const</code> 的引用参数，除非用于交换，比如 <code>swap()</code>.</p>
<p>有时候，在输入形参中用 <code>const T*</code> 指针比 <code>const T&amp;</code> 更明智。比如：</p>
<ul>
<li>您会传 null 指针。</li>
<li>函数要把指针或对地址的引用赋值给输入形参。</li>
</ul>
<p>总之大多时候输入形参往往是 <code>const T&amp;</code>. 若用 <code>const T*</code> 说明输入另有处理。所以若您要用 <code>const T*</code>, 则应有理有据，否则会害得读者误解。</p>
</blockquote>
<h3 id="右值引用">6.2. 右值引用</h3>
<p>==Tip==</p>
<p>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 <code>std::forward</code>.</p>
<p>==定义:==</p>
<blockquote>
<p>右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, <code>void f(string&amp;&amp; s)</code>; 声明了一个其参数是一个字符串的右值引用的函数.</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果 <code>v1</code> 是一个 <code>vector</code>, 则 <code>auto v2(std::move(v1))</code> 将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升.</p>
<p>右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能, 无论其参数是否是临时对象都能正常工作.</p>
<p>右值引用能实现可移动但不可拷贝的类型, 这一特性对那些在拷贝方面没有实际需求, 但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.</p>
<p>要高效率地使用某些标准库类型, 例如 <code>std::unique_ptr</code>, <code>std::move</code> 是必需的.</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 <code>std::forward</code> 功能函数. 你可能会使用 <code>std::move</code> 来表示将值从一个对象移动而不是复制到另一个对象.</p>
</blockquote>
<h3 id="函数重载-1">6.3. 函数重载</h3>
<p>==Tip==</p>
<p>若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p>
<p>==定义:==</p>
<blockquote>
<p>你可以编写一个参数类型为 <code>const string&amp;</code> 的函数, 然后用另一个参数类型为 <code>const char*</code> 的函数重载它:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *text, <span class="keyword">size_t</span> textlen)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利.</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>如果函数单单靠不同的参数类型而重载（acgtyrant 注：这意味着参数数量不变），读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等， 而不是一口气重载多个 <code>Append()</code>.</p>
</blockquote>
<h3 id="缺省参数-1">6.4. 缺省参数</h3>
<p>==Tip==</p>
<p>我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p>
<p>==优点:==</p>
<blockquote>
<p>当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复（acgtyrant 注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数（acgtyrant 注：即不能再通过缺省参数来省略参数了）。</p>
<p>其一，位于 <code>.cc</code> 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</p>
<p>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</p>
<p>其三，可以用来模拟变长数组。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过空 AlphaNum 以支持四个形参</span></span><br><span class="line"><span class="function">string <span class="title">StrCat</span><span class="params">(<span class="keyword">const</span> AlphaNum &amp;a,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">const</span> AlphaNum &amp;b = gEmptyAlphaNum,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">const</span> AlphaNum &amp;c = gEmptyAlphaNum,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">const</span> AlphaNum &amp;d = gEmptyAlphaNum)</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="变长数组和-alloca">6.5. 变长数组和 alloca()</h3>
<p>==Tip==</p>
<p>我们不允许使用变长数组和 <code>alloca()</code>.</p>
<p>==优点:==</p>
<blockquote>
<p>变长数组具有浑然天成的语法. 变长数组和 <code>alloca()</code> 也都很高效.</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>变长数组和 <code>alloca()</code> 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>改用更安全的分配器（allocator），就像 <code>std::vector</code> 或 <code>std::unique_ptr</code>.</p>
</blockquote>
<h3 id="友元">6.6. 友元</h3>
<p>==Tip==</p>
<p>我们允许合理的使用友元类及友元函数.</p>
<p>通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 <code>FooBuilder</code> 声明为 <code>Foo</code> 的友元, 以便 <code>FooBuilder</code> 正确构造 <code>Foo</code> 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.</p>
<p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 <code>public</code>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p>
<h3 id="异常">6.7. 异常</h3>
<p>==Tip==</p>
<p>我们不使用 C++ 异常.</p>
<p>==优点:==</p>
<blockquote>
<ul>
<li>异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant 注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。</li>
<li>很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类 C++ 的语言更一脉相承。</li>
<li>有些第三方 C++ 库依赖异常，禁用异常就不好用了。</li>
<li>异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant 注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或 <code>Init()</code> 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态。</li>
<li>在测试框架里很好用。</li>
</ul>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<ul>
<li>在现有函数中添加 <code>throw</code> 语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，<code>f()</code> 调用 <code>g()</code>, <code>g()</code> 又调用 <code>h()</code>, 且 <code>h</code> 抛出的异常被 <code>f</code> 捕获。当心 <code>g</code>, 否则会没妥善清理好。</li>
<li>还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。</li>
<li>异常安全需要RAII和不同的编码实践. 要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说, 为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交” 状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得.</li>
<li>启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。</li>
<li>滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。</li>
</ul>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p>
<p>鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.</p>
<p>我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p>
<p>对于 Windows 代码来说, 有个 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/exceptions/##windows-code">特例</a>.</p>
</blockquote>
<p>(YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的, 以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理, Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定)</p>
<h3 id="运行时类型识别">6.8. 运行时类型识别</h3>
<p>==Tip==</p>
<p>我们禁止使用 RTTI.</p>
<p>==定义:==</p>
<blockquote>
<p>RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 <code>typeid</code> 或者 <code>dynamic_cast</code> 完成.</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中.</p>
<p>RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用.</p>
<p>在考虑多个抽象对象时 RTTI 也很好用. 例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Base::Equal</span><span class="params">(Base* other)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Derived::Equal</span><span class="params">(Base* other)</span> </span>&#123;</span><br><span class="line">  Derived* that = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(other);</span><br><span class="line">  <span class="keyword">if</span> (that == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</p>
<p>随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:</p>
<p>虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.</p>
<p>如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行类型判断.</p>
<p>如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在这种情况下, 使用 dynamic_cast 也是一种替代方案.</p>
<p>基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in"><span class="keyword">typeid</span></span>(*data) == <span class="built_in"><span class="keyword">typeid</span></span>(D1)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in"><span class="keyword">typeid</span></span>(*data) == <span class="built_in"><span class="keyword">typeid</span></span>(D2)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in"><span class="keyword">typeid</span></span>(*data) == <span class="built_in"><span class="keyword">typeid</span></span>(D3)) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p>
<p>不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图.</p>
</blockquote>
<h3 id="类型转换">6.9. 类型转换</h3>
<p>==Tip==</p>
<p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用 <code>int y = (int)x</code> 或 <code>int y = int(x)</code> 等转换方式;</p>
<p>==定义:==</p>
<blockquote>
<p>C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 <code>(int)3.5</code>), 有时是在做类型转换 (如 <code>(int)"hello"</code>). 另外, C++ 的类型转换在查找时更醒目.</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>恶心的语法.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p>
<blockquote>
<ul>
<li>用 <code>static_cast</code> 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</li>
<li>用 <code>const_cast</code> 去掉 <code>const</code> 限定符.</li>
<li>用 <code>reinterpret_cast</code> 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</li>
</ul>
</blockquote>
<p>至于 <code>dynamic_cast</code> 参见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##rtti">6.8. 运行时类型识别</a>.</p>
</blockquote>
<h3 id="流">6.10. 流</h3>
<p>==Tip==</p>
<p>只在记录日志时使用流.</p>
<p>==定义:==</p>
<blockquote>
<p>流用来替代 <code>printf()</code> 和 <code>scanf()</code>.</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 <code>printf</code> 也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>流使得 <code>pread()</code> 等功能函数很难执行. 如果不使用 <code>printf</code> 风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 <code>%.*s</code>) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code> 之类的代替.</p>
<p>使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p>
</blockquote>
<p>==拓展讨论:==</p>
<blockquote>
<p>对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是 <code>printf + read/write</code>. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p>
<p>流的支持者们主张流是不二之选, 但观点并不是那么清晰有力. 他们指出的流的每个优势也都是其劣势. 流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警. 使用流时容易造成的这类错误:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="keyword">this</span>;   <span class="comment">// 输出地址</span></span><br><span class="line">cout &lt;&lt; *<span class="keyword">this</span>;  <span class="comment">// 输出值</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>由于 <code>&lt;&lt;</code> 被重载, 编译器不会报错. 就因为这一点我们反对使用操作符重载.</p>
<p>有人说 <code>printf</code> 的格式化丑陋不堪, 易读性差, 但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</p>
<blockquote>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">cerr &lt;&lt; <span class="string">&quot;Error connecting to &#x27;&quot;</span> &lt;&lt; foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.first</span><br><span class="line">     &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.second &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; strerror(errno);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, <span class="string">&quot;Error connecting to &#x27;%s:%u: %s&quot;</span>,</span><br><span class="line">        foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.first, foo-&gt;bar<span class="function"><span class="params">()</span>-&gt;</span>hostname.second,</span><br><span class="line">        strerror(errno));</span><br></pre></td></tr></table></figure>
</blockquote>
<p>你可能会说, “把流封装一下就会比较好了”, 这儿可以, 其他地方呢? 而且不要忘了, 我们的目标是使语言更紧凑, 而不是添加一些别人需要学习的新装备.</p>
<p>每一种方式都是各有利弊, “没有最好, 只有更适合”. 简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 <code>printf + read/write</code>.</p>
</blockquote>
<h3 id="前置自增和自减">6.11. 前置自增和自减</h3>
<p>==Tip==</p>
<p>对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</p>
<p>==定义:==</p>
<blockquote>
<p>对于变量在自增 (<code>++i</code> 或 <code>i++</code>) 或自减 (<code>--i</code> 或 <code>i--</code>) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>不考虑返回值的话, 前置自增 (<code>++i</code>) 通常要比后置自增 (<code>i++</code>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 <code>i</code> 进行一次拷贝. 如果 <code>i</code> 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 <code>for</code> 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (<code>i</code>) 在谓语动词 (<code>++</code>) 前.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</p>
</blockquote>
<h3 id="const-用法">6.12. <code>const</code> 用法</h3>
<p>==Tip==</p>
<p>我们强烈建议你在任何可能的情况下都要使用 <code>const</code>. 此外有时改用 C++11 推出的 constexpr 更好。</p>
<p>==定义:==</p>
<blockquote>
<p>在声明的变量或参数前加上关键字 <code>const</code> 用于指明变量值不可被篡改 (如 <code>const int foo</code> ). 为类中的函数加上 <code>const</code> 限定符表明该函数不会修改类成员变量的状态 (如 <code>class Foo &#123; int Bar(char c) const; &#125;;</code>).</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p><code>const</code> 是入侵性的: 如果你向一个函数传入 <code>const</code> 变量, 函数原型声明中也必须对应 <code>const</code> 参数 (否则变量需要 <code>const_cast</code> 类型转换), 在调用库函数时显得尤其麻烦.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p><code>const</code> 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 <code>const</code>:</p>
<blockquote>
<ul>
<li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 <code>const</code>.</li>
<li>尽可能将函数声明为 <code>const</code>. 访问函数应该总是 <code>const</code>. 其他不会修改任何数据成员, 未调用非 <code>const</code> 函数, 不会返回数据成员非 <code>const</code> 指针或引用的函数也应该声明成 <code>const</code>.</li>
<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <code>const</code>.</li>
</ul>
</blockquote>
<p>然而, 也不要发了疯似的使用 <code>const</code>. 像 <code>const int * const * const x;</code> 就有些过了, 虽然它非常精确的描述了常量 <code>x</code>. 关注真正有帮助意义的信息: 前面的例子写成 <code>const int** x</code> 就够了.</p>
<p>关键字 <code>mutable</code> 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.</p>
</blockquote>
<p><code>const</code> 的位置:</p>
<blockquote>
<p>有人喜欢 <code>int const *foo</code> 形式, 不喜欢 <code>const int* foo</code>, 他们认为前者更一致因此可读性也更好: 遵循了 <code>const</code> 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消大部分你原本想保持的一致性. 将 <code>const</code> 放在前面才更易读, 因为在自然语言中形容词 (<code>const</code>) 是在名词 (<code>int</code>) 之前.</p>
<p>这是说, 我们提倡但不强制 <code>const</code> 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把 <code>const</code> 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)</p>
</blockquote>
<h3 id="constexpr-用法">6.13. <code>constexpr</code> 用法</h3>
<p>==Tip==</p>
<p>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>
<p>==定义:==</p>
<blockquote>
<p>变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量。</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>如今 constexpr 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>若过早把变量优化成 constexpr 变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。 千万别痴心妄想地想靠 constexpr 来强制代码「内联」。</p>
</blockquote>
<h3 id="整型">6.14. 整型</h3>
<p>==Tip==</p>
<p>C++ 内建整型中, 仅使用 <code>int</code>. 如果程序中需要不同大小的变量, 可以使用 `<code>中长度精确的整型, 如</code>int16_t<code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如</code>int64_t`. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。</p>
<p>==定义:==</p>
<blockquote>
<p>C++ 没有指定整型的大小. 通常人们假定 <code>short</code> 是 16 位, <code>int</code> 是 32 位, <code>long</code> 是 32 位, <code>long long</code> 是 64 位.</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>保持声明统一.</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>C++ 中整型大小因编译器和体系结构的不同而不同.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>`<code>定义了</code>int16_t<code>,</code>uint32_t<code>,</code>int64_t<code>等整型, 在需要确保整型大小时可以使用它们代替</code>short<code>,</code>unsigned long long<code>等. 在 C 整型中, 只使用</code>int<code>. 在合适的情况下, 推荐使用标准类型如</code>size_t<code>和</code>ptrdiff_t`.</p>
<p>如果已知整数不会太大, 我们常常会使用 <code>int</code>, 如循环计数. 在类似的情况下使用原生类型 <code>int</code>. 你可以认为 <code>int</code> 至少为 32 位, 但不要认为它会多于 <code>32</code> 位. 如果需要 64 位整型, 用 <code>int64_t</code> 或 <code>uint64_t</code>.</p>
<p>对于大整数, 使用 <code>int64_t</code>.</p>
<p>不要使用 <code>uint32_t</code> 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p>
<p>如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。</p>
<p>小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 <code>int</code> 与 <code>unsigned int</code> 运算时，前者被提升为 <code>unsigned int</code> 而有可能溢出），总有意想不到的后果。</p>
</blockquote>
<p>关于无符号整数:</p>
<blockquote>
<p>有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:</p>
<blockquote>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">for <span class="params">(unsigned int <span class="attr">i</span> = foo.Length()</span>-1; i &gt;= 0; <span class="params">--i</span>) <span class="string">...</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p>
<p>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p>
</blockquote>
<h3 id="位下的可移植性">6.15. 64 位下的可移植性</h3>
<p>==Tip==</p>
<p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:</p>
<ul>
<li><p>对于某些类型, <code>printf()</code> 的指示符在 32 位和 64 位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 <code>inttypes.h</code> 仿标准风格):</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// printf macros for size_t, in the style of inttypes.h</span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> __PRIS_PREFIX <span class="meta-string">&quot;z&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> __PRIS_PREFIX</span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use these macros after a % in a printf format string</span></span><br><span class="line"><span class="comment">// to get correct 32/64 bit behavior, like this:</span></span><br><span class="line"><span class="comment">// size_t size = records.size();</span></span><br><span class="line"><span class="comment">// printf(&quot;%&quot;PRIuS&quot;\n&quot;, size);</span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> PRIdS __PRIS_PREFIX <span class="meta-string">&quot;d&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> PRIxS __PRIS_PREFIX <span class="meta-string">&quot;x&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> PRIuS __PRIS_PREFIX <span class="meta-string">&quot;u&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> PRIXS __PRIS_PREFIX <span class="meta-string">&quot;X&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> PRIoS __PRIS_PREFIX <span class="meta-string">&quot;o&quot;</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>不要使用</th>
<th>使用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>void *</code> (或其他指针类型)</td>
<td><code>%lx</code></td>
<td><code>%p</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>int64_t</code></td>
<td><code>%qd, %lld</code></td>
<td><code>%"PRId64"</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>uint64_t</code></td>
<td><code>%qu, %llu, %llx</code></td>
<td><code>%"PRIu64", %"PRIx64"</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>size_t</code></td>
<td><code>%u</code></td>
<td><code>%"PRIuS", %"PRIxS"</code></td>
<td>C99 规定 <code>%zu</code></td>
</tr>
<tr class="odd">
<td><code>ptrdiff_t</code></td>
<td><code>%d</code></td>
<td><code>%"PRIdS"</code></td>
<td>C99 规定 <code>%zd</code></td>
</tr>
</tbody>
</table>
<p>注意 <code>PRI*</code> 宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用 <code>PRI*</code> 宏同样可以在 <code>%</code> 后包含长度指示符. 例如, <code>printf("x = %30"PRIuS"\n", x)</code> 在 32 位 Linux 上将被展开为 <code>printf("x = %30" "u" "\n", x)</code>, 编译器当成 <code>printf("x = %30u\n", x)</code> 处理 (Yang.Y 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p>
</blockquote></li>
<li><p>记住 <code>sizeof(void *) != sizeof(int)</code>. 如果需要一个指针大小的整数要用 <code>intptr_t</code>.</p></li>
<li><p>你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 <code>int64_t</code>/<code>uint64_t</code> 成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 <code>__attribute__((packed))</code>. MSVC 则提供了 <code>##pragma pack()</code> 和 <code>__declspec(align())</code> (YuleFox 注, 解决方案的项目属性里也可以直接设置).</p></li>
<li><p>创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> my_value = <span class="number">0x123456789</span>LL;</span><br><span class="line"><span class="keyword">uint64_t</span> my_mask = <span class="number">3ULL</span> &lt;&lt; <span class="number">48</span>;</span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 <code>##ifdef _LP64</code> 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化)</p></li>
</ul>
<h3 id="预处理宏">6.16. 预处理宏</h3>
<p>==Tip==</p>
<p>使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p>
<p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.</p>
<p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被 <code>const</code> 变量代替. 用宏 “缩写” 长变量名可被引用代替. 用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦 (<code>##define</code> 防止头文件重包含当然是个特例).</p>
<p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 <code>##</code> 字符串化, 用 <code>###</code> 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p>
<p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:</p>
<blockquote>
<ul>
<li>不要在 <code>.h</code> 文件中定义宏.</li>
<li>在马上要使用时才进行 <code>##define</code>, 使用后要立即 <code>##undef</code>.</li>
<li>不要只是对已经存在的宏使用##undef，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>
<li>不要用 <code>###</code> 处理函数，类和变量的名字。</li>
</ul>
</blockquote>
<h3 id="nullptr-和-null">6.17. 0, <code>nullptr</code> 和 <code>NULL</code></h3>
<p>==Tip==</p>
<p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>'\0'</code>.</p>
<p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 这一点是毫无争议的.</p>
<p>对于指针 (地址值), 到底是用 <code>0</code>, <code>NULL</code> 还是 <code>nullptr</code>. C++11 项目用 <code>nullptr</code>; C++03 项目则用 <code>NULL</code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 <code>NULL</code> 的定义比较特殊，可以输出有用的警告，特别是 <code>sizeof(NULL)</code> 就和 <code>sizeof(0)</code> 不一样。</p>
<p>字符 (串) 用 <code>'\0'</code>, 不仅类型正确而且可读性好.</p>
<h3 id="sizeof">6.18. sizeof</h3>
<p>==Tip==</p>
<p>尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</p>
<p>使用 <code>sizeof(varname)</code> 是因为当代码中变量类型改变时会自动更新. 您或许会用 <code>sizeof(type)</code> 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Struct data;</span><br><span class="line">Struct data; <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(data));</span><br></pre></td></tr></table></figure>
<p>==Warning==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Struct));</span><br><span class="line"><span class="keyword">if</span> (raw_size &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)) &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;compressed record not big enough for count: &quot;</span> &lt;&lt; raw_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="auto">6.19. auto</h3>
<p>==Tip==</p>
<p>用 <code>auto</code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>
<p>==定义：==</p>
<blockquote>
<p>C++11 中，若变量被声明成 <code>auto</code>, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用 <code>auto</code> 来复制初始化或绑定引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>];  <span class="comment">// 创建一份 v[0] 的拷贝。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>];  <span class="comment">// s2 是 v[0] 的一个引用。</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>==优点：==</p>
<blockquote>
<p>C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sparse_hash_map&lt;string, <span class="keyword">int</span>&gt;::iterator iter = m.<span class="built_in">find</span>(val);</span><br></pre></td></tr></table></figure>
<p>返回类型好难读，代码目的也不够一目了然。重构其：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br></pre></td></tr></table></figure>
<p>好多了。</p>
<p>没有 <code>auto</code> 的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p>
</blockquote>
<p>==缺点：==</p>
<blockquote>
<p>类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = x.<span class="built_in">Lookup</span>(key);</span><br></pre></td></tr></table></figure>
<p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p>
<p>程序员必须会区分 <code>auto</code> 和 <code>const auto&amp;</code> 的不同之处，否则会复制错东西。</p>
<p>auto 和 C++11 列表初始化的合体令人摸不着头脑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 圆括号。</span></span><br><span class="line"><span class="keyword">auto</span> y&#123;<span class="number">3</span>&#125;;  <span class="comment">// 大括号。</span></span><br></pre></td></tr></table></figure>
<p>它们不是同一回事——<code>x</code> 是 <code>int</code>, <code>y</code> 则是 <code>std::initializer_list</code>. 其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types, 它涉及到 C++ 鲜为人知的坑：<a href="http://stackoverflow.com/a/17794965/1546088">Why is vector not a STL container?</a>）也有大同小异的陷阱。</p>
<p>如果在接口里用 <code>auto</code>, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。</p>
</blockquote>
<p>结论：</p>
<blockquote>
<p><code>auto</code> 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 <code>auto</code> 变量。</p>
<p><code>auto</code> 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。</p>
</blockquote>
<h3 id="列表初始化">6.20. 列表初始化</h3>
<p>==Tip==</p>
<p>你可以用列表初始化。</p>
<p>早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="keyword">int</span> x; <span class="keyword">int</span> y; &#125;;</span><br><span class="line">Point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector 接收了一个初始化列表。</span></span><br><span class="line">vector&lt;string&gt; v&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不考虑细节上的微妙差别，大致上相同。</span></span><br><span class="line"><span class="comment">// 您可以任选其一。</span></span><br><span class="line">vector&lt;string&gt; v = &#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以配合 new 一起用。</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> vector&lt;string&gt;&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 接收了一些 pair, 列表初始化大显神威。</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表也可以用在返回类型上的隐式转换。</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">test_function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表可迭代。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用里用列表初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFunction2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">TestFunction2</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>用户自定义类型也可以定义接收 <code>std::initializer_list</code> 的构造函数和赋值运算符，以自动列表初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// std::initializer_list 专门接收 init 列表。</span></span><br><span class="line">  <span class="comment">// 得以值传递。</span></span><br><span class="line">  <span class="built_in">MyType</span>(std::initializer_list&lt;<span class="keyword">int</span>&gt; init_list) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : init_list) <span class="built_in">append</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  MyType&amp; <span class="keyword">operator</span>=(std::initializer_list&lt;<span class="keyword">int</span>&gt; init_list) &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : init_list) <span class="built_in">append</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyType m&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收 <code>std::initializer_list</code> 的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123;<span class="number">1.23</span>&#125;;</span><br><span class="line"><span class="comment">// MyOtherType 没有 std::initializer_list 构造函数，</span></span><br><span class="line"> <span class="comment">// 直接上接收常规类型的构造函数。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherType</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyOtherType</span><span class="params">(string)</span></span>;</span><br><span class="line">  <span class="built_in">MyOtherType</span>(<span class="keyword">int</span>, string);</span><br><span class="line">&#125;;</span><br><span class="line">MyOtherType m = &#123;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。</span></span><br><span class="line">MyOtherType m&#123;<span class="string">&quot;b&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂：</p>
<p>==Warning==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;;        <span class="comment">// d 即是 std::initializer_list&lt;double&gt;</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="keyword">double</span>&#123;<span class="number">1.23</span>&#125;;  <span class="comment">// 善哉 -- d 即为 double, 并非 std::initializer_list.</span></span><br></pre></td></tr></table></figure>
<p>至于格式化，参见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##braced-initializer-list-format">9.7. 列表初始化格式</a>.</p>
<h3 id="lambda-表达式">6.21. Lambda 表达式</h3>
<p>==Tip==</p>
<p>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p>
<p>==定义：==</p>
<blockquote>
<p>Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Weight</span>(x) &lt; <span class="built_in">Weight</span>(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>C++11 首次提出 Lambdas, 还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper） <code>std::function</code>.</p>
</blockquote>
<p>==优点：==</p>
<blockquote>
<ul>
<li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li>
<li>Lambdas, <code>std::functions</code> 和 <code>std::bind</code> 可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。</li>
</ul>
</blockquote>
<p>==缺点：==</p>
<blockquote>
<ul>
<li>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</li>
<li>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</li>
</ul>
</blockquote>
<p>==结论：==</p>
<blockquote>
<ul>
<li>按 format 小用 lambda 表达式怡情。</li>
<li>禁用默认捕获，捕获都要显式写出来。打比方，比起 <code>[=](int x) &#123;return x + n;&#125;</code>, 您该写成 <code>[n](int x) &#123;return x + n;&#125;</code> 才对，这样读者也好一眼看出 <code>n</code> 是被捕获的值。</li>
<li>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。</li>
<li>如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.</li>
</ul>
</blockquote>
<h3 id="模板编程">6.22. 模板编程</h3>
<p>==Tip==</p>
<p>不要使用复杂的模板编程</p>
<p>==定义:==</p>
<blockquote>
<p>模板编程指的是利用c++ 模板实例化机制是图灵完备性, 可以被用来实现编译时刻的类型判断的一系列编程技巧</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>模板编程能够实现非常灵活的类型安全的接口和极好的性能, 一些常见的工具比如Google Test, std::tuple, std::function 和 Boost.Spirit. 这些工具如果没有模板是实现不了的</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<ul>
<li>模板编程所使用的技巧对于使用c++不是很熟练的人是比较晦涩, 难懂的. 在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和 维护起来都很麻烦</li>
<li>模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候, 即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示. 导致这个编译出错信息看起来非常难以理解.</li>
<li>大量的使用模板编程接口会让重构工具(Visual Assist X, Refactor for C++等等)更难发挥用途. 首先模板的代码会在很多上下文里面扩展开来, 所以很难确认重构对所有的这些展开的代码有用, 其次有些重构工具只对已经做过模板类型替换的代码的AST 有用. 因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构.</li>
</ul>
</blockquote>
<p>==结论:==</p>
<blockquote>
<ul>
<li>模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此模板编程最好只用在少量的基础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉</li>
<li>在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非c++ 程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程. 如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板, 或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载, 那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用</li>
<li>如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴漏. 你最好只在实现里面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性. 并且你应该在这些使用模板的代码上写尽可能详细的注释. 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代码大概是什么样子的. 还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为这些出错信息也是你的接口的一部分, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解, 并且用户很容易知道如何修改这些错误</li>
</ul>
</blockquote>
<h3 id="boost-库">6.23. Boost 库</h3>
<p>==Tip==</p>
<p>只使用 Boost 中被认可的库.</p>
<p>==定义:==</p>
<blockquote>
<p><a href="http://www.boost.org/">Boost 库集</a> 是一个广受欢迎, 经过同行鉴定, 免费开源的 C++ 库集.</p>
</blockquote>
<p>==优点:==</p>
<blockquote>
<p>Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针。</p>
</blockquote>
<p>==缺点:==</p>
<blockquote>
<p>某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术, 以及过度 “函数化” 的编程风格.</p>
</blockquote>
<p>==结论:==</p>
<blockquote>
<p>为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前允许使用以下库:</p>
<blockquote>
<ul>
<li><a href="http://www.boost.org/doc/libs/1_58_0/libs/utility/call_traits.htm">Call Traits</a> : <code>boost/call_traits.hpp</code></li>
<li><a href="http://www.boost.org/libs/utility/compressed_pair.htm">Compressed Pair</a> : <code>boost/compressed_pair.hpp</code></li>
<li>[ : <code>boost/graph</code>, except serialization (<code>adj_list_serialize.hpp</code>) and parallel/distributed algorithms and data structures(<code>boost/graph/parallel/*</code> and <code>boost/graph/distributed/*</code>)</li>
<li><a href="http://www.boost.org/libs/property_map/">Property Map</a> : <code>boost/property_map.hpp</code></li>
<li>The part of <a href="http://www.boost.org/libs/iterator/">Iterator</a> that deals with defining iterators: <code>boost/iterator/iterator_adaptor.hpp</code>, <code>boost/iterator/iterator_facade.hpp</code>, and <code>boost/function_output_iterator.hpp</code></li>
<li>The part of <a href="http://www.boost.org/libs/polygon/">Polygon</a> that deals with Voronoi diagram construction and doesn’t depend on the rest of Polygon: <code>boost/polygon/voronoi_builder.hpp</code>, <code>boost/polygon/voronoi_diagram.hpp</code>, and <code>boost/polygon/voronoi_geometry_type.hpp</code></li>
<li><a href="http://www.boost.org/libs/bimap/">Bimap</a> : <code>boost/bimap</code></li>
<li><a href="http://www.boost.org/libs/math/doc/html/dist.html">Statistical Distributions and Functions</a> : <code>boost/math/distributions</code></li>
<li><a href="http://www.boost.org/libs/multi_index/">Multi-index</a> : <code>boost/multi_index</code></li>
<li><a href="http://www.boost.org/libs/heap/">Heap</a> : <code>boost/heap</code></li>
<li>The flat containers from <a href="http://www.boost.org/libs/container/">Container</a>: <code>boost/container/flat_map</code>, and <code>boost/container/flat_set</code></li>
</ul>
</blockquote>
<p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p>
<p>以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：</p>
<blockquote>
<ul>
<li><a href="http://www.boost.org/libs/ptr_container/">Pointer Container</a> : <code>boost/ptr_container</code>, 改用 <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a></li>
<li><a href="http://www.boost.org/libs/array/">Array</a> : <code>boost/array.hpp</code>, 改用 <a href="http://en.cppreference.com/w/cpp/container/array">std::array</a></li>
</ul>
</blockquote>
</blockquote>
<h3 id="c11">6.24. C++11</h3>
<p>==Tip==</p>
<p>适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。</p>
<p>==定义：==</p>
<blockquote>
<p>C++11 有众多语言和库上的<code>变革 &lt;https://en.wikipedia.org/wiki/C%2B%2B11&gt;</code>_ 。</p>
</blockquote>
<p>==优点：==</p>
<blockquote>
<p>在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++ 编译器支持。它标准化很多我们早先就在用的 C++ 扩展，简化了不少操作，大大改善了性能和安全。</p>
</blockquote>
<p>==缺点：==</p>
<blockquote>
<p>C++11 相对于前身，复杂极了：1300 页 vs 800 页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。</p>
<p>和 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##boost">6.23. Boost 库</a> 一样，有些 C++11 扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。</p>
</blockquote>
<p>==缺点：==</p>
<blockquote>
<p>C++11 特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11 特性之外，以下特性最好不要用：</p>
<ul>
<li>尾置返回类型，比如用 <code>auto foo() -&gt; int</code> 代替 <code>int foo()</code>. 为了兼容于现有代码的声明风格。</li>
<li>编译时合数 ``, 因为它涉及一个重模板的接口风格。</li>
<li><code>和</code> 头文件，因为编译器尚不支持。</li>
<li>默认 lambda 捕获。</li>
</ul>
</blockquote>
<h3 id="译者acgtyrant笔记-3">译者（acgtyrant）笔记</h3>
<ol type="1">
<li>实际上，<a href="http://www.zhihu.com/question/24439516/answer/27858964">缺省参数会改变函数签名的前提是改变了它接收的参数数量</a>，比如把 <code>void a()</code> 改成 <code>void a(int b = 0)</code>, 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li>
<li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li>
<li>我还发现 <a href="http://www.zhihu.com/question/24439516/answer/27896004">滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。</a></li>
<li><code>friend</code> 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 <code>.cc</code> 文件加以定义。</li>
<li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li>
<li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##declaration-order">声明顺序</a> 。</li>
<li><a href="http://www.zhihu.com/question/22889420">对使用 C++ 异常处理应具有怎样的态度？</a> 非常值得一读。</li>
<li>注意初始化 const 对象时，必须在初始化的同时值初始化。</li>
<li>用断言代替无符号整型类型，深有启发。</li>
<li>auto 在涉及迭代器的循环语句里挺常用。</li>
<li><a href="http://stackoverflow.com/questions/11215227/should-the-trailing-return-type-syntax-style-become-the-default-for-new-c11-pr">Should the trailing return type syntax style become the default for new C++11 programs?</a> 讨论了 auto 与尾置返回类型一起用的全新编码风格，值得一看。</li>
</ol>
<h2 id="命名约定">7. 命名约定</h2>
<p>最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.</p>
<h3 id="通用命名规则">7.1. 通用命名规则</h3>
<p><strong>总述</strong></p>
<p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p>
<p><strong>说明</strong></p>
<p>尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="keyword">int</span> num_errors;            <span class="comment">// &quot;num&quot; 是一个常见的写法</span></span><br><span class="line"><span class="keyword">int</span> num_dns_connections;   <span class="comment">// 人人都知道 &quot;DNS&quot; 是什么</span></span><br><span class="line"><span class="keyword">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="keyword">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="keyword">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="keyword">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="keyword">int</span> pc_reader;             <span class="comment">// &quot;pc&quot; 有太多可能的解释了.</span></span><br><span class="line"><span class="keyword">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></table></figure>
<p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code>i</code> 表示迭代变量和用 <code>T</code> 表示模板参数.</p>
<p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##type-names">类型命名</a> 的规则, 而非类型模板应当遵循 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##variable-names">变量命名</a> 的规则.</p>
<h3 id="文件命名">7.2. 文件命名</h3>
<p><strong>总述</strong></p>
<p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p>
<p><strong>说明</strong></p>
<p>可接受的文件命名示例:</p>
<ul>
<li><code>my_useful_class.cc</code></li>
<li><code>my-useful-class.cc</code></li>
<li><code>myusefulclass.cc</code></li>
<li><code>myusefulclass_test.cc</code> // <code>_unittest</code> 和 <code>_regtest</code> 已弃用.</li>
</ul>
<p>C++ 文件要以 <code>.cc</code> 结尾, 头文件以 <code>.h</code> 结尾. 专门插入文本的文件则以 <code>.inc</code> 结尾, 参见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##self-contained-headers">头文件自足</a>.</p>
<p>不要使用已经存在于 <code>/usr/include</code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 <code>db.h</code>.</p>
<p>通常应尽量让文件名更加明确. <code>http_server_logs.h</code> 就比 <code>logs.h</code> 要好. 定义类时文件名一般成对出现, 如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类 <code>FooBar</code>.</p>
<p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短, 就直接放在 <code>.h</code> 中.</p>
<h3 id="类型命名">7.3. 类型命名</h3>
<p><strong>总述</strong></p>
<p>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p>
<p><strong>说明</strong></p>
<p>所有类型命名 —— 类, 结构体, 类型定义 (<code>typedef</code>), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTable</span> &#123;</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTableTester</span> &#123;</span> ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UrlTableErrors</span> &#123;</span> ...</span><br></pre></td></tr></table></figure>
<h3 id="变量命名">7.4. 变量命名</h3>
<p><strong>总述</strong></p>
<p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>.</p>
<p><strong>说明</strong></p>
<h6 id="普通变量命名">普通变量命名</h6>
<p>举例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line">string tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line"></span><br><span class="line">string tableName;  <span class="comment">// 差 - 混合大小写</span></span><br></pre></td></tr></table></figure>
<h6 id="类数据成员">类数据成员</h6>
<p>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableInfo</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  string tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="结构体变量">结构体变量</h6>
<p>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span></span><br><span class="line">  string name;</span><br><span class="line">  <span class="keyword">int</span> num_entries;</span><br><span class="line">  <span class="keyword">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体与类的使用讨论, 参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##structs-vs-classes">结构体 vs. 类</a>.</p>
<h3 id="常量命名">7.5. 常量命名</h3>
<p><strong>总述</strong></p>
<p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 <a href="http://en.cppreference.com/w/cpp/language/storage_duration##Storage_duration">存储类型</a>) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p>
<h3 id="函数命名">7.6. 函数命名</h3>
<p><strong>总述</strong></p>
<p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>.</p>
<p><strong>说明</strong></p>
<p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AddTableEntry</span>()</span><br><span class="line"><span class="built_in">DeleteUrl</span>()</span><br><span class="line"><span class="built_in">OpenFileOrDie</span>()</span><br></pre></td></tr></table></figure>
<p>(同样的命名规则同时适用于类作用域与命名空间作用域的常量, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.)</p>
<p>取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如 <code>int count()</code> 与 <code>void set_count(int count)</code>.</p>
<h3 id="命名空间命名">7.7. 命名空间命名</h3>
<p><strong>总述</strong></p>
<p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p>
<p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p>
<p>注意 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##general-naming-rules">不使用缩写作为名称</a> 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.</p>
<p>要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 <code>std</code> 命名空间. 建议使用更独特的项目标识符 (<code>websearch::index</code>, <code>websearch::index_util</code>) 而非常见的极易发生冲突的名称 (比如 <code>websearch::util</code>).</p>
<p>对于 <code>internal</code> 命名空间, 要当心加入到同一 <code>internal</code> 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 <code>frobber.h</code>, 使用 <code>websearch::index::frobber_internal</code>).</p>
<h3 id="枚举命名">7.8. 枚举命名</h3>
<p><strong>总述</strong></p>
<p>枚举的命名应当和 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量</a> 或 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a> 一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>.</p>
<p><strong>说明</strong></p>
<p>单独的枚举值应该优先采用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##constant-names">常量</a> 的命名方式. 但 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a> 方式的命名也可以接受. 枚举名 <code>UrlTableErrors</code> (以及 <code>AlternateUrlTableErrors</code>) 是类型, 所以要用大小写混合的方式.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UrlTableErrors</span> &#123;</span></span><br><span class="line">    kOK = <span class="number">0</span>,</span><br><span class="line">    kErrorOutOfMemory,</span><br><span class="line">    kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AlternateUrlTableErrors</span> &#123;</span></span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">    MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2009 年 1 月之前, 我们一直建议采用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/##macro-names">宏</a> 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
<h3 id="宏命名">7.9. 宏命名</h3>
<p><strong>总述</strong></p>
<p>你并不打算 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##preprocessor-macros">使用宏</a>, 对吧? 如果你一定要用, 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p>
<p><strong>说明</strong></p>
<p>参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##preprocessor-macros">预处理宏</a>; 通常 <em>不应该</em> 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(x) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_ROUNDED 3.0</span></span><br></pre></td></tr></table></figure>
<h3 id="命名规则的特例">7.10. 命名规则的特例</h3>
<p><strong>总述</strong></p>
<p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
<p><code>bigopen()</code>: 函数名, 参照 <code>open()</code> 的形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint`: `<span class="keyword">typedef</span></span><br></pre></td></tr></table></figure>
<p><code>bigpos</code>: <code>struct</code> 或 <code>class</code>, 参照 <code>pos</code> 的形式</p>
<p><code>sparse_hash_map</code>: STL 型实体; 参照 STL 命名约定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LONGLONG_MAX`: 常量, 如同 `INT_MAX</span><br></pre></td></tr></table></figure>
<h3 id="译者acgtyrant笔记-4">译者（acgtyrant）笔记</h3>
<ol type="1">
<li>感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 query_result, 区分度很好; 再次, 类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如 <code>TextQuery::TextQuery(std::string word) : word_(word) &#123;&#125;</code> , 其中 <code>word_</code> 自然是类内私有成员.</li>
</ol>
<h2 id="注释">8. 注释</h2>
<p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</p>
<p>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你!</p>
<h3 id="注释风格">8.1. 注释风格</h3>
<p><strong>总述</strong></p>
<p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p>
<p><strong>说明</strong></p>
<p><code>//</code> 或 <code>/* */</code> 都可以; 但 <code>//</code> <em>更</em> 常用. 要在如何注释及注释风格上确保统一.</p>
<h3 id="文件注释">8.2. 文件注释</h3>
<p><strong>总述</strong></p>
<p>在每一个文件开头加入版权公告.</p>
<p>文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释.</p>
<p><strong>说明</strong></p>
<h6 id="法律公告和作者信息">法律公告和作者信息</h6>
<p>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)</p>
<p>如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p>
<h6 id="文件内容">文件内容</h6>
<p>如果一个 <code>.h</code> 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系. 一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中.</p>
<p>不要在 <code>.h</code> 和 <code>.cc</code> 之间复制注释, 这样的注释偏离了注释的实际意义.</p>
<h3 id="类注释">8.3. 类注释</h3>
<p><strong>总述</strong></p>
<p>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterates over the contents of a GargantuanTable.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) &#123;</span></span><br><span class="line"><span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    delete iter;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GargantuanTableIterator</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
<p>如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适.</p>
<p>如果类的声明和定义分开了(例如分别放在了 <code>.h</code> 和 <code>.cc</code> 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.</p>
<h3 id="函数注释">8.4. 函数注释</h3>
<p><strong>总述</strong></p>
<p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p>
<p><strong>说明</strong></p>
<h6 id="函数声明">函数声明</h6>
<p>基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p>
<p>函数声明处注释的内容:</p>
<ul>
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>函数是否分配了必须由调用者释放的空间.</li>
<li>参数是否可以为空指针.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ul>
<p>举例如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns an iterator for this table.  It is the client&#x27;s</span></span><br><span class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></span><br><span class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></span><br><span class="line"><span class="comment">// on which the iterator was created has been deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This method is equivalent to:</span></span><br><span class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    iter-&gt;Seek(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    return iter;</span></span><br><span class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></span><br><span class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></span><br><span class="line"><span class="comment">// and avoid the extra seek.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns true if the table cannot hold any more entries.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTableFull</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释. 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</p>
<p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
<h6 id="函数定义">函数定义</h6>
<p>如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p>
<p><em>不要</em> 从 <code>.h</code> 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
<h3 id="变量注释">8.5. 变量注释</h3>
<p><strong>总述</strong></p>
<p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<p><strong>说明</strong></p>
<h6 id="类数据成员-1">类数据成员</h6>
<p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p>
<p>特别地, 如果变量可以接受 <code>NULL</code> 或 <code>-1</code> 等警戒值, 须加以说明. 比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// Used to bounds-check table accesses. -1 means</span></span><br><span class="line"> <span class="comment">// that we don&#x27;t yet know how many entries the table has.</span></span><br><span class="line"> <span class="keyword">int</span> num_total_entries_;</span><br></pre></td></tr></table></figure>
<h6 id="全局变量">全局变量</h6>
<p>和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因. 比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumTestCases = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<h3 id="实现注释">8.6. 实现注释</h3>
<p><strong>总述</strong></p>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
<p><strong>说明</strong></p>
<h6 id="代码前注释">代码前注释</h6>
<p>巧妙或复杂的代码段前要加注释. 比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Divide result by two, taking into account that x</span></span><br><span class="line"><span class="comment">// contains the carry from the add.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result-&gt;<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</span><br><span class="line">  (*result)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="行注释">行注释</h6>
<p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></span><br><span class="line">mmap_budget = max&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;<span class="built_in">length</span>());</span><br><span class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !<span class="built_in">MmapData</span>(mmap_chunk_bytes, mlock))</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">// Error already logged.</span></span><br></pre></td></tr></table></figure>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DoSomething</span>();                  <span class="comment">// Comment here so the comments line up.</span></span><br><span class="line"><span class="built_in">DoSomethingElseThatIsLonger</span>();  <span class="comment">// Two spaces between the code and the comment.</span></span><br><span class="line">&#123; <span class="comment">// One space before comment when opening a new scope is allowed,</span></span><br><span class="line">  <span class="comment">// thus the comment lines up with the following comments and code.</span></span><br><span class="line">  <span class="built_in">DoSomethingElse</span>();  <span class="comment">// Two spaces before line comments normally.</span></span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;string&gt; list&#123;</span><br><span class="line">                    <span class="comment">// Comments in braced lists describe the next element...</span></span><br><span class="line">                    <span class="string">&quot;First item&quot;</span>,</span><br><span class="line">                    <span class="comment">// .. and should be aligned appropriately.</span></span><br><span class="line"><span class="string">&quot;Second item&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">DoSomething</span>(); <span class="comment">/* For trailing block comments, one space is fine. */</span></span><br></pre></td></tr></table></figure>
<h6 id="函数参数注释">函数参数注释</h6>
<p>如果函数参数的意义不明显, 考虑用下面的方式进行弥补:</p>
<ul>
<li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li>
<li>考虑更改函数的签名, 让某个 <code>bool</code> 类型的参数变为 <code>enum</code> 类型, 这样可以让这个参数的值表达其意义.</li>
<li>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li>
<li>用具名变量代替大段而复杂的嵌套表达式.</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ul>
<p>比如下面的示例的对比:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// What are these arguments?</span></span><br><span class="line"><span class="keyword">const</span> DecimalNumber product = <span class="built_in">CalculateProduct</span>(values, <span class="number">7</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ProductOptions options;</span><br><span class="line">options.<span class="built_in">set_precision_decimals</span>(<span class="number">7</span>);</span><br><span class="line">options.<span class="built_in">set_use_cache</span>(ProductOptions::kDontUseCache);</span><br><span class="line"><span class="keyword">const</span> DecimalNumber product =</span><br><span class="line">    <span class="built_in">CalculateProduct</span>(values, options, <span class="comment">/*completion_callback=*/</span><span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>哪个更清晰一目了然.</p>
<h6 id="不允许的行为">不允许的行为</h6>
<p>不要描述显而易见的现象, <em>永远不要</em> 用自然语言翻译代码作为注释, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p>
<p>你所提供的注释应当解释代码 <em>为什么</em> 要这么做和代码的目的, 或者最好是让代码自文档化.</p>
<p>比较这样的注释:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和这样的注释:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Process &quot;element&quot; unless it was already processed.</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsAlreadyProcessed</span>(element)) &#123;</span><br><span class="line">  <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标点-拼写和语法">8.7. 标点, 拼写和语法</h3>
<p><strong>总述</strong></p>
<p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
<p><strong>说明</strong></p>
<p>注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p>
<p>虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有很大帮助.</p>
<h3 id="todo-注释">8.8. TODO 注释</h3>
<p><strong>总述</strong></p>
<p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释.</p>
<p><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 <code>TODO</code> 相关的 issue. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code> 格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 <code>TODO</code> 时, 一般都是写上自己的名字.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span></span><br><span class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></span><br><span class="line"><span class="comment">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span></span><br></pre></td></tr></table></figure>
<p>如果加 <code>TODO</code> 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”).</p>
<h3 id="弃用注释">8.9. 弃用注释</h3>
<p><strong>总述</strong></p>
<p>通过弃用注释（<code>DEPRECATED</code> comments）以标记某接口点已弃用.</p>
<p>您可以写上包含全大写的 <code>DEPRECATED</code> 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p>
<p>在 <code>DEPRECATED</code> 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识.</p>
<p>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点. 在 C++ 中, 你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口.</p>
<p>仅仅标记接口为 <code>DEPRECATED</code> 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p>
<p>修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点. 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p>
<h3 id="译者-yulefox-笔记-3">译者 (YuleFox) 笔记</h3>
<ol type="1">
<li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
<h2 id="格式">9. 格式</h2>
<p>每个人都可能有自己的代码风格和格式, 但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行. 每个人未必能同意下述的每一处格式规则, 而且其中的不少规则需要一定时间的适应, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人轻松地阅读和理解代码.</p>
<p>为了帮助你正确的格式化代码, 我们写了一个 <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs 配置文件</a>.</p>
<h3 id="行长度">9.1. 行长度</h3>
<p><strong>总述</strong></p>
<p>每一行代码字符数不超过 80.</p>
<p>我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要.</p>
<p><strong>优点</strong></p>
<p>提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢?</p>
<p><strong>缺点</strong></p>
<p>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码.</p>
<p><strong>结论</strong></p>
<p>80 个字符是最大值.</p>
<p>如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符.</p>
<p>包含长路径的 <code>#include</code> 语句可以超出80列.</p>
<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">头文件保护</a> 可以无视该原则.</p>
<h3 id="非-ascii-字符">9.2. 非 ASCII 字符</h3>
<p><strong>总述</strong></p>
<p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p>
<p><strong>说明</strong></p>
<p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p>
<p>十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 <code>"\xEF\xBB\xBF"</code>, 或者更简洁地写作 <code>u8"\uFEFF"</code>, 在 Unicode 中是 <em>零宽度 无间断</em> 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p>
<p>(Yang.Y 注: <code>"\xEF\xBB\xBF"</code> 通常用作 UTF-8 with BOM 编码标记)</p>
<p>使用 <code>u8</code> 前缀把带 <code>uXXXX</code> 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8, 输出就会出错.</p>
<p>别用 C++11 的 <code>char16_t</code> 和 <code>char32_t</code>, 它们和 UTF-8 文本没有关系, <code>wchar_t</code> 同理, 除非你写的代码要调用 Windows API, 后者广泛使用了 <code>wchar_t</code>.</p>
<h3 id="空格还是制表位">9.3. 空格还是制表位</h3>
<p><strong>总述</strong></p>
<p>只使用空格, 每次缩进 2 个空格.</p>
<p><strong>说明</strong></p>
<p>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</p>
<h3 id="函数声明与定义">9.4. 函数声明与定义</h3>
<p><strong>总述</strong></p>
<p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##function-calls">函数调用</a> 一致.</p>
<p><strong>说明</strong></p>
<p>函数看上去像这样:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(Type par_name1, Type par_name2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果同一行文本太多, 放不下所有参数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1, Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             Type par_name3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至连第一个参数都放不下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name1,  <span class="comment">// 4 space indent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以下几点:</p>
<ul>
<li>使用好的参数名.</li>
<li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li>
<li>如果返回类型和函数名在一行放不下, 分行.</li>
<li>如果返回类型与函数声明或定义分行了, 不要缩进.</li>
<li>左圆括号总是和函数名在同一行.</li>
<li>函数名和左圆括号间永远没有空格.</li>
<li>圆括号与参数间没有空格.</li>
<li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li>
<li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li>
<li>右圆括号和左大括号间总是有一个空格.</li>
<li>所有形参应尽可能对齐.</li>
<li>缺省缩进为 2 个空格.</li>
<li>换行后的参数保持 4 个空格的缩进.</li>
</ul>
<p>未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>(Foo&amp;&amp;);</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(Foo&amp;&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> radians)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> radians)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="keyword">double</span> <span class="comment">/*radians*/</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 差 - 如果将来有人要实现, 很难猜出变量的作用.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="keyword">double</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">MUST_USE_RESULT <span class="keyword">bool</span> <span class="title">IsOK</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="lambda-表达式-1">9.5. Lambda 表达式</h3>
<p><strong>总述</strong></p>
<p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p>
<p><strong>说明</strong></p>
<p>若用引用捕获, 在变量名和 <code>&amp;</code> 之间不留空格.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> add_to_x = [&amp;x](<span class="keyword">int</span> n) &#123; x += n; &#125;;</span><br></pre></td></tr></table></figure>
<p>短 lambda 就写得和内联函数一样.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::set&lt;<span class="keyword">int</span>&gt; blacklist = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; digits = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">digits.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">end</span>(), [&amp;blacklist](<span class="keyword">int</span> i) &#123;</span><br><span class="line">               <span class="keyword">return</span> blacklist.<span class="built_in">find</span>(i) != blacklist.<span class="built_in">end</span>();</span><br><span class="line">             &#125;),</span><br><span class="line">             digits.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="函数调用">9.6. 函数调用</h3>
<p><strong>总述</strong></p>
<p>要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p>
<p><strong>说明</strong></p>
<p>函数调用遵循如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = <span class="built_in">DoSomething</span>(argument1, argument2, argument3);</span><br></pre></td></tr></table></figure>
<p>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = <span class="built_in">DoSomething</span>(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br></pre></td></tr></table></figure>
<p>参数也可以放在次行, 缩进四格：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="built_in">DoSomething</span>(</span><br><span class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">        argument3, argument4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性. 有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过, 比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办：</p>
<p>如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_heuristic = scores[x] * y + bases[x];</span><br><span class="line"><span class="keyword">bool</span> retval = <span class="built_in">DoSomething</span>(my_heuristic, x, y, z);</span><br></pre></td></tr></table></figure>
<p>或者放着不管, 补充上注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = <span class="built_in">DoSomething</span>(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></span><br><span class="line">                          x, y, z);</span><br></pre></td></tr></table></figure>
<p>如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. 参数的格式处理应当以可读性而非其他作为最重要的原则.</p>
<p>此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></span><br><span class="line">my_widget.<span class="built_in">Transform</span>(x1, x2, x3,</span><br><span class="line">                    y1, y2, y3,</span><br><span class="line">                    z1, z2, z3);</span><br></pre></td></tr></table></figure>
<h3 id="列表初始化格式">9.7. 列表初始化格式</h3>
<p><strong>总述</strong></p>
<p>您平时怎么格式化函数调用, 就怎么格式化 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/##braced-initializer-list">列表初始化</a>.</p>
<p><strong>说明</strong></p>
<p>如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字, 就视作名字长度为零.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一行列表初始化示范.</span></span><br><span class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</span><br><span class="line"><span class="built_in">functioncall</span>(&#123;foo, bar&#125;);</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p&#123;foo, bar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不得不断行时.</span></span><br><span class="line"><span class="built_in">SomeFunction</span>(</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    some_other_function_parameter);</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    some, other, values,</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    SomeOtherType&#123;</span><br><span class="line">        <span class="string">&quot;Very long string requiring the surrounding breaks.&quot;</span>,  <span class="comment">// 非常长的字符串, 前后都需要断行.</span></span><br><span class="line">        some, other values&#125;,</span><br><span class="line">    SomeOtherType&#123;<span class="string">&quot;Slightly shorter string&quot;</span>,  <span class="comment">// 稍短的字符串.</span></span><br><span class="line">                  some, other, values&#125;&#125;;</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    <span class="string">&quot;This is too long to fit all in one line&quot;</span>&#125;;  <span class="comment">// 字符串过长, 因此无法放在同一行.</span></span><br><span class="line">MyType m = &#123;  <span class="comment">// 注意了, 您可以在 &#123; 前断行.</span></span><br><span class="line">    superlongvariablename1,</span><br><span class="line">    superlongvariablename2,</span><br><span class="line">    &#123;<span class="keyword">short</span>, interior, list&#125;,</span><br><span class="line">    &#123;interiorwrappinglist,</span><br><span class="line">     interiorwrappinglist2&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="条件语句">9.8. 条件语句</h3>
<p><strong>总述</strong></p>
<p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.</p>
<p><strong>说明</strong></p>
<p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<p>最常见的是没有空格的格式. 哪一种都可以, 最重要的是 <em>保持一致</em>. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 圆括号里没有空格.</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你更喜欢在圆括号内部加空格:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)     <span class="comment">// 差 - IF 后面没空格.</span></span><br><span class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 差 - &#123; 前面没空格.</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;    <span class="comment">// 变本加厉地差.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 好 - IF 和 &#123; 都与空格紧邻.</span></span><br></pre></td></tr></table></figure>
<p>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 <code>else</code> 子句时使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bar</span>();</span><br></pre></td></tr></table></figure>
<p>如果语句有 <code>else</code> 分支则不允许:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span></span><br><span class="line"><span class="keyword">if</span> (x) <span class="built_in">DoThis</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">DoThat</span>();</span><br></pre></td></tr></table></figure>
<p>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 <code>if</code> 必须总是使用大括号:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果语句中某个 <code>if-else</code> 分支使用了大括号的话, 其它分支也必须使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  foo;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环和开关选择语句">9.9. 循环和开关选择语句</h3>
<p><strong>总述</strong></p>
<p><code>switch</code> 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 <code>&#123;&#125;</code> 或 <code>continue</code>.</p>
<p><strong>说明</strong></p>
<p><code>switch</code> 语句中的 <code>case</code> 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<p>如果有不满足 <code>case</code> 条件的枚举值, <code>switch</code> 应该总是包含一个 <code>default</code> 匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果 <code>default</code> 应该永远执行不到, 简单的加条 <code>assert</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单语句循环里, 括号可用可不用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I love you\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I take it back\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空循环体应使用 <code>&#123;&#125;</code> 或 <code>continue</code>, 而不是一个简单的分号.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 反复循环直到条件失效.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br><span class="line"><span class="keyword">while</span> (condition);  <span class="comment">// 差 - 看起来仅仅只是 while/loop 的部分之一.</span></span><br></pre></td></tr></table></figure>
<h3 id="指针和引用表达式">9.10. 指针和引用表达式</h3>
<p><strong>总述</strong></p>
<p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>) 之后不能有空格.</p>
<p><strong>说明</strong></p>
<p>下面是指针和引用表达式的正确使用范例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>在访问成员时, 句点或箭头前后没有空格.</li>
<li>指针操作符 <code>*</code> 或 <code>&amp;</code> 后没有空格.</li>
</ul>
<p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="keyword">char</span> *c;</span><br><span class="line"><span class="keyword">const</span> string &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="keyword">const</span> string&amp; str;</span><br><span class="line"><span class="keyword">int</span> x, *y;  <span class="comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="keyword">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></span><br><span class="line"><span class="keyword">const</span> string &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格.</span></span><br></pre></td></tr></table></figure>
<p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</p>
<h3 id="布尔表达式">9.11. 布尔表达式</h3>
<p><strong>总述</strong></p>
<p>如果一个布尔表达式超过 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/##line-length">标准行宽</a>, 断行方式要统一一下.</p>
<p><strong>说明</strong></p>
<p>下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</span><br><span class="line">    a_third_thing == a_fourth_thing &amp;&amp;</span><br><span class="line">    yet_another &amp;&amp; last_one) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意, 上例的逻辑与 (<code>&amp;&amp;</code>) 操作符均位于行尾. 这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以. 可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外, 直接用符号形式的操作符, 比如 <code>&amp;&amp;</code> 和 <code>~</code>, 不要用词语形式的 <code>and</code> 和 <code>compl</code>.</p>
<h3 id="函数返回值">9.12. 函数返回值</h3>
<p><strong>总述</strong></p>
<p>不要在 <code>return</code> 表达式里加上非必须的圆括号.</p>
<p><strong>说明</strong></p>
<p>只有在写 <code>x = expr</code> 要加上括号的时候才在 <code>return expr;</code> 里使用括号.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> result;                  <span class="comment">// 返回值很简单, 没有圆括号.</span></span><br><span class="line"><span class="comment">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span></span><br><span class="line"><span class="keyword">return</span> (some_long_condition &amp;&amp;</span><br><span class="line">        another_condition);</span><br><span class="line"><span class="keyword">return</span> (value);                <span class="comment">// 毕竟您从来不会写 var = (value);</span></span><br><span class="line"><span class="keyword">return</span>(result);                <span class="comment">// return 可不是函数！</span></span><br></pre></td></tr></table></figure>
<h3 id="变量及数组初始化">9.13. 变量及数组初始化</h3>
<p><strong>总述</strong></p>
<p>用 <code>=</code>, <code>()</code> 和 <code>&#123;&#125;</code> 均可.</p>
<p><strong>说明</strong></p>
<p>您可以用 <code>=</code>, <code>()</code> 和 <code>&#123;&#125;</code>, 以下的例子都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">&quot;Some Name&quot;</span>)</span></span>;</span><br><span class="line">string name = <span class="string">&quot;Some Name&quot;</span>;</span><br><span class="line">string name&#123;<span class="string">&quot;Some Name&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>请务必小心列表初始化 <code>&#123;...&#125;</code> 用 <code>std::initializer_list</code> 构造函数初始化出的类型. 非空列表初始化就会优先调用 <code>std::initializer_list</code>, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用 <code>std::initializer_list</code> 构造函数, 请改用括号.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 内容为 100 个 1 的向量.</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// 内容为 100 和 1 的向量.</span></span><br></pre></td></tr></table></figure>
<p>此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pi</span><span class="params">(<span class="number">3.14</span>)</span></span>;  <span class="comment">// 好 - pi == 3.</span></span><br><span class="line"><span class="keyword">int</span> pi&#123;<span class="number">3.14</span>&#125;;  <span class="comment">// 编译错误: 缩窄转换.</span></span><br></pre></td></tr></table></figure>
<h3 id="预处理指令">9.14. 预处理指令</h3>
<p><strong>总述</strong></p>
<p>预处理指令不要缩进, 从行首开始.</p>
<p><strong>说明</strong></p>
<p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好 - 指令从行首开始</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line">#<span class="meta"># <span class="meta-keyword">if</span> NOTIFY               <span class="comment">// 非必要 - ## 后跟空格</span></span></span><br><span class="line">    <span class="built_in">NotifyClient</span>();</span><br><span class="line">#<span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 差 - 指令缩进</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING  <span class="comment">// 差 - &quot;#if&quot; 应该放在行开头</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line">    #<span class="meta">#<span class="meta-keyword">endif</span>                <span class="comment">// 差 - &quot;##endif&quot; 不要缩进</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="类格式">9.15. 类格式</h3>
<p><strong>总述</strong></p>
<p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p>
<p><strong>说明</strong></p>
<p>类声明 (下面的代码中缺少注释, 参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/comments/##class-comments">类注释</a>) 的基本格式如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> OtherClass &#123;</span><br><span class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有一个空格的缩进</span></span><br><span class="line">  <span class="built_in">MyClass</span>();  <span class="comment">// 标准的两空格缩进</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">  ~<span class="built_in">MyClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_some_var</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> some_var_;</span><br><span class="line">  <span class="keyword">int</span> some_other_var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意事项:</p>
<ul>
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>
<li>关键词 <code>public:</code>, <code>protected:</code>, <code>private:</code> 要缩进 1 个空格.</li>
<li>除第一个关键词 (一般是 <code>public</code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>
<li>这些关键词后不要保留空行.</li>
<li><code>public</code> 放在最前面, 然后是 <code>protected</code>, 最后是 <code>private</code>.</li>
<li>关于声明顺序的规则请参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##declaration-order">声明顺序</a> 一节.</li>
</ul>
<h3 id="构造函数初始值列表">9.16. 构造函数初始值列表</h3>
<p><strong>总述</strong></p>
<p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p>
<p><strong>说明</strong></p>
<p>下面两种初始值列表方式都可以接受:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="keyword">int</span> var) : <span class="built_in">some_var_</span>(var) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="keyword">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var), <span class="built_in">some_other_var_</span>(var + <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="keyword">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">      <span class="built_in">some_other_var_</span>(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="keyword">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间格式化">9.17. 命名空间格式化</h3>
<p><strong>总述</strong></p>
<p>命名空间内容不缩进.</p>
<p><strong>说明</strong></p>
<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/##namespaces">命名空间</a> 不要增加额外的缩进层次, 例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确. 命名空间内没有额外的缩进.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p>不要在命名空间内缩进:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错, 缩进多余了.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p>声明嵌套命名空间时, 每个命名空间都独立成行.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="keyword">namespace</span> bar &#123;</span><br></pre></td></tr></table></figure>
<h3 id="水平留白">9.19. 水平留白</h3>
<p><strong>总述</strong></p>
<p>水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p>
<p><strong>说明</strong></p>
<h6 id="通用">通用</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="keyword">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  <span class="built_in">Foo</span>(<span class="keyword">int</span> b) : <span class="built_in">Bar</span>(), <span class="built_in">baz_</span>(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开.</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p>
<h6 id="循环和条件语句">循环和条件语句</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span></span><br><span class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号, 但这很少见. 总之要一致.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br></pre></td></tr></table></figure>
<h6 id="操作符">操作符</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h6 id="模板和转换">模板和转换</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line">vector&lt;string&gt; x;</span><br><span class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line">vector&lt;<span class="keyword">char</span> *&gt; x;</span><br></pre></td></tr></table></figure>
<h3 id="垂直留白">9.19. 垂直留白</h3>
<p><strong>总述</strong></p>
<p>垂直留白越少越好.</p>
<p><strong>说明</strong></p>
<p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p>
<p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好.</p>
<p>下面的规则可以让加入的空行更有效:</p>
<ul>
<li>函数体内开头或结尾的空行可读性微乎其微.</li>
<li>在多重 if-else 块里加空行或许有点可读性.</li>
</ul>
<h3 id="译者-yulefox-笔记-4">译者 (YuleFox) 笔记</h3>
<ol type="1">
<li>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</li>
<li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li>
<li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</li>
<li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li>
<li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</li>
<li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</li>
<li><code>.</code>/<code>-&gt;</code> 操作符前后不留空格, <code>*</code>/<code>&amp;</code> 不要前后都留, 一个就可, 靠左靠右依各人喜好;</li>
<li>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</li>
<li>初始化用 <code>=</code> 还是 <code>()</code> 依个人喜好, 统一就好;</li>
<li><code>return</code> 不要加 <code>()</code>;</li>
<li>水平/垂直留白不要滥用, 怎么易读怎么来.</li>
<li>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (<code>.cc</code> 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然.</li>
</ol>
<h3 id="译者acgtyrant笔记-5">译者（acgtyrant）笔记</h3>
<ol type="1">
<li>80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块, 超多重函数调用等等.</li>
<li>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码, 不像奇葩的 Windows.</li>
<li>Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号. Apple 正好 <a href="http://coolshell.cn/articles/11112.html">有栽过跟头</a> .</li>
<li>其实我主张指针／地址操作符与变量名紧邻, <code>int* a, b</code> vs <code>int *a, b</code>, 新手会误以为前者的 <code>b</code> 是 <code>int *</code> 变量, 但后者就不一样了, 高下立判.</li>
<li>在这风格指南里我才刚知道 C++ 原来还有所谓的 <a href="http://en.cppreference.com/w/cpp/language/operator_alternative">Alternative operator representations</a>, 大概没人用吧.</li>
<li>注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事, 我就差点混淆了它们的翻译.</li>
<li>事实上, 如果您熟悉英语本身的书写规则, 就会发现该风格指南在格式上的规定与英语语法相当一脉相承. 比如普通标点符号和单词后面还有文本的话, 总会留一个空格; 特殊符号与单词之间就不用留了, 比如 <code>if (true)</code> 中的圆括号与 <code>true</code>.</li>
<li>本风格指南没有明确规定 void 函数里要不要用 return 语句, 不过就 Google 开源项目 leveldb 并没有写; 此外从 <a href="http://stackoverflow.com/questions/9316717/is-a-blank-return-statement-at-the-end-of-a-function-whos-return-type-is-void-ne">Is a blank return statement at the end of a function whos return type is void necessary?</a> 来看, <code>return;</code> 比 <code>return ;</code> 更约定俗成（事实上 cpplint 会对后者报错, 指出分号前有多余的空格）, 且可用来提前跳出函数栈.</li>
</ol>
<h2 id="规则特例">10. 规则特例</h2>
<p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p>
<h3 id="现有不合规范的代码">10.1. 现有不合规范的代码</h3>
<p><strong>总述</strong></p>
<p>对于现有不符合既定编程风格的代码可以网开一面.</p>
<p><strong>说明</strong></p>
<p>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住, <em>一致性</em> 也包括原有的一致性.</p>
<h3 id="windows-代码">10.2. Windows 代码</h3>
<p><strong>总述</strong></p>
<p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p>
<p><strong>说明</strong></p>
<p>如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p>
<ul>
<li>不要使用匈牙利命名法 (比如把整型变量命名成 <code>iNum</code>). 使用 Google 命名约定, 包括对源文件使用 <code>.cc</code> 扩展名.</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 <code>DWORD</code>, <code>HANDLE</code> 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 <code>const TCHAR *</code> 而不是 <code>LPCTSTR</code>.</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有警告(warnings)当作错误(errors)处理.</li>
<li>不要使用 <code>##pragma once</code>; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 <code>##ifndef SRC_DIR_BAR_H_</code>, 参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/##define-guard">##define 保护</a> 一节).</li>
<li>除非万不得已, 不要使用任何非标准的扩展, 如 <code>##pragma</code> 和 <code>__declspec</code>. 使用 <code>__declspec(dllimport)</code> 和 <code>__declspec(dllexport)</code> 是允许的, 但必须通过宏来使用, 比如 <code>DLLIMPORT</code> 和 <code>DLLEXPORT</code>, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li>
</ul>
<p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p>
<ul>
<li>通常我们 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/##multiple-inheritance">禁止使用多重继承</a>, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 <code>_ATL_NO_EXCEPTIONS</code> 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理).</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 <code>StdAfx.h</code> 或 <code>precompile.h</code> 的文件. 为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 <code>precompile.cc</code> 中), 使用 <code>/FI</code> 编译器选项以自动包含该文件.</li>
<li>资源头文件通常命名为 <code>resource.h</code> 且只包含宏, 这一文件不需要遵守本风格指南.</li>
</ul>
<h2 id="结束语">11. 结束语</h2>
<p>运用常识和判断力, 并且 <em>保持一致</em>.</p>
<p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 <code>if</code> 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做.</p>
<p>风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏, 所以要尽量避免.</p>
<p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
  </entry>
</search>
